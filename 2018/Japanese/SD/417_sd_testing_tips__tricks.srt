
1
00:00:07,140 --> 00:00:16,650
(音楽)

2
00:00:24,591 --> 00:00:31,865
(拍手)

3
00:00:32,366 --> 00:00:35,469
こんにちは
当セッションへようこそ

4
00:00:36,069 --> 00:00:37,871
ブライアンです

5
00:00:38,272 --> 00:00:41,008
同僚のスチュアートと私が

6
00:00:41,108 --> 00:00:44,811
テストのテクニックを
ご紹介します

7
00:00:47,848 --> 00:00:52,452
WWDC開催にあたり 会場周辺の
見どころを検索できる―

8
00:00:52,553 --> 00:00:56,757
アプリケーションがあったら
便利だと我々は考えました

9
00:00:57,724 --> 00:01:03,730
このアプリケーションで
周辺のスポットを探すと

10
00:00:57,724 --> 00:01:03,730
このアプリケーションで
周辺のスポットを探すと

11
00:01:03,830 --> 00:01:06,033
現在地からの距離が出ます

12
00:01:07,568 --> 00:01:12,005
もちろん
テストスイートが必要です

13
00:01:12,339 --> 00:01:17,311
開発中のどの時点であっても
コードが正しく動くと―

14
00:01:17,411 --> 00:01:19,179
確認するためです

15
00:01:21,849 --> 00:01:26,787
テストを記述する際に
役立つテクニックを

16
00:01:26,887 --> 00:01:28,789
４つ ご紹介します

17
00:01:30,224 --> 00:01:33,760
ネットワークコードのテスト

18
00:01:34,862 --> 00:01:39,032
Foundation
通知オブジェクトのテスト

19
00:01:40,334 --> 00:01:44,872
プロトコルで
モックを作成するテスト

20
00:01:45,606 --> 00:01:49,009
テストスピードを
高速で維持する方法です

21
00:01:52,379 --> 00:01:54,481
最初はネットワークです

22
00:01:55,782 --> 00:01:57,885
動的コンテンツ更新のため

23
00:01:57,985 --> 00:02:01,788
リモートウェブサーバから
データを読み込ませます

24
00:01:57,985 --> 00:02:01,788
リモートウェブサーバから
データを読み込ませます

25
00:02:02,723 --> 00:02:06,894
そこでネットワークコードの
テストのコツです

26
00:02:08,729 --> 00:02:11,899
まず昨年を振り返りましょう

27
00:02:12,299 --> 00:02:16,770
WWDC 2017の
“Engineering for Testability”

28
00:02:17,004 --> 00:02:21,708
徹底度と理解性 実行速度の
バランスを保った―

29
00:02:21,875 --> 00:02:26,547
テストスイート作成を
ピラミッドで説明しました

30
00:02:28,615 --> 00:02:34,454
理想的なテストスイートは
ユニットテストを中心とし

31
00:02:34,555 --> 00:02:38,258
各クラスやメソッドを
対象とします

32
00:02:39,626 --> 00:02:42,529
その特徴は 読みやすく―

33
00:02:42,896 --> 00:02:46,366
不合格時に
はっきり表示することです

34
00:02:46,967 --> 00:02:48,669
また実行速度が速く―

35
00:02:48,769 --> 00:02:52,306
毎分 何千ものテストを
実行します

36
00:02:54,675 --> 00:02:59,546
それを補完するのが
インテグレーションテストです

37
00:03:00,113 --> 00:03:04,318
個別サブシステムや
クラスクラスタを対象とし

38
00:03:04,852 --> 00:03:09,523
それらの連携を
数秒以内に確認します

39
00:03:11,758 --> 00:03:15,362
最上部はエンドツーエンドの
システムテストです

40
00:03:15,462 --> 00:03:18,198
多くは
UIテストの形を取り―

41
00:03:18,365 --> 00:03:23,537
エンドユーザと同じように
デバイス上で動かします

42
00:03:24,438 --> 00:03:26,940
各部の接続状況と―

43
00:03:27,040 --> 00:03:31,912
OSや外部リソースとの
相互作用を確認します

44
00:03:33,680 --> 00:03:35,916
このモデルの
テストスイートで―

45
00:03:36,016 --> 00:03:39,920
コードベースが全体で
いかに機能するか分かります

46
00:03:43,724 --> 00:03:48,829
ネットワークスタックのテストに
このモデルを使い

47
00:03:48,929 --> 00:03:51,965
テストスイート作成の
指針としました

48
00:03:53,267 --> 00:03:57,671
これがネットワークリクエストと
データフィード時の―

49
00:03:57,771 --> 00:03:59,940
上位レベルのデータフローです

50
00:04:02,276 --> 00:04:04,278
初期のプロトタイプでは

51
00:04:04,478 --> 00:04:08,815
View Controllerの
１メソッドで行っていました

52
00:04:09,049 --> 00:04:10,584
このようにです

53
00:04:12,586 --> 00:04:15,656
ユーザの位置で
パラメータを取ります

54
00:04:17,357 --> 00:04:19,091
位置をクエリパラメータとし

55
00:04:19,192 --> 00:04:23,630
サービスAPIエンドポイントの
URLを生成

56
00:04:26,066 --> 00:04:29,169
そしてFoundationの
URLSessionを使い

57
00:04:29,269 --> 00:04:32,873
URLのGETリクエストのため
データタスクを作成

58
00:04:34,875 --> 00:04:38,278
サーバが応答して
データをアンラップ

59
00:04:39,413 --> 00:04:42,616
FoundationのJSONDecoderで
デコードし

60
00:04:42,883 --> 00:04:45,419
PointOfInterest値の配列へ

61
00:04:45,519 --> 00:04:50,057
これは他で宣言した構造体で
プロトコルに準拠します

62
00:04:51,792 --> 00:04:57,564
それをプロパティに保存し
テーブルビューで表示

63
00:05:00,267 --> 00:05:05,572
たった15行のコードで
以上のことができました

64
00:05:05,739 --> 00:05:08,408
SwiftとFoundationの
おかげです

65
00:05:09,443 --> 00:05:12,079
しかし
１つのメソッドにすると―

66
00:05:12,179 --> 00:05:16,984
コードのテストしやすさと
保守性が問題になります

67
00:05:20,888 --> 00:05:23,390
ピラミッドの最下部を見ると

68
00:05:23,490 --> 00:05:28,996
各フローのユニットテストを
記述することが重要です

69
00:05:30,831 --> 00:05:35,269
まずリクエスト準備と
応答の解析についてです

70
00:05:38,739 --> 00:05:41,375
テストしやすいコードに
するために―

71
00:05:41,842 --> 00:05:44,478
View Controllerから
取り出して

72
00:05:45,512 --> 00:05:49,583
PointsOfInterestRequest型に
２つのメソッドを作成

73
00:05:50,517 --> 00:05:56,056
２つの分離メソッドが
それぞれ 値を入力として

74
00:05:56,223 --> 00:06:00,394
副作用なしで
出力値に変換するのです

75
00:05:56,223 --> 00:06:00,394
副作用なしで
出力値に変換するのです

76
00:06:03,330 --> 00:06:08,135
コードのユニットテストを
記述しやすくなります

77
00:06:09,469 --> 00:06:11,772
makeRequestメソッドの
テストでは

78
00:06:11,972 --> 00:06:16,009
サンプルを作って
メソッドに渡し

79
00:06:16,176 --> 00:06:19,213
戻り値について
アサーションを作成

80
00:06:22,082 --> 00:06:26,220
応答の解析のテストでも
モックJSONを渡し―

81
00:06:26,320 --> 00:06:28,922
解析結果について
アサーションを作成

82
00:06:31,458 --> 00:06:34,261
もう１つ
注目すべき点があります

83
00:06:34,361 --> 00:06:39,299
throwsのテストメソッドに
XCTestサポートを活用し

84
00:06:39,399 --> 00:06:45,105
do-catchブロックは不要で
tryを使えるのです

85
00:06:49,209 --> 00:06:52,412
次はURLSessionとの関係です

86
00:06:54,548 --> 00:06:57,184
再びView Controllerから
取り出し

87
00:06:57,951 --> 00:07:04,591
シグネチャが合うメソッドと
APIRequestプロトコルを作成

88
00:06:57,951 --> 00:07:04,591
シグネチャが合うメソッドと
APIRequestプロトコルを作成

89
00:07:05,459 --> 00:07:08,629
使用している
APIRequestLoaderクラスは

90
00:07:09,530 --> 00:07:14,268
リクエスト型とURLSessionで
初期化されています

91
00:07:17,437 --> 00:07:20,507
ここの
loadAPIRequestメソッドは

92
00:07:20,607 --> 00:07:24,878
APIRequest値で
URLリクエストを作成

93
00:07:25,345 --> 00:07:27,614
URLSessionにフィードし

94
00:07:28,382 --> 00:07:31,451
APIRequestで応答を解析

95
00:07:34,822 --> 00:07:37,791
ユニットテストの記述を
続けられますが―

96
00:07:37,891 --> 00:07:40,394
ピラミッドの上部へ移ります

97
00:07:40,494 --> 00:07:45,065
データフローをカバーする
インテグレーションテストです

98
00:07:46,934 --> 00:07:51,839
テストスイートの
この層でテストしたいのは

99
00:07:51,939 --> 00:07:55,609
URLSessionとの連携です

100
00:07:56,977 --> 00:07:59,746
Foundationの
URLローディングシステムが

101
00:07:59,847 --> 00:08:02,015
フックを提供しています

102
00:07:59,847 --> 00:08:02,015
フックを提供しています

103
00:08:04,151 --> 00:08:09,456
ネットワークリクエストに使う
上位レベルのAPIを提供し

104
00:08:10,424 --> 00:08:14,828
インフライト要求を代表する
URLSessionDataTaskを生成します

105
00:08:15,796 --> 00:08:21,034
背後には下位レベルAPIの
URLProtocolがあります

106
00:08:21,301 --> 00:08:24,638
ネットワーク接続をオープンし

107
00:08:24,738 --> 00:08:28,008
リクエストを記述し
応答をリードバックします

108
00:08:29,743 --> 00:08:32,412
URLProtocolは
サブクラス化され

109
00:08:32,513 --> 00:08:36,250
URLローディングシステムの
拡張性を高めます

110
00:08:39,153 --> 00:08:45,192
FoundationはHTTPSのような
ビルトインプロトコルを提供

111
00:08:45,592 --> 00:08:49,630
テストではモックプロトコルで
オーバーライドできます

112
00:08:49,863 --> 00:08:53,300
リクエストについての
アサーションを作成し

113
00:08:53,967 --> 00:08:55,936
モック応答を返せます

114
00:08:59,740 --> 00:09:02,543
URLProtocolはプログレスを

115
00:08:59,740 --> 00:09:02,543
URLProtocolはプログレスを

116
00:09:02,643 --> 00:09:05,579
URLProtocolClientを通じ
システムに伝達

117
00:09:07,948 --> 00:09:10,083
このように使えます

118
00:09:10,951 --> 00:09:14,221
テストバンドルに
MockURLProtocolを作成

119
00:09:14,755 --> 00:09:17,357
canInitリクエストを
オーバーライドし

120
00:09:17,457 --> 00:09:21,562
あらゆるリクエストに
興味があると示します

121
00:09:23,730 --> 00:09:26,366
canonicalRequestを
実装しますが

122
00:09:26,466 --> 00:09:30,337
startLoadingと
stopLoadingも実装

123
00:09:34,741 --> 00:09:37,911
このURLProtocolに
フックするため―

124
00:09:38,011 --> 00:09:42,282
requestHandlerを
テストに提供します

125
00:09:44,852 --> 00:09:47,054
URLSessionタスクが始まると

126
00:09:47,154 --> 00:09:50,424
URLProtocolサブクラスを
インスタンス化

127
00:09:50,524 --> 00:09:55,729
URLRequest値とURLProtocol
クライアントインスタンスを提供

128
00:09:57,197 --> 00:09:59,533
そして
startLoadingを呼び出し

129
00:09:59,633 --> 00:10:03,136
テストサブセットに
requestHandlerを提供

130
00:09:59,633 --> 00:10:03,136
テストサブセットに
requestHandlerを提供

131
00:10:03,403 --> 00:10:06,306
URLRequestをパラメータとし
呼び出します

132
00:10:07,474 --> 00:10:10,644
戻ってきたものを
システムに渡します

133
00:10:10,878 --> 00:10:13,780
URLレスポンスと
データの場合も

134
00:10:14,681 --> 00:10:16,049
エラーの場合もあります

135
00:10:18,552 --> 00:10:20,787
テストリクエストの
キャンセルは

136
00:10:20,888 --> 00:10:24,925
stopLoadingの実装と
同様です

137
00:10:28,829 --> 00:10:32,199
スタブプロトコルがあれば
テストを記述できます

138
00:10:33,400 --> 00:10:36,503
APIRequestLoaderを作成

139
00:10:36,603 --> 00:10:38,705
構成内容は
リクエスト型と―

140
00:10:39,072 --> 00:10:43,143
URLProtocolのため
設定されたURLSessionです

141
00:10:46,246 --> 00:10:51,084
テストベースにrequestHandlerを
MockURLProtocolで設定

142
00:10:51,718 --> 00:10:54,955
リクエストについて
アサーションを作成し

143
00:10:55,789 --> 00:10:57,925
スタブ応答を提供します

144
00:10:59,726 --> 00:11:02,196
そしてloadAPIRequestを
呼び出します

145
00:10:59,726 --> 00:11:02,196
そしてloadAPIRequestを
呼び出します

146
00:11:02,996 --> 00:11:05,365
完了ブロックの
呼び出しを待ち

147
00:11:06,099 --> 00:11:08,702
解析した応答について
アサーションを作成

148
00:11:10,938 --> 00:11:16,310
この層のテストの実行により
コードの連携と―

149
00:11:16,410 --> 00:11:19,479
システムとの統合が
確認できます

150
00:11:19,713 --> 00:11:22,916
データタスクで
レジュームを呼び忘れると

151
00:11:23,016 --> 00:11:26,286
このテストは
不合格となります

152
00:11:26,520 --> 00:11:28,956
皆さんも経験があるでしょう

153
00:11:33,260 --> 00:11:38,966
最後に エンドツーエンドの
システムテストが重要です

154
00:11:39,766 --> 00:11:43,103
UIテストが効果的でしょう

155
00:11:44,371 --> 00:11:46,173
UIテストについては

156
00:11:46,273 --> 00:11:51,144
WWDC 2015の“UI Testing in
Xcode”をご参照ください

157
00:11:54,014 --> 00:11:59,686
エンドツーエンドのテストを
記述する際に問題があります

158
00:12:00,120 --> 00:12:02,422
不合格となった場合に―

159
00:12:02,523 --> 00:12:06,660
どこから原因を探るかと
いうことです

160
00:12:07,961 --> 00:12:11,131
我々は
この問題への対策として―

161
00:12:11,231 --> 00:12:14,168
モックサーバの
ローカルインスタンスを設定

162
00:12:14,268 --> 00:12:19,173
UIテストを中断し モックに
リクエストさせました

163
00:12:19,640 --> 00:12:22,242
データをコントロールでき

164
00:12:22,342 --> 00:12:25,779
UIテストの信頼性が
高まりました

165
00:12:28,582 --> 00:12:32,085
この点でモックサーバは
役に立ちますが―

166
00:12:32,186 --> 00:12:36,290
本物のサーバに
リクエストするテストも有益です

167
00:12:38,959 --> 00:12:43,330
そこでユニットテストバンドルで
テストをします

168
00:12:43,430 --> 00:12:46,633
アプリケーションに対し
直接 呼び出すテストで

169
00:12:46,900 --> 00:12:50,170
本物のサーバに直接
リクエストさせるのです

170
00:12:51,004 --> 00:12:53,607
するとアプリケーションと
同じように―

171
00:12:53,707 --> 00:12:57,044
サーバもリクエストを
受け取るか確認できます

172
00:12:57,477 --> 00:13:01,715
また同時にUIを
テストする際の問題もなく

173
00:12:57,477 --> 00:13:01,715
また同時にUIを
テストする際の問題もなく

174
00:13:01,815 --> 00:13:04,918
サーバの応答を解析できるか
確認できます

175
00:13:10,290 --> 00:13:12,025
まとめましょう

176
00:13:12,125 --> 00:13:14,161
コードを小さく分割し

177
00:13:14,261 --> 00:13:18,165
ユニットテストを
実行しやすくしました

178
00:13:19,500 --> 00:13:22,836
ネットワークリクエストの
モックに

179
00:13:22,936 --> 00:13:25,038
URLProtocolを使用しました

180
00:13:26,306 --> 00:13:31,612
また バランスのいい
テストスイートの作成を

181
00:13:31,712 --> 00:13:34,148
ピラミッドモデルで
説明しました

182
00:13:35,549 --> 00:13:39,520
この後はスチュアートが
テクニックをお教えします

183
00:13:40,087 --> 00:13:43,090
(拍手)

184
00:13:43,190 --> 00:13:44,324
ありがとう

185
00:13:46,493 --> 00:13:47,895
ありがとう　ブライアン

186
00:13:48,061 --> 00:13:53,066
まず 通知のテストについての
ベストプラクティスをお教えします

187
00:13:54,668 --> 00:14:00,174
ここで“通知”というのは
Foundationレベルの通知で

188
00:13:54,668 --> 00:14:00,174
ここで“通知”というのは
Foundationレベルの通知で

189
00:14:00,274 --> 00:14:02,876
NSNotificationと
Objective-Cです

190
00:14:03,243 --> 00:14:07,114
通知の監視を
テストすることもあれば

191
00:14:07,214 --> 00:14:11,018
通知の送信を
テストする場合もあります

192
00:14:11,418 --> 00:14:14,621
通知は１対多数の
コミュニケーションです

193
00:14:14,721 --> 00:14:20,761
つまり１つの通知の受け手は
アプリケーション全体や―

194
00:14:20,861 --> 00:14:24,198
フレームワークコード内に
複数います

195
00:14:24,298 --> 00:14:29,603
そこで通知のテストでは
分離することが重要です

196
00:14:29,703 --> 00:14:33,440
意図しない副作用を避け

197
00:14:33,540 --> 00:14:37,311
信頼性を損なうのを
防ぐためです

198
00:14:37,511 --> 00:14:40,681
この問題のあるコードを
見ましょう

199
00:14:41,248 --> 00:14:45,819
PointsOfInterest
TableViewControllerです

200
00:14:46,086 --> 00:14:49,356
近くのスポットを
テーブルビューで表示し

201
00:14:49,656 --> 00:14:54,461
位置承認に変更があると
データを再読み込みします

202
00:14:54,628 --> 00:14:57,331
authChangedという通知を

203
00:14:57,431 --> 00:15:00,467
CurrentLocationProvider
クラスから監視します

204
00:14:57,431 --> 00:15:00,467
CurrentLocationProvider
クラスから監視します

205
00:15:00,667 --> 00:15:04,338
通知を監視する時
必要なら 再読み込みし

206
00:15:04,438 --> 00:15:07,908
目的のため
フラグを設定します

207
00:15:08,242 --> 00:15:13,981
通知を受け取ったかを
フラグでチェックするのです

208
00:15:14,481 --> 00:15:19,019
デフォルトの通知センターで
オブザーバを追加しています

209
00:15:19,786 --> 00:15:23,023
ユニットテストは
どうなるでしょうか

210
00:15:23,757 --> 00:15:29,163
authChangedNotificationを
ポストしてシミュレートし

211
00:15:29,263 --> 00:15:33,433
そしてデフォルトの
NotificationCenterにポスト

212
00:15:33,967 --> 00:15:39,206
このテストは機能しても
未知の副作用が出る可能性も

213
00:15:39,373 --> 00:15:41,975
システム通知に多いですが―

214
00:15:42,075 --> 00:15:48,682
多くのレイヤに監視され
未知の副作用があり得ます

215
00:15:48,815 --> 00:15:51,418
テスト速度が落ちることも

216
00:15:51,518 --> 00:15:55,055
そこでコードを分離して
テストするのです

217
00:15:56,623 --> 00:16:00,127
あるテクニックで
うまく分離できます

218
00:15:56,623 --> 00:16:00,127
あるテクニックで
うまく分離できます

219
00:16:00,227 --> 00:16:04,932
通知センターは
複数のインスタンスがあります

220
00:16:05,432 --> 00:16:10,070
デフォルトのインスタンスが
ありますが―

221
00:16:10,170 --> 00:16:13,273
必要に応じ
インスタンスを生成します

222
00:16:13,373 --> 00:16:16,009
これが分離のカギとなるのです

223
00:16:16,343 --> 00:16:20,714
新しいNotificationCenterを
作成し

224
00:16:20,814 --> 00:16:24,885
デフォルトのインスタンスの
代わりに使うのです

225
00:16:25,486 --> 00:16:28,088
依存性の注入とも呼ばれます

226
00:16:28,422 --> 00:16:31,124
View Controllerで
使ってみましょう

227
00:16:31,825 --> 00:16:35,696
デフォルトのNotificationCenterを
使った元のコードを

228
00:16:35,796 --> 00:16:38,499
修正したものです

229
00:16:39,399 --> 00:16:44,338
パラメータとプロパティを
イニシャライザに加えました

230
00:16:44,738 --> 00:16:49,810
オブザーバを加えず
新しいプロパティを使います

231
00:16:51,912 --> 00:16:56,216
また.defaultのデフォルトの
パラメータ値を加え

232
00:16:56,316 --> 00:16:59,153
既存コードの破壊を避けます

233
00:16:59,253 --> 00:17:04,124
新しいパラメータを渡すのは
ユニットテストだけです

234
00:16:59,253 --> 00:17:04,124
新しいパラメータを渡すのは
ユニットテストだけです

235
00:17:05,893 --> 00:17:08,194
ではテストを更新します

236
00:17:08,796 --> 00:17:10,597
元のテストコードです

237
00:17:10,931 --> 00:17:14,768
修正して 分離した
NotificationCenterを使います

238
00:17:18,070 --> 00:17:21,575
このように通知の監視を
テストしますが―

239
00:17:21,675 --> 00:17:24,645
通知の送信のテストは？

240
00:17:25,479 --> 00:17:29,082
分離したNotificationCenterを
使いますが―

241
00:17:29,182 --> 00:17:34,354
ビルトインExpectation APIを
活用します

242
00:17:35,522 --> 00:17:40,227
我々のアプリケーションの
CurrentLocationProviderです

243
00:17:40,460 --> 00:17:42,896
このクラスは後で話しますが

244
00:17:42,996 --> 00:17:46,667
アプリケーションの位置承認の
変更を―

245
00:17:46,767 --> 00:17:51,071
他のクラスに
通知を送信して知らせます

246
00:17:51,905 --> 00:17:54,474
デフォルトの
NotificationCenterを

247
00:17:54,575 --> 00:17:56,577
ハードコードしています

248
00:17:58,512 --> 00:18:00,881
このユニットテストを
記述しました

249
00:17:58,512 --> 00:18:00,881
このユニットテストを
記述しました

250
00:18:00,981 --> 00:18:02,950
notifyAuthChangedメソッドが
呼ばれたら―

251
00:18:03,050 --> 00:18:05,953
通知を送信するか確認します

252
00:18:06,887 --> 00:18:08,522
ここでは
addObserverメソッドで

253
00:18:08,622 --> 00:18:12,793
ブロックベースの
オブザーバを作成し

254
00:18:12,893 --> 00:18:15,362
ブロックの中に
移動させています

255
00:18:16,063 --> 00:18:22,402
ビルトインのXCTNSNotification
Expectation APIを使い

256
00:18:22,503 --> 00:18:26,640
NotificationCenter
オブザーバを作成できます

257
00:18:27,508 --> 00:18:32,045
コードの行数を減らせる
いい改善です

258
00:18:32,679 --> 00:18:37,317
しかしデフォルトの
NotificationCenterの使用は

259
00:18:37,417 --> 00:18:38,852
再考すべきでしょう

260
00:18:40,087 --> 00:18:41,655
元のコードです

261
00:18:42,523 --> 00:18:47,761
イニシャライザに 分離した
NotificationCenterを入れ

262
00:18:47,861 --> 00:18:50,998
デフォルトの代わりに
使いましょう

263
00:18:53,667 --> 00:18:55,636
テストコードに戻り

264
00:18:56,136 --> 00:18:59,840
新しいNotificationCenterを
対象に渡すため修正

265
00:19:00,274 --> 00:19:02,709
しかしExpectationに
ご注目を

266
00:19:03,343 --> 00:19:07,514
Centerで
通知を受け取るなら―

267
00:19:07,614 --> 00:19:09,950
NotificationCenter
パラメータを

268
00:19:10,050 --> 00:19:12,186
Expectationの
イニシャライザに渡せます

269
00:19:13,687 --> 00:19:18,826
またExpectationの
タイムアウトが“０”なのは

270
00:19:18,926 --> 00:19:23,330
待つ前に実行されることを
期待しているからです

271
00:19:23,831 --> 00:19:26,400
notifyAuthChanged
メソッドが戻る前に―

272
00:19:26,500 --> 00:19:29,770
通知は
送信されるべきだからです

273
00:19:30,671 --> 00:19:33,941
この２つの
テストテクニックを使って

274
00:19:34,041 --> 00:19:36,844
テストを分離させられます

275
00:19:36,944 --> 00:19:40,747
デフォルトのパラメータ値を
指定したので―

276
00:19:40,848 --> 00:19:43,817
既存のコードを
修正せずに済みます

277
00:19:47,788 --> 00:19:51,658
ユニットテスト記述に
伴う問題をお話しします

278
00:19:51,758 --> 00:19:54,194
外部クラスとのやり取りです

279
00:19:55,863 --> 00:19:59,099
アプリケーションの開発中に
クラスが―

280
00:19:59,199 --> 00:20:05,472
アプリケーション内やSDKの
別のクラスとやり取りします

281
00:19:59,199 --> 00:20:05,472
アプリケーション内やSDKの
別のクラスとやり取りします

282
00:20:05,572 --> 00:20:08,575
外部クラスを作成するのは
難しいため―

283
00:20:08,675 --> 00:20:12,513
テストの記述も困難だと
分かりますね

284
00:20:12,846 --> 00:20:17,618
直接 作成されないAPIだと
特によく起こります

285
00:20:17,718 --> 00:20:21,989
デリゲートメソッドがあれば
さらに困難です

286
00:20:22,823 --> 00:20:25,826
プロトコルを使って
解決しましょう

287
00:20:25,926 --> 00:20:28,829
外部クラスとのやり取りを
モックし

288
00:20:28,929 --> 00:20:32,332
テストの信頼性は
損ないません

289
00:20:34,067 --> 00:20:39,172
CurrentLocationProviderクラスで
CoreLocationを使っています

290
00:20:39,807 --> 00:20:43,710
CLLocationManagerを
イニシャライザに構成し

291
00:20:43,811 --> 00:20:47,915
自身をデリゲートと
設定しています

292
00:20:49,983 --> 00:20:53,954
checkCurrentLocationという
メソッドです

293
00:20:54,087 --> 00:20:56,990
現在地をリクエストし
完了ブロックで―

294
00:20:57,090 --> 00:20:59,960
スポットかどうか返します

295
00:21:00,794 --> 00:21:05,332
requestLocationメソッドを
呼び出しています

296
00:21:05,833 --> 00:21:09,169
すると現在地の取得を試みて

297
00:21:09,269 --> 00:21:11,939
最後にデリゲートメソッドを
呼びます

298
00:21:12,039 --> 00:21:14,007
見てみましょう

299
00:21:15,275 --> 00:21:16,176
extensionを使い

300
00:21:16,276 --> 00:21:19,646
CLLocationManagerDelegate
プロトコルに準拠

301
00:21:19,746 --> 00:21:21,949
保存された完了ブロックを
呼びます

302
00:21:22,349 --> 00:21:25,586
ではユニットテストを
書きましょう

303
00:21:26,720 --> 00:21:29,389
全体を読んでみると―

304
00:21:29,490 --> 00:21:33,393
まずCurrentLocationProviderを
作成して

305
00:21:33,494 --> 00:21:37,297
目標精度とデリゲート設定を
確認します

306
00:21:37,397 --> 00:21:38,799
順調ですね

307
00:21:39,099 --> 00:21:40,934
ここから ご注意を

308
00:21:41,235 --> 00:21:46,039
checkCurrentLocationメソッドを
確認したいですが―

309
00:21:46,140 --> 00:21:48,008
問題があります

310
00:21:48,108 --> 00:21:51,812
requestLocationが
いつ呼ばれるか分かりません

311
00:21:51,912 --> 00:21:56,283
CLLocationManager上の
メソッドだからです

312
00:21:57,451 --> 00:22:00,154
もう１つ問題なのは―

313
00:21:57,451 --> 00:22:00,154
もう１つ問題なのは―

314
00:22:00,254 --> 00:22:03,557
CoreLocationが
ユーザ認証を求めることです

315
00:22:03,657 --> 00:22:07,794
認証していないと
許可ダイアログが表示されます

316
00:22:08,295 --> 00:22:10,864
デバイスの状態に左右され

317
00:22:10,964 --> 00:22:14,535
テストが不合格に
なりやすくなります

318
00:22:16,236 --> 00:22:21,475
この問題に対処するには
外部クラスのサブクラス化と

319
00:22:21,575 --> 00:22:24,578
メソッドの
オーバーライドです

320
00:22:24,778 --> 00:22:25,679
例えば―

321
00:22:25,779 --> 00:22:28,982
CLLocationManagerの
サブクラス化と

322
00:22:29,082 --> 00:22:31,785
requestLocationメソッドの
オーバーライドです

323
00:22:32,052 --> 00:22:35,022
最初はよくてもリスクが高いです

324
00:22:35,522 --> 00:22:40,160
SDKからのクラスの一部は
サブクラス化に向いておらず

325
00:22:40,594 --> 00:22:45,799
スーパークラスのイニシャライザを
呼ぶ必要もあります

326
00:22:46,166 --> 00:22:47,668
しかし主要な問題は―

327
00:22:47,768 --> 00:22:52,039
メソッド呼び出しのため
コードを修正した時で

328
00:22:52,139 --> 00:22:56,543
そのメソッドの
オーバーライドが必要です

329
00:22:57,010 --> 00:23:02,416
別のメソッドを呼び出したと
コンパイラが通知せず―

330
00:22:57,010 --> 00:23:02,416
別のメソッドを呼び出したと
コンパイラが通知せず―

331
00:23:02,516 --> 00:23:04,985
つい忘れて
テストが失敗します

332
00:23:05,452 --> 00:23:07,287
この方法は お勧めしません

333
00:23:07,387 --> 00:23:11,291
プロトコルで外部の型を
モックするのがいい

334
00:23:11,391 --> 00:23:13,160
その方法を説明します

335
00:23:14,461 --> 00:23:16,130
元のコードです

336
00:23:16,230 --> 00:23:19,333
まず 新しいプロトコルを
定義します

337
00:23:20,234 --> 00:23:22,803
LocationFetcherと
名づけました

338
00:23:22,903 --> 00:23:28,342
CLLocationManagerから使う
メソッドとプロパティを含みます

339
00:23:28,942 --> 00:23:31,979
メンバーの名前と型が一致し

340
00:23:32,079 --> 00:23:37,284
CLLocationManagerに
extensionを作成できます

341
00:23:37,384 --> 00:23:39,620
要件を満たすからです

342
00:23:41,255 --> 00:23:44,925
locationManagerプロパティを
locationFetcherと名を変え

343
00:23:45,025 --> 00:23:48,128
locationFetcherプロトコルに
型を変えます

344
00:23:49,596 --> 00:23:53,700
イニシャライザに
デフォルトのパラメータ値を与え

345
00:23:53,801 --> 00:23:56,370
既存コードの破壊を避けます

346
00:23:58,372 --> 00:24:03,777
checkCurrentLocationメソッドに
１カ所 変更が必要です

347
00:23:58,372 --> 00:24:03,777
checkCurrentLocationメソッドに
１カ所 変更が必要です

348
00:24:05,379 --> 00:24:07,848
最後に
デリゲートメソッドです

349
00:24:08,115 --> 00:24:12,653
少し問題なのはデリゲートが
マネージャパラメータを―

350
00:24:12,753 --> 00:24:16,924
本物のCLLocationManagerと
考えるからです

351
00:24:17,491 --> 00:24:20,594
デリゲートでは
少し複雑になりますが―

352
00:24:20,694 --> 00:24:22,930
プロトコルを適用できます

353
00:24:23,030 --> 00:24:24,631
確認しましょう

354
00:24:26,300 --> 00:24:30,003
LocationFetcher
プロトコルに戻り

355
00:24:30,270 --> 00:24:34,474
デリゲートプロパティ名を
LocationFetcherDelegateへ

356
00:24:34,575 --> 00:24:36,643
そして型は新プロトコルへ

357
00:24:36,743 --> 00:24:40,681
CLLocationManagerDelegateと
ほぼ同じインターフェイスです

358
00:24:40,781 --> 00:24:42,449
しかしメソッド名を変え

359
00:24:42,549 --> 00:24:45,986
最初のパラメータ型を
LocationFetcherへ

360
00:24:49,289 --> 00:24:53,393
LocationFetcherDelegate
プロパティを実装しましょう

361
00:24:53,494 --> 00:24:56,430
もはや要件を
満たさないからです

362
00:24:56,897 --> 00:24:59,800
ゲッタとセッタを実装し
フォースキャストを用い―

363
00:24:59,900 --> 00:25:03,270
CLLocationManager
Delegateとの間で変換

364
00:24:59,900 --> 00:25:03,270
CLLocationManager
Delegateとの間で変換

365
00:25:03,537 --> 00:25:06,507
フォースキャストを
使う理由は 後ほど

366
00:25:08,308 --> 00:25:13,180
デリゲートプロパティは
locationFetcherDelegateへ

367
00:25:14,848 --> 00:25:17,651
最後に元のextensionを

368
00:25:17,751 --> 00:25:21,622
新モックデリゲート
プロトコルに準拠させます

369
00:25:21,722 --> 00:25:25,959
プロトコルとメソッドシグネチャを
置き換えるだけです

370
00:25:26,527 --> 00:25:32,166
しかし前のCLLocationManager
Delegateプロトコルにも準拠

371
00:25:32,499 --> 00:25:34,668
本物の
CLLocationManagerが―

372
00:25:34,768 --> 00:25:37,337
モックデリゲートプロトコルを
知らないからです

373
00:25:38,172 --> 00:25:43,010
本物に準拠したextensionを
戻すのがコツで

374
00:25:43,110 --> 00:25:46,780
上の同じlocationFetcher
デリゲートメソッドを呼ばせます

375
00:25:47,915 --> 00:25:51,952
デリゲートゲッタとセッタで
フォースキャストを使うのは

376
00:25:52,319 --> 00:25:57,991
クラスを両方のプロトコルに
準拠させるためです

377
00:26:01,528 --> 00:26:06,700
ユニットテストではテストクラスで
入れ子になった構造体を定義

378
00:26:06,800 --> 00:26:10,838
locationFetcherプロトコルに
準拠し 要求を満たします

379
00:26:11,438 --> 00:26:14,241
requestLocationメソッドでは
ブロックを呼び

380
00:26:14,341 --> 00:26:17,945
カスタマイズできる
偽の位置を取得します

381
00:26:18,178 --> 00:26:21,949
デリゲートメソッドを起動し
偽の位置を渡します

382
00:26:24,484 --> 00:26:27,588
材料がそろったので
テストの記述です

383
00:26:27,921 --> 00:26:30,023
MockLocationFetcher
構造体を作成

384
00:26:30,124 --> 00:26:32,493
handleRequestLocation
ブロックを設定し

385
00:26:32,593 --> 00:26:34,495
偽の位置を提供します

386
00:26:35,195 --> 00:26:37,531
次にCurrentLocation
Providerを作成し

387
00:26:37,631 --> 00:26:39,900
MockLocationFetcherに
渡します

388
00:26:40,200 --> 00:26:43,971
最後に完了ブロックで
checkCurrentLocationを呼びます

389
00:26:44,204 --> 00:26:45,505
完了ブロックでは

390
00:26:45,606 --> 00:26:49,343
位置がスポットなのかを
アサーションが確認します

391
00:26:51,078 --> 00:26:54,882
これで クラスによる
CLLocationManagerの使用を

392
00:26:54,982 --> 00:26:57,117
うまくモックしましたね

393
00:26:58,118 --> 00:27:02,523
プロトコルを使って
やり取りをモックする方法を

394
00:26:58,118 --> 00:27:02,523
プロトコルを使って
やり取りをモックする方法を

395
00:27:02,623 --> 00:27:03,991
ご説明しました

396
00:27:04,191 --> 00:27:06,927
おさらいしましょう

397
00:27:08,829 --> 00:27:13,901
最初に 新しいプロトコルを
定義しました

398
00:27:14,234 --> 00:27:19,406
外部クラスに使うメソッドや
プロパティがすべて―

399
00:27:19,506 --> 00:27:22,609
このプロトコルに含まれます

400
00:27:23,744 --> 00:27:27,080
次に 元の外部クラスに
extensionを作成

401
00:27:27,181 --> 00:27:29,383
プロトコルへの準拠を
宣言します

402
00:27:30,384 --> 00:27:34,521
そして外部クラスの利用を
新プロトコルと置き換えて

403
00:27:34,788 --> 00:27:39,159
型を設定できるように
イニシャライザパラメータを追加

404
00:27:40,928 --> 00:27:46,233
またSDKで一般的なプロトコルの
モック法の説明です

405
00:27:46,867 --> 00:27:50,070
我々は
このようにやりました

406
00:27:50,938 --> 00:27:53,440
まずモックデリゲート
プロトコルを―

407
00:27:53,540 --> 00:27:56,844
同じメソッドシグネチャで
定義しました

408
00:27:57,044 --> 00:28:00,814
本物の型はモックプロトコル型と
置き換えました

409
00:27:57,044 --> 00:28:00,814
本物の型はモックプロトコル型と
置き換えました

410
00:28:01,982 --> 00:28:05,819
元のモックプロトコルで
デリゲートプロパティを改名

411
00:28:05,919 --> 00:28:08,722
そのプロパティを
extensionで実装しました

412
00:28:09,790 --> 00:28:15,329
サブクラス化などと比べると
多くのコードが必要ですが

413
00:28:15,562 --> 00:28:19,900
信頼性は高く
コードが破たんしにくいのです

414
00:28:20,100 --> 00:28:24,972
なぜなら
呼び出したメソッドはすべて

415
00:28:25,072 --> 00:28:27,407
新プロトコルに
含まれるからです

416
00:28:31,879 --> 00:28:35,983
最後にテスト速度について
お話しします

417
00:28:38,018 --> 00:28:42,589
テストに時間がかかれば
開発中の実行を避け

418
00:28:42,689 --> 00:28:45,559
長いテストを
飛ばすかもしれない

419
00:28:46,160 --> 00:28:50,631
我々のテストスイートでは
素早く簡単にできます

420
00:28:50,731 --> 00:28:54,101
そのテスト速度を
維持したいのです

421
00:28:54,902 --> 00:28:59,773
テストで わざと待機や
スリープ状態にした経験は？

422
00:28:59,873 --> 00:29:03,777
原因はコードの非同期や
タイマーの使用でしょう

423
00:28:59,873 --> 00:29:03,777
原因はコードの非同期や
タイマーの使用でしょう

424
00:29:04,411 --> 00:29:08,081
遅延したアクションには
注意が要りますし

425
00:29:08,182 --> 00:29:11,385
すべての速度が
落ちかねません

426
00:29:11,752 --> 00:29:17,624
必要ではない遅延を
避ける方法をご紹介します

427
00:29:19,159 --> 00:29:23,130
例えば我々がビルド中の
アプリケーションでは

428
00:29:23,230 --> 00:29:27,434
メインUIの下部に
注目地点を表示

429
00:29:27,534 --> 00:29:33,073
10秒ごとに入れ替わりながら
近くの上位地点を表示します

430
00:29:33,474 --> 00:29:39,112
いくつかの選択肢の中から
Timer APIを使います

431
00:29:40,881 --> 00:29:43,617
このクラスの
ユニットテストです

432
00:29:44,017 --> 00:29:46,420
FeaturedPlaceManagerを
生成し

433
00:29:46,520 --> 00:29:51,125
scheduleNextPlaceメソッドを
呼び出すまで 現在地を保存

434
00:29:51,492 --> 00:29:56,763
実行ループは11秒間で
１秒は猶予時間です

435
00:29:57,331 --> 00:30:00,467
最後に
currentPlaceの変化を確認

436
00:29:57,331 --> 00:30:00,467
最後に
currentPlaceの変化を確認

437
00:30:00,968 --> 00:30:04,438
これでは実行に
かなり時間が要ります

438
00:30:04,938 --> 00:30:08,141
そこでコードに
プロパティを公開し

439
00:30:08,242 --> 00:30:12,479
タイムアウトを１秒程度に
カスタマイズします

440
00:30:12,880 --> 00:30:16,450
このようにコードを
変えるのです

441
00:30:20,687 --> 00:30:24,758
この方法で遅延を
１秒に減らせます

442
00:30:25,325 --> 00:30:30,197
先ほどより改善して
実行が速くなりましたが―

443
00:30:30,297 --> 00:30:32,232
まだ理想的ではない

444
00:30:32,332 --> 00:30:35,302
短くなっても遅延はあります

445
00:30:35,669 --> 00:30:39,640
問題は このコードが
時間依存的なことで―

446
00:30:39,740 --> 00:30:45,179
遅延を短くするほど
信頼性が損なわれ得るのです

447
00:30:45,279 --> 00:30:48,582
スケジュール予測が
CPUに依存するからです

448
00:30:48,682 --> 00:30:52,219
特に非同期コードは
そうとは限りません

449
00:30:52,820 --> 00:30:55,155
よりよい方法を見ましょう

450
00:30:56,490 --> 00:31:00,027
まず遅延の仕組みを
特定すべきです

451
00:30:56,490 --> 00:31:00,027
まず遅延の仕組みを
特定すべきです

452
00:31:00,127 --> 00:31:01,929
私の例ではタイマーで

453
00:31:02,029 --> 00:31:06,133
DispatchQueueからの
asyncAfter APIの場合もあります

454
00:31:06,833 --> 00:31:09,136
この仕組みをモックして

455
00:31:09,236 --> 00:31:13,040
直ちに遅延アクションを実行し
遅れをバイパスします

456
00:31:15,943 --> 00:31:17,678
再び元のコードです

457
00:31:17,778 --> 00:31:21,849
scheduledTimerメソッドの
動きを確認しましょう

458
00:31:22,516 --> 00:31:26,086
このメソッドは２つのことを
行います

459
00:31:26,253 --> 00:31:27,821
タイマーの生成と―

460
00:31:27,921 --> 00:31:30,591
現在の実行ループへの
追加です

461
00:31:31,125 --> 00:31:34,595
タイマーの生成に
便利なAPIですが―

462
00:31:34,695 --> 00:31:38,966
２つを分ければ
よりテストしやすくなります

463
00:31:40,500 --> 00:31:44,037
scheduledTimerを使う
先ほどのコードを変更し

464
00:31:44,138 --> 00:31:46,206
まずタイマーを作成

465
00:31:46,306 --> 00:31:50,544
次に新プロパティに保存した
runLoopを追加

466
00:31:51,512 --> 00:31:54,081
コードは前と同等です

467
00:31:54,181 --> 00:31:56,450
２つを分ければ
runLoopは―

468
00:31:56,550 --> 00:32:01,121
このクラスがやり取りする
外部クラスの１つです

469
00:31:56,550 --> 00:32:01,121
このクラスがやり取りする
外部クラスの１つです

470
00:32:01,288 --> 00:32:05,459
プロトコルのテクニックで
モックするのです

471
00:32:06,126 --> 00:32:10,731
addTimerメソッドを含んだ
小プロトコルを作り

472
00:32:12,032 --> 00:32:14,535
TimerSchedulerと
名づけました

473
00:32:14,635 --> 00:32:17,070
addTimerメソッドは―

474
00:32:17,171 --> 00:32:20,340
runLoop APIの
シグネチャと適合します

475
00:32:22,176 --> 00:32:27,181
このプロトコルをrunLoopと
置き換えましょう

476
00:32:29,650 --> 00:32:33,654
本物のrunLoopを
使いたくないので

477
00:32:33,754 --> 00:32:38,292
タイマーを渡す
モックスケジューラを作ります

478
00:32:39,560 --> 00:32:43,030
TimerScheduler
プロトコルに準拠する―

479
00:32:43,130 --> 00:32:47,267
MockTimerSchedulerという
新しい構造体を作成

480
00:32:47,835 --> 00:32:51,705
タイマーの追加時に呼ばれる
ブロックを含みます

481
00:32:53,841 --> 00:32:57,277
では最終ユニットテストを
記述します

482
00:32:57,778 --> 00:33:00,414
まず
MockTimerSchedulerを作り

483
00:32:57,778 --> 00:33:00,414
まず
MockTimerSchedulerを作り

484
00:33:00,514 --> 00:33:02,816
handleAddTimer
ブロックを設定

485
00:33:03,383 --> 00:33:08,622
スケジューラに加えられると
タイマーの遅延を記録し

486
00:33:08,722 --> 00:33:12,192
タイマーを発動して
遅れをバイパスし

487
00:33:12,292 --> 00:33:13,794
ブロックを起動します

488
00:33:14,928 --> 00:33:19,099
FeaturedPlaceManagerを生成し
MockTimerSchedulerを提供

489
00:33:19,867 --> 00:33:23,337
最後にscheduleNextPlaceを
呼んで テストを開始

490
00:33:23,871 --> 00:33:26,874
遅延のないテストの
完成です

491
00:33:26,974 --> 00:33:31,645
高速で 時間に依存せず
信頼性が増しました

492
00:33:32,312 --> 00:33:37,918
さらに アサーションを使い
時間の遅れを確認できます

493
00:33:38,018 --> 00:33:40,654
前のテストでは不可能でした

494
00:33:42,790 --> 00:33:47,561
このテクニックで
遅延は完全に取り除けます

495
00:33:47,995 --> 00:33:51,632
遅延を含むコードのテストに
適します

496
00:33:51,732 --> 00:33:54,802
しかしテスト全体の
速度向上には―

497
00:33:54,902 --> 00:33:58,438
テストの大部分を直接構造に
すべきです

498
00:33:58,539 --> 00:34:01,041
遅延のモックは要りません

499
00:33:58,539 --> 00:34:01,041
遅延のモックは要りません

500
00:34:01,909 --> 00:34:03,544
我々の
アプリケーションだと―

501
00:34:03,644 --> 00:34:07,614
遅延が次の注目地点に
変換されます

502
00:34:07,714 --> 00:34:13,053
１～２つのテストで
タイマーの遅れを正せます

503
00:34:13,152 --> 00:34:16,989
scheduleNextPlaceメソッドを
直接 呼び出し

504
00:34:17,091 --> 00:34:19,793
モックは必要ありません

505
00:34:22,496 --> 00:34:26,900
テストの実行速度について
あと２つ コツがあります

506
00:34:27,601 --> 00:34:31,538
NSPredicateExpectationの
使用に関しては―

507
00:34:31,772 --> 00:34:36,176
他のExpectationクラスほどの
性能はありません

508
00:34:36,275 --> 00:34:40,179
直接的な
コールバックでないからです

509
00:34:40,514 --> 00:34:46,219
条件の評価が別のプロセスである
UIテストに主に用いられます

510
00:34:46,320 --> 00:34:50,257
ユニットテストには
直接的な方法がお勧めです

511
00:34:50,357 --> 00:34:53,793
XCTestExpectationや
NSNotificationExpectation

512
00:34:53,893 --> 00:34:55,795
KVOExpectationなどです

513
00:34:57,931 --> 00:34:59,533
もう１つのコツは―

514
00:34:59,633 --> 00:35:02,770
アプリケーションの起動を
速めることです

515
00:34:59,633 --> 00:35:02,770
アプリケーションの起動を
速めることです

516
00:35:03,237 --> 00:35:06,673
ほとんどは起動時に
セットアップを行います

517
00:35:06,773 --> 00:35:10,177
通常の起動には
欠かせませんが―

518
00:35:10,277 --> 00:35:14,982
テスト実行の際には
その多くが不要になります

519
00:35:15,249 --> 00:35:19,119
View Controllerの読み込みや
ネットワークリクエストの開始

520
00:35:19,219 --> 00:35:21,521
分析パッケージの
設定などです

521
00:35:21,622 --> 00:35:25,826
これらはユニットテストでも
不要です

522
00:35:26,994 --> 00:35:32,933
XCTestは デリゲートが
起動終了を伝えるのを待ちます

523
00:35:33,066 --> 00:35:37,671
テスト時に
起動に時間がかかるなら―

524
00:35:38,072 --> 00:35:42,409
テスト実行だと検出させて
回避させるのも手です

525
00:35:44,011 --> 00:35:45,178
１つの方法は―

526
00:35:45,279 --> 00:35:49,316
カスタム環境変数や
起動引数の特定です

527
00:35:49,783 --> 00:35:55,289
スキームエディタの左側の
“Test”から“Arguments”を開き

528
00:35:55,389 --> 00:35:58,592
環境変数か起動引数を
追加しましょう

529
00:35:59,226 --> 00:36:04,598
このスクリーンショットでは
IS UNIT TESTINGを１にしています

530
00:35:59,226 --> 00:36:04,598
このスクリーンショットでは
IS UNIT TESTINGを１にしています

531
00:36:06,266 --> 00:36:09,703
デリゲートの
didFinishLaunchingコードを

532
00:36:09,803 --> 00:36:12,973
このようなコードに
変えてください

533
00:36:13,640 --> 00:36:17,478
スキップしたコードは
ユニットテストに不要と―

534
00:36:17,578 --> 00:36:19,546
必ず確認してください

535
00:36:23,016 --> 00:36:24,518
おさらいです

536
00:36:25,853 --> 00:36:32,125
ブライアンが
バランスのいいテスト作成と

537
00:36:32,226 --> 00:36:36,196
ネットワークテストの
テクニックを紹介しました

538
00:36:36,830 --> 00:36:40,601
私は
Foundation通知の分離と―

539
00:36:40,701 --> 00:36:42,569
依存性の注入を話しました

540
00:36:43,370 --> 00:36:47,274
また 外部クラスとの
やり取りという―

541
00:36:47,374 --> 00:36:51,612
テストを書く際の課題への
解決策を提示

542
00:36:52,279 --> 00:36:57,151
テスト速度を高め
遅延を避けるコツにも触れました

543
00:36:57,718 --> 00:37:02,556
テストを書く際に
ぜひご活用ください

544
00:36:57,718 --> 00:37:02,556
テストを書く際に
ぜひご活用ください

545
00:37:04,558 --> 00:37:07,761
詳細はウェブサイトヘ

546
00:37:07,861 --> 00:37:13,000
水曜のセッションを見逃した方は
ビデオをご覧ください

547
00:37:13,667 --> 00:37:16,336
ありがとうございました

548
00:37:16,437 --> 00:37:20,140
(拍手)