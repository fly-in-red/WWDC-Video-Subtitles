
1
00:00:07,074 --> 00:00:16,283
(音楽)

2
00:00:21,722 --> 00:00:23,323
私はデビッドです

3
00:00:23,423 --> 00:00:27,694
後ほど同僚のタイラーと
ラッセルも登場します

4
00:00:27,794 --> 00:00:30,864
今回はサイズや形状を問わない―

5
00:00:30,964 --> 00:00:32,966
アプリケーションの
構築についてです

6
00:00:34,568 --> 00:00:40,107
初期iPhoneのiOS 2をご存知の方が
ここにいるかは分かりませんが

7
00:00:40,207 --> 00:00:42,809
当時 画面サイズは１つでした

8
00:00:43,310 --> 00:00:49,349
しかし今日では各種iPhoneや
iPadなどがあり サイズも様々です

9
00:00:49,449 --> 00:00:54,721
新たな画面と形状を持つ
iPhone Xへの対応も求められます

10
00:00:55,689 --> 00:01:00,561
今回は“Bagel Times”という
アプリケーションを例にしながら

11
00:00:55,689 --> 00:01:00,561
今回は“Bagel Times”という
アプリケーションを例にしながら

12
00:01:00,661 --> 00:01:04,864
iPhone XとiPhone 8に対応する
デザインを作ります

13
00:01:06,433 --> 00:01:10,604
今回のセッションの要点は
次の３点です

14
00:01:11,104 --> 00:01:13,707
１つ目はSafe Areaと
レイアウトマージン

15
00:01:13,807 --> 00:01:18,278
様々な画面に対応させるための
方法を取り上げます

16
00:01:19,346 --> 00:01:22,549
２つ目はスクロールビュー

17
00:01:22,649 --> 00:01:27,221
Safe Areaやマージン
UIKitの機能との関係を紹介します

18
00:01:28,655 --> 00:01:33,093
３つ目は アダプティブな
アプリケーションを構築するための

19
00:01:33,193 --> 00:01:35,295
UIKitツールについてです

20
00:01:35,996 --> 00:01:40,868
ではまず Safe Areaと
レイアウトマージンのお話です

21
00:01:42,236 --> 00:01:47,674
Safe Areaとはどのようなもので
デバイスではどう見えるのでしょう

22
00:01:48,275 --> 00:01:54,014
iPhone 8の矩形の画面では
全体がSafe Areaです

23
00:01:54,114 --> 00:01:57,518
コンテンツが
隠れる部分はありません

24
00:01:58,852 --> 00:02:00,454
iPhone Xの場合―

25
00:01:58,852 --> 00:02:00,454
iPhone Xの場合―

26
00:02:00,721 --> 00:02:05,025
ハードウェアが上部と下部に
スペースを有しています

27
00:02:05,125 --> 00:02:09,896
これらはアプリケーションの
Safe Area外となります

28
00:02:10,497 --> 00:02:13,534
横向きの場合も ほぼ同様です

29
00:02:13,634 --> 00:02:20,374
下部のホームインジケータを避けて
レイアウトする必要があります

30
00:02:21,308 --> 00:02:25,312
画面全体がSafe Areaでない
デバイスは他にもあります

31
00:02:26,880 --> 00:02:30,551
実はApple TVでも
同様の考慮が必要です

32
00:02:30,651 --> 00:02:32,886
一部のテレビにおいては―

33
00:02:32,986 --> 00:02:37,024
映像の端が画面に表示されない
ケースがあります

34
00:02:37,257 --> 00:02:42,029
その場合“オーバースキャン補償”
という設定で表示できます

35
00:02:42,496 --> 00:02:47,534
オーバースキャンで映される範囲が
アプリケーションのSafe Areaです

36
00:02:48,735 --> 00:02:54,074
いくつかのデバイスにおける
Safe Areaをご紹介しましたが

37
00:02:54,174 --> 00:03:01,215
どう使えばアダプティブな
アプリケーションが作れるでしょう

38
00:02:54,174 --> 00:03:01,215
どう使えばアダプティブな
アプリケーションが作れるでしょう

39
00:03:03,450 --> 00:03:07,621
では 任意視点について
見ていきましょう

40
00:03:08,055 --> 00:03:12,392
上下左右の４辺に余白があります

41
00:03:12,492 --> 00:03:17,064
これらの部分に
コンテンツを表示すると

42
00:03:17,164 --> 00:03:21,068
何らかの要素で覆われる
可能性があります

43
00:03:21,735 --> 00:03:24,204
UIViewでの取得に使うのは―

44
00:03:24,304 --> 00:03:26,673
safeAreaInsetsプロパティです

45
00:03:26,773 --> 00:03:30,043
UIEdgeInsets型で
上下左右の値を取得できます

46
00:03:31,011 --> 00:03:32,913
Auto Layoutをお使いの方は

47
00:03:33,013 --> 00:03:37,017
単に 安全な矩形の領域を
見たいかもしれません

48
00:03:37,351 --> 00:03:41,355
それは safeAreaLayoutGuideを
使えば可能です

49
00:03:41,455 --> 00:03:45,792
レイアウトアンカーを
扱えるようになる―

50
00:03:45,893 --> 00:03:48,228
UILayoutGuideです

51
00:03:48,328 --> 00:03:51,231
矩形を見るだけなら
layoutFrameも使えます

52
00:03:53,100 --> 00:04:00,607
それではSafe Areaの見え方に続き
画面遷移についてお話ししましょう

53
00:03:53,100 --> 00:04:00,607
それではSafe Areaの見え方に続き
画面遷移についてお話ししましょう

54
00:04:01,642 --> 00:04:05,679
テキストを消し
サブビューを追加します

55
00:04:05,779 --> 00:04:08,949
ビューの下半分が隠れましたね

56
00:04:10,484 --> 00:04:14,922
Safe Areaは
どう計算されるのでしょう？

57
00:04:15,389 --> 00:04:21,060
このサブビューは
安全な領域の外に入り込んでいます

58
00:04:21,161 --> 00:04:25,966
スーパービューの
左右と下部に被っていますね

59
00:04:26,366 --> 00:04:30,237
これらはサブビューの
UIEdgeInsetsで

60
00:04:30,337 --> 00:04:33,373
safeAreaInsetsの値として
示されます

61
00:04:33,774 --> 00:04:39,379
layoutFrameが似ている
safeAreaLayoutGuideも示されます

62
00:04:40,480 --> 00:04:45,252
これらのことを目にすると
ご自身のUIに―

63
00:04:45,352 --> 00:04:48,555
余白を追加したくなるでしょう

64
00:04:48,655 --> 00:04:52,693
View Controllerを使って
コントロールを追加し

65
00:04:52,793 --> 00:04:57,698
サブビューのSafe Areaで
追加や削除をしたいかもしれません

66
00:04:58,265 --> 00:05:00,300
ここで別のサブビューを追加します

67
00:04:58,265 --> 00:05:00,300
ここで別のサブビューを追加します

68
00:05:01,802 --> 00:05:05,038
View Controllerも追加します

69
00:05:05,172 --> 00:05:09,943
View Controllerには余白を
追加するプロパティがあるからです

70
00:05:10,110 --> 00:05:14,982
additionalSafeAreaInsetsという
プロパティです

71
00:05:15,382 --> 00:05:18,652
これから親の余白を継承してみます

72
00:05:19,319 --> 00:05:22,723
additionalSafeAreaInsetsを
このビューに追加し

73
00:05:22,923 --> 00:05:27,160
最終的なSafe Areaを取得します

74
00:05:28,395 --> 00:05:32,165
Safe Areaについて
他に知っておくべきことは？

75
00:05:32,499 --> 00:05:34,935
別の例も見てみましょう

76
00:05:35,035 --> 00:05:39,106
１つのビューが
親のSafe Area内に収まっています

77
00:05:39,273 --> 00:05:43,443
このビューのSafe Areaは ビューの
全領域をカプセル化しています

78
00:05:43,911 --> 00:05:48,015
１辺に近づけても
Safe Areaは広がりません

79
00:05:48,115 --> 00:05:51,218
親のSafe Areaを
出ていないからです

80
00:05:52,119 --> 00:05:58,025
もう少し動かすと Safe Areaの
下部の余白が少し大きくなります

81
00:05:58,125 --> 00:06:03,897
親のSafe Areaの外に出て
重なった部分が現れました

82
00:05:58,125 --> 00:06:03,897
親のSafe Areaの外に出て
重なった部分が現れました

83
00:06:04,565 --> 00:06:07,901
続けて動かすと
さらに大きくなります

84
00:06:08,569 --> 00:06:13,006
これを さらに動かすと
どうなると思いますか？

85
00:06:14,875 --> 00:06:15,976
どうでしょう

86
00:06:16,376 --> 00:06:21,114
ビューが親の外に出ると
Safe Areaは大きくなりません

87
00:06:21,582 --> 00:06:25,352
どれだけ親から離れても
変わりません

88
00:06:25,686 --> 00:06:30,324
“その理由と目的は？”と
お思いでしょう

89
00:06:30,824 --> 00:06:32,893
答えは“アニメーション”です

90
00:06:33,160 --> 00:06:36,597
今回はサブビューを
親の外に動かしました

91
00:06:36,797 --> 00:06:42,035
親と一緒に動かすためには
Safe Areaの中に置けないのです

92
00:06:42,369 --> 00:06:44,838
このアプリケーションを
見てください

93
00:06:45,138 --> 00:06:48,575
下部からビューが開きます

94
00:06:49,510 --> 00:06:53,447
このビューが
親のSafe Areaに接していて

95
00:06:53,547 --> 00:06:58,719
そして親のSafe Areaは
下部に広がるとしましょう

96
00:06:59,086 --> 00:07:04,558
そうなると その間このビューは
画面に留まることになり

97
00:06:59,086 --> 00:07:04,558
そうなると その間このビューは
画面に留まることになり

98
00:07:04,992 --> 00:07:08,762
後ろに表示されるものが
見えなくなります

99
00:07:09,062 --> 00:07:13,200
子のSafe Areaは
親から与えられる以上は

100
00:07:13,300 --> 00:07:15,002
広がらないのです

101
00:07:16,236 --> 00:07:21,942
それではSafe Areaについての話を
まとめていきます

102
00:07:22,209 --> 00:07:25,612
safeAreaInsetsと
safeAreaLayoutGuideは

103
00:07:25,712 --> 00:07:27,581
ご説明しましたね

104
00:07:28,015 --> 00:07:32,052
safeAreaInsetsの変更を
感知すべき時は

105
00:07:32,152 --> 00:07:36,190
safeAreaInsetsDidChange()を
オーバーライドします

106
00:07:37,491 --> 00:07:39,827
setNeedsLayout()を呼ぶのが
典型的ですが

107
00:07:39,927 --> 00:07:42,829
他のロジックを走らせても
構いません

108
00:07:43,664 --> 00:07:48,035
View Controllerが
Safe Areaの変更に対応すべき時は

109
00:07:48,135 --> 00:07:52,973
viewSafeAreaInsetsDidChange()を
オーバーライドします

110
00:07:53,607 --> 00:07:56,877
Interface Builderで
インターフェイスを作っている場合

111
00:07:56,977 --> 00:07:59,346
Safe Areaのプロパティが使えます

112
00:07:59,446 --> 00:08:05,052
Safe Areaの制約を構築するための
ビューの一覧で確認できます

113
00:07:59,446 --> 00:08:05,052
Safe Areaの制約を構築するための
ビューの一覧で確認できます

114
00:08:06,353 --> 00:08:10,390
次はレイアウトマージンについて
お話しします

115
00:08:13,260 --> 00:08:17,664
レイアウトマージンとは
つまり余白です

116
00:08:17,931 --> 00:08:21,068
通常 これらは制御可能な
プロパティで

117
00:08:21,168 --> 00:08:25,873
ビューの縁からのスペースを
指定できます

118
00:08:26,707 --> 00:08:28,175
Safe Areaと同様―

119
00:08:28,275 --> 00:08:33,212
UIEdgeInsets型のlayoutMargins
プロパティで参照できます

120
00:08:33,881 --> 00:08:38,885
昨年はdirectionalLayoutMargins
プロパティが新たに追加されました

121
00:08:39,153 --> 00:08:44,892
layoutMarginsは
UIEdgeInsetsの値を使います

122
00:08:45,125 --> 00:08:46,860
しかし
directionalLayoutMarginsは

123
00:08:46,960 --> 00:08:49,062
NSDirectionalEdgeInsetsを
使います

124
00:08:49,496 --> 00:08:51,732
２つの構造体の最大の違いは

125
00:08:51,832 --> 00:08:55,969
後者は 左右ではなく
前辺と後辺を扱う点です

126
00:08:56,069 --> 00:09:01,842
RTLレイアウトに対応する
マージンを作るのに役立ちます

127
00:08:56,069 --> 00:09:01,842
RTLレイアウトに対応する
マージンを作るのに役立ちます

128
00:09:01,942 --> 00:09:06,180
directionalLayoutMarginsを
使えば 左右の入れ替えは不要です

129
00:09:07,314 --> 00:09:13,020
Safe Areaだけでなくマージンにも
layoutMarginsGuideがあり

130
00:09:13,453 --> 00:09:17,891
マージンに対するコンテンツを
レイアウトできます

131
00:09:18,292 --> 00:09:22,629
ではコンテンツを
ビューの中に入れましょう

132
00:09:24,064 --> 00:09:29,670
レイアウトマージンとSafe Areaを
併せてお話ししましたが

133
00:09:30,571 --> 00:09:33,407
２つは どう関わるのでしょう

134
00:09:34,208 --> 00:09:36,743
再度 マーカーで説明します

135
00:09:37,077 --> 00:09:40,814
おっと その前に
この話をしておきます

136
00:09:41,949 --> 00:09:44,685
デフォルトでは
Safe Areaを構築し―

137
00:09:45,452 --> 00:09:52,559
その後 そのSafe Areaを考慮して
レイアウトマージンを構築します

138
00:09:52,693 --> 00:09:58,465
デフォルトでは この方法が
ベストであることは明らかでしょう

139
00:09:58,565 --> 00:10:01,168
Safe Areaの中の
レイアウトマージンは

140
00:09:58,565 --> 00:10:01,168
Safe Areaの中の
レイアウトマージンは

141
00:10:01,268 --> 00:10:04,972
レイアウトに対する
付加的な余白を示すからです

142
00:10:05,906 --> 00:10:11,178
“それがベストではない
場合もある”とお思いでしょう

143
00:10:11,378 --> 00:10:14,114
ですので別の方法もあります

144
00:10:14,248 --> 00:10:20,487
insetsLayoutMarginsFromSafe
Areaをtrueからfalseにすれば

145
00:10:20,954 --> 00:10:24,491
レイアウトマージンは
ビューの範囲に戻ります

146
00:10:24,591 --> 00:10:28,028
Safe Areaにカプセル化されません

147
00:10:28,529 --> 00:10:30,297
他にできることは？

148
00:10:30,898 --> 00:10:36,637
デフォルトではsafeAreaMarginsは
下位階層に伝播しますが

149
00:10:37,638 --> 00:10:40,140
layoutMarginsは違います

150
00:10:40,240 --> 00:10:44,811
デフォルトでは全ビュー階層を示す
Safe Areaを考慮せず

151
00:10:44,912 --> 00:10:48,982
独立したレイアウトが
必要かもしれません

152
00:10:50,284 --> 00:10:54,188
しかし伝播が必要なら
ビューごとに―

153
00:10:54,521 --> 00:10:59,426
preservesSuperviewLayout
Marginsをfalseからtrueにします

154
00:11:00,027 --> 00:11:04,798
親と子のビューの間で
すべてが自然に並ぶよう―

155
00:11:04,898 --> 00:11:09,336
親よりも小さいマージンを
設置します

156
00:11:11,271 --> 00:11:17,711
View Controllerのビューの
layoutMarginsを変えたいとします

157
00:11:18,212 --> 00:11:19,646
デフォルトでは

158
00:11:19,746 --> 00:11:24,518
ビューに対するマージンは
このようになります

159
00:11:25,085 --> 00:11:31,558
昨年 systemMinimumLayoutMargins
というプロパティが追加されました

160
00:11:31,792 --> 00:11:32,993
これらのマージンは

161
00:11:33,093 --> 00:11:40,033
現在 与えているマージンに対して
統合された最小のものです

162
00:11:40,133 --> 00:11:47,007
UIKitが与える左右のマージンを
邪魔せずに 上下にも追加できます

163
00:11:47,441 --> 00:11:50,177
さらなるコントロールが
欲しい場合は

164
00:11:50,344 --> 00:11:56,250
viewRespectsSystemMinimum
LayoutMarginsが使えます

165
00:11:56,650 --> 00:12:00,721
マージンを完全に
コントロールしたい場合は

166
00:11:56,650 --> 00:12:00,721
マージンを完全に
コントロールしたい場合は

167
00:12:00,821 --> 00:12:06,827
このプロパティをfalseにすれば
マージンは記述のとおりになります

168
00:12:07,995 --> 00:12:13,333
それでは UIViewのプロパティを
まとめましょう

169
00:12:13,433 --> 00:12:17,905
layoutMarginsは上下左右の
EdgeInsetsを設定します

170
00:12:18,305 --> 00:12:23,810
directionalLayoutMarginsは
RTLレイアウトに適しています

171
00:12:24,411 --> 00:12:29,082
layoutMarginsGuideは
Auto Layoutと使えます

172
00:12:29,750 --> 00:12:33,787
そしてlayoutMarginsに
変更があった際は

173
00:12:33,887 --> 00:12:38,559
layoutMarginsDidChange()を
オーバーライドしてください

174
00:12:39,293 --> 00:12:43,230
Interface Builderで
マージンの制約を作る際は

175
00:12:43,330 --> 00:12:46,033
“Constrain to margins”に
チェックを入れます

176
00:12:46,400 --> 00:12:50,571
次はタイラーから
スクロールビューのお話です

177
00:12:50,671 --> 00:12:57,077
(拍手)

178
00:12:58,679 --> 00:12:59,847
ありがとう

179
00:13:00,113 --> 00:13:01,181
こんにちは

180
00:13:01,415 --> 00:13:05,586
私からはスクロールビューについて
お話しします

181
00:13:05,686 --> 00:13:09,389
スクロールビューは
iOSの大事な要素です

182
00:13:09,523 --> 00:13:14,895
テーブルビューやテキストビュー
コレクションビューに加え

183
00:13:14,995 --> 00:13:18,499
カスタムアプリケーションにも
使われています

184
00:13:18,966 --> 00:13:24,204
私たちは今 Bagel Timesという
アプリケーションに注力しています

185
00:13:24,972 --> 00:13:26,940
こちらが記事の画面です

186
00:13:27,040 --> 00:13:30,444
スクロールビューの中央に
記事が配置されています

187
00:13:30,544 --> 00:13:34,715
これは当社のライターによる
ハイクオリティな記事です

188
00:13:34,815 --> 00:13:39,353
Apple Parkから得られる
インスピレーションを探っています

189
00:13:39,753 --> 00:13:45,759
異なる形状やサイズのデバイスに
コンテンツを対応させるために

190
00:13:45,859 --> 00:13:50,998
まずはスクロールビューの使い方を
おさらいしましょう

191
00:13:51,999 --> 00:13:57,437
全画面のスクロールビューを
例として進めていきます

192
00:13:57,805 --> 00:14:01,575
左側は 一般的と思われる
デバイスです

193
00:13:57,805 --> 00:14:01,575
左側は 一般的と思われる
デバイスです

194
00:14:01,675 --> 00:14:07,481
右側は ダイアグラムの中で
何が起きているのかを示します

195
00:14:07,948 --> 00:14:13,720
今回のお話は すべてy軸の
縦のスクロールについてですが

196
00:14:13,820 --> 00:14:16,924
x軸にも同様に応用できます

197
00:14:17,124 --> 00:14:20,360
説明のために単純値を使うので

198
00:14:20,461 --> 00:14:23,897
スクロールビューの高さは
400ptとします

199
00:14:25,666 --> 00:14:29,269
スクロールビューの中に
コンテンツがあります

200
00:14:29,837 --> 00:14:33,674
例えて言うなら
スクロールビューは額縁で

201
00:14:33,807 --> 00:14:37,945
スクロールビューのサイズが
額縁のサイズです

202
00:14:38,045 --> 00:14:40,647
コンテンツは額縁の中の絵です

203
00:14:40,747 --> 00:14:44,751
そしてそのコンテンツは
スライドすることができます

204
00:14:45,018 --> 00:14:48,121
今回の例でも
縦にスクロールできます

205
00:14:48,222 --> 00:14:55,329
これはスクロールビューの高さより
コンテンツの方が縦に長いからです

206
00:14:56,029 --> 00:14:58,465
クリッピングをオフにしたので

207
00:14:58,565 --> 00:15:01,268
右側で舞台裏をのぞけます

208
00:14:58,565 --> 00:15:01,268
右側で舞台裏をのぞけます

209
00:15:02,202 --> 00:15:03,837
スクロールビューは

210
00:15:03,937 --> 00:15:08,442
スクロール位置を示すために
contentOffsetを使います

211
00:15:09,243 --> 00:15:12,880
現在の位置は一番上なので
contentOffsetは0です

212
00:15:12,980 --> 00:15:17,818
コンテンツとスクロールビューの
上辺がそろっています

213
00:15:18,819 --> 00:15:23,090
では スクロールビューを
一番下まで下げ

214
00:15:23,190 --> 00:15:25,859
コンテンツを上げましょう

215
00:15:26,226 --> 00:15:33,000
ご覧のとおり 下辺まで下がると
contentOffsetは100に増えました

216
00:15:33,100 --> 00:15:36,103
これはスクロールビューの
上辺が―

217
00:15:36,203 --> 00:15:39,706
コンテンツの上辺より
100pt低いということです

218
00:15:40,407 --> 00:15:45,946
contentOffsetを0にすると
スクロールビューは上に戻ります

219
00:15:46,280 --> 00:15:47,648
最初の形ですね

220
00:15:48,582 --> 00:15:52,119
これがスクロールビューの基本です

221
00:15:52,286 --> 00:15:54,988
次は 非常に大事な
コンセプトである―

222
00:15:55,088 --> 00:15:58,492
スクロール可能な領域の
拡大についてです

223
00:15:58,592 --> 00:16:01,662
contentInsetという
プロパティを使います

224
00:15:58,592 --> 00:16:01,662
contentInsetという
プロパティを使います

225
00:16:02,596 --> 00:16:04,331
contentInsetは

226
00:16:04,431 --> 00:16:11,839
スクロール可能な領域の縁から
コンテンツ内へ余白を与えます

227
00:16:12,306 --> 00:16:13,774
これを追加すれば

228
00:16:13,874 --> 00:16:19,379
スクロールビューがより広い領域を
スクロールできるようになるのです

229
00:16:19,580 --> 00:16:23,584
それでは contentInsetを
上辺に設定してみます

230
00:16:24,318 --> 00:16:26,687
contentInsetを20に設定すると

231
00:16:27,020 --> 00:16:32,426
スクロールビューの上辺が広がり
スクロール可能な領域が増えました

232
00:16:33,093 --> 00:16:36,697
現在 contentOffsetは0なので
コンテンツは―

233
00:16:36,797 --> 00:16:39,633
スクロールビューの上辺と
そろったままです

234
00:16:39,733 --> 00:16:43,804
ですがスクロールビューは
もう少し上に行けます

235
00:16:44,304 --> 00:16:48,242
スクロールして
変化を見てみましょう

236
00:16:48,809 --> 00:16:54,515
先ほどと同じく 下辺まで下がると
contentOffsetは100に増えます

237
00:16:54,815 --> 00:17:00,254
下辺のcontentInsetは変わらず
0だからです

238
00:16:54,815 --> 00:17:00,254
下辺のcontentInsetは変わらず
0だからです

239
00:17:00,888 --> 00:17:05,291
ですが 一番上まで
スクロールして戻すと―

240
00:17:05,392 --> 00:17:08,762
contentOffsetが負数になります

241
00:17:09,630 --> 00:17:14,067
コンテンツの上辺を超えて
スクロール可能となったからです

242
00:17:14,166 --> 00:17:18,906
負数の分だけ より
スクロールできるようになりました

243
00:17:20,307 --> 00:17:24,912
iOS 7以降は このcontentInsetが
非常に重要です

244
00:17:25,012 --> 00:17:30,150
iOS 7では システム全体にわたり
各種バーが半透明になったからです

245
00:17:30,250 --> 00:17:33,654
コンテンツは端から端まで
表示できます

246
00:17:33,754 --> 00:17:39,593
バーの下に入ったコンテンツは
美しくカラフルに ぼやけますね

247
00:17:39,693 --> 00:17:42,162
ツールバーや
ナビゲーションバーなどです

248
00:17:42,496 --> 00:17:45,299
様々な箇所で使われているので

249
00:17:45,399 --> 00:17:50,370
スクロールビューにcontentInsetを
自動で設定したいところです

250
00:17:50,604 --> 00:17:53,674
以前 便利なプロパティが
UIViewControllerにありました

251
00:17:54,174 --> 00:17:57,644
automaticallyAdjusts
ScrollViewInsetsです

252
00:17:57,744 --> 00:18:03,250
ナビゲーションバーや
ツールバーなどと重なる場合に

253
00:17:57,744 --> 00:18:03,250
ナビゲーションバーや
ツールバーなどと重なる場合に

254
00:18:03,350 --> 00:18:08,288
スクロールビューにcontentInsetを
自動で設定できるものでした

255
00:18:08,589 --> 00:18:11,425
Navigation Controllerの中に

256
00:18:11,525 --> 00:18:14,528
スクロールビューが
含まれる場合にもです

257
00:18:15,562 --> 00:18:17,931
大抵はうまくいきましたが

258
00:18:18,031 --> 00:18:23,136
UIScrollViewに
手を加えている場合は別でした

259
00:18:23,237 --> 00:18:29,476
もし コードとUIKitの両方が
contentInsetを設定していると

260
00:18:29,576 --> 00:18:30,744
複雑だったのです

261
00:18:31,578 --> 00:18:33,781
そこでiOS 11以降は

262
00:18:33,881 --> 00:18:39,319
より明確でパワフルな方法で
自動化できるようになりました

263
00:18:39,620 --> 00:18:46,894
adjustedContentInsetという
UIScrollViewのプロパティです

264
00:18:48,228 --> 00:18:54,234
iOS 11から新たに導入された
このプロパティは読み取り専用で

265
00:18:54,334 --> 00:18:59,072
スクロールビューの動作を
記述するものです

266
00:18:59,573 --> 00:19:05,679
“contentInsetとの違いは何だ？”
と疑問に思うかもしれません

267
00:18:59,573 --> 00:19:05,679
“contentInsetとの違いは何だ？”
と疑問に思うかもしれません

268
00:19:05,779 --> 00:19:08,448
早速 見ていきましょう

269
00:19:09,149 --> 00:19:14,755
adjustedContentInsetは
アプリケーションのcontentInsetと

270
00:19:14,855 --> 00:19:18,959
自動でシステムやUIKitから
与えられる余白を併せたものです

271
00:19:19,626 --> 00:19:24,731
これらを別々に認識することで
状況を判断しやすくなります

272
00:19:25,299 --> 00:19:30,070
いつどこでシステムの余白を
得るのか疑問でしょう

273
00:19:30,971 --> 00:19:34,775
最も一般的なケースは
safeAreaInsetsです

274
00:19:35,008 --> 00:19:36,677
見てみましょう

275
00:19:36,977 --> 00:19:41,782
ベーシックなダイアグラムに戻し
safeAreaInsetsを加えます

276
00:19:42,616 --> 00:19:47,187
現状では safeAreaInsetsは
どちらの辺にもありませんが

277
00:19:47,287 --> 00:19:51,391
これから上辺に
safeAreaInsetsを加えます

278
00:19:52,326 --> 00:19:58,732
デフォルトではスクロールビューは
自動でこれらのsafeAreaInsetsを

279
00:19:58,832 --> 00:20:02,769
adjustedContentInsetに
取り込みます

280
00:19:58,832 --> 00:20:02,769
adjustedContentInsetに
取り込みます

281
00:20:02,870 --> 00:20:05,505
これは縦スクロールが
できるからです

282
00:20:05,706 --> 00:20:09,977
スクロール可能な領域が
自動で増えたことで

283
00:20:10,077 --> 00:20:17,484
上辺のバーやディスプレイの縁に
コンテンツが隠れなくなったのです

284
00:20:19,052 --> 00:20:23,590
同じスクロールビューを
異なるデバイスに表示しました

285
00:20:23,690 --> 00:20:26,994
左がiPhone Xで 右がiPhone 8です

286
00:20:27,094 --> 00:20:32,633
より高いステータスバーや
センサーハウジングがあるため

287
00:20:32,733 --> 00:20:36,403
上辺のSafe area insetは
iPhone Xの方が大きいです

288
00:20:36,537 --> 00:20:41,775
灰色に見えるスクロールビューの
上辺の余白も より広いです

289
00:20:42,543 --> 00:20:47,781
これが スクロールビューが自動で
デバイスに対応する方法の１つです

290
00:20:48,248 --> 00:20:51,919
ではダイアグラムに戻り
別のお話をしましょう

291
00:20:52,753 --> 00:20:56,890
上辺にsafeAreaInsetsがある
スクロールビューに

292
00:20:56,990 --> 00:20:59,726
サブビューを追加します

293
00:20:59,827 --> 00:21:02,095
コンテンツ領域に入りました

294
00:20:59,827 --> 00:21:02,095
コンテンツ領域に入りました

295
00:21:02,196 --> 00:21:07,100
スクロールビューのSafe Area内に
完全に収まっています

296
00:21:08,035 --> 00:21:12,473
ですが スクロールビューを
下にスクロールすると

297
00:21:12,639 --> 00:21:18,912
サブビューがスクロールビューの
Safe Area外に出てしまいました

298
00:21:19,546 --> 00:21:23,684
safeAreaInsetsの伝播の話に
基づけば サブビューは

299
00:21:23,784 --> 00:21:29,690
自身の上辺のsafeAreaInsetsを
見るのだと思うかもしれませんね

300
00:21:30,390 --> 00:21:32,159
実は違います

301
00:21:32,593 --> 00:21:35,062
スクロールビューは自動で―

302
00:21:35,162 --> 00:21:39,833
adjustedContentInsetに
safeAreaInsetsを取り込みます

303
00:21:39,933 --> 00:21:45,205
そうすると これらの辺の余白は
サブビューに伝播されないのです

304
00:21:46,240 --> 00:21:47,674
重要な点です

305
00:21:48,141 --> 00:21:53,881
スクロールビューはSafe Area内で
コンテンツをスクロールさせます

306
00:21:54,448 --> 00:22:01,488
もしスクロール領域を広げるための
safeAreaInsetsまで伝播したら

307
00:21:54,448 --> 00:22:01,488
もしスクロール領域を広げるための
safeAreaInsetsまで伝播したら

308
00:22:01,588 --> 00:22:06,460
異なる場所に同じ余白が
重複するような状態になります

309
00:22:06,560 --> 00:22:11,765
adjustedContentInsetに
取り込まれたsafeAreaInsetsを

310
00:22:11,865 --> 00:22:17,304
スクロールの軸上のサブビューは
まったく認識しないのです

311
00:22:18,438 --> 00:22:19,773
では次に―

312
00:22:19,873 --> 00:22:25,179
スクロールビューとSafe Areaの
連携を操るオプションを紹介します

313
00:22:26,847 --> 00:22:31,919
UIScrollViewのcontentInset
AdjustmentBehaviorです

314
00:22:32,019 --> 00:22:36,023
ご覧のとおり
Interface Builderでも使えます

315
00:22:36,557 --> 00:22:39,126
デフォルトの値はAutomaticです

316
00:22:39,226 --> 00:22:44,932
ほとんどの場合は
デフォルトの値で問題ありませんが

317
00:22:45,165 --> 00:22:50,437
何ができるのかを理解するため
オプションを見ていきましょう

318
00:22:50,537 --> 00:22:52,973
選択肢を広げられます

319
00:22:53,340 --> 00:22:58,378
まずはこの中から
alwaysの挙動についてです

320
00:22:58,479 --> 00:23:00,647
これは分かりやすいはずです

321
00:22:58,479 --> 00:23:00,647
これは分かりやすいはずです

322
00:23:00,747 --> 00:23:05,886
safeAreaInsetsなど
あらゆるシステムの余白をいつでも

323
00:23:05,986 --> 00:23:09,289
adjustedContentInsetに
取り込みます

324
00:23:09,389 --> 00:23:11,458
この例でもそうです

325
00:23:11,558 --> 00:23:14,695
上部と下部にのみ
safeAreaInsetsがあります

326
00:23:14,795 --> 00:23:19,032
これらが取り込まれるので
コンテンツはバーに隠れません

327
00:23:19,132 --> 00:23:23,070
水平方向の左右には
余白はないので問題ありませんが

328
00:23:23,170 --> 00:23:29,576
例えばiPhone Xでテーブルビューを
横向きで表示する際は要注意です

329
00:23:29,743 --> 00:23:31,678
左右にsafeAreaInsetsがあります

330
00:23:31,778 --> 00:23:36,717
alwaysの挙動を使えば
テーブルビューはそれらを取り込み

331
00:23:36,817 --> 00:23:41,188
スクロール領域が増え 水平方向に
スクロール可能となります

332
00:23:41,588 --> 00:23:42,923
困りますよね

333
00:23:43,757 --> 00:23:47,227
それを解決するのが
次のscrollableAxesの挙動です

334
00:23:47,828 --> 00:23:53,734
縦軸と横軸にあるものが
別々に考慮されるようになります

335
00:23:53,834 --> 00:23:59,139
例えばコンテンツサイズが
場合に応じて幅や高さを上回ったり

336
00:23:59,239 --> 00:24:01,942
alwaysBounceHorizontalや

337
00:23:59,239 --> 00:24:01,942
alwaysBounceHorizontalや

338
00:24:02,009 --> 00:24:04,511
alwaysBounceVerticalを
trueにしたりする時です

339
00:24:04,745 --> 00:24:07,514
このような時に
スクロール可能な軸を考慮し

340
00:24:07,614 --> 00:24:11,785
adjustedContentInsetに
システムの余白を取り込みます

341
00:24:11,885 --> 00:24:15,055
後ろの例では
長い記事がスクロールできます

342
00:24:15,489 --> 00:24:18,292
自動で余白が取り込まれたのです

343
00:24:18,392 --> 00:24:20,861
短い記事も見てみましょう

344
00:24:21,328 --> 00:24:23,163
こちらが短い記事です

345
00:24:23,363 --> 00:24:26,733
ナビゲーションバーの下を
見てみましょう

346
00:24:26,833 --> 00:24:27,534
おっと

347
00:24:27,968 --> 00:24:30,971
スクロールできないため
システムの余白を失い―

348
00:24:31,071 --> 00:24:34,074
記事タイトルが
バーの下に隠れました

349
00:24:34,274 --> 00:24:37,811
それでは解決方法を
ご紹介しましょう

350
00:24:37,911 --> 00:24:42,683
alwaysBounceVerticalを
設定するのも ひとつの手でしょう

351
00:24:42,783 --> 00:24:45,652
常に縦スクロールが可能になります

352
00:24:45,752 --> 00:24:49,189
またはautomaticの挙動も使えます

353
00:24:49,556 --> 00:24:54,261
先ほどのscrollableAxesと
似た働きをしますが

354
00:24:54,361 --> 00:24:58,198
さらに別の挙動も可能となるのです

355
00:24:58,298 --> 00:25:02,503
Navigation Controllerの中に
スクロールビューが含まれる場合

356
00:24:58,298 --> 00:25:02,503
Navigation Controllerの中に
スクロールビューが含まれる場合

357
00:25:02,603 --> 00:25:05,772
上部と下部の
contentInsetを調節します

358
00:25:05,873 --> 00:25:10,210
これは縦スクロールが
できない場合も同じです

359
00:25:10,310 --> 00:25:15,249
今回のような短い記事でも
適切な余白を得られます

360
00:25:15,349 --> 00:25:19,286
一般的に要求される挙動なので
これがデフォルトです

361
00:25:19,386 --> 00:25:25,592
しかしautomaticallyAdjustsScroll
ViewInsetsをfalseにしていると

362
00:25:25,692 --> 00:25:30,531
この挙動は無効となり
scrollableAxesと同様になります

363
00:25:31,131 --> 00:25:34,668
そこで登場するのが
最後の挙動 neverです

364
00:25:35,435 --> 00:25:41,308
これを使えば スクロールビューは
contentInsetを調節しません

365
00:25:42,009 --> 00:25:44,912
しかし そうすると弊害があります

366
00:25:45,712 --> 00:25:47,915
第一に スクロールビューが

367
00:25:48,015 --> 00:25:52,920
すべての辺においてsafeArea
Insetsを伝播してしまいます

368
00:25:53,020 --> 00:25:57,758
これは 先ほど述べたような
厄介な挙動を招きます

369
00:25:57,858 --> 00:26:01,562
例えばSafe Areaと関連する
レイアウトマージンが

370
00:25:57,858 --> 00:26:01,562
例えばSafe Areaと関連する
レイアウトマージンが

371
00:26:01,662 --> 00:26:05,632
この挙動により
変わったりするのです

372
00:26:06,400 --> 00:26:13,307
scrollIndicatorInsetsなどの
便利な自動の挙動も無効になります

373
00:26:13,640 --> 00:26:17,678
オンラインでQ&Aを確認したら

374
00:26:17,778 --> 00:26:22,816
このプロパティはneverにすべきと
勧められたとします

375
00:26:22,916 --> 00:26:27,921
オーバーレイの追加を
システムに知らせたければ

376
00:26:28,021 --> 00:26:33,794
追加でsafeAreaInsetsを
使うことを検討してみてください

377
00:26:33,894 --> 00:26:40,968
もしくはcontentInsetプロパティを
直接 修正してもいいでしょう

378
00:26:41,068 --> 00:26:47,107
効果的なadjustedContentInsetの
ために追加や削除を行うのです

379
00:26:47,574 --> 00:26:52,746
それでは最後の総括を
ラッセルにお願いしましょう

380
00:26:53,213 --> 00:26:57,184
(拍手)

381
00:26:58,252 --> 00:26:59,286
ありがとう

382
00:27:00,420 --> 00:27:06,493
当社は異なる環境に対応するAPIを
これまで多数 提供してきました

383
00:27:06,593 --> 00:27:09,463
中でもSafe Areaは新しいものです

384
00:27:09,563 --> 00:27:14,234
各種コンセプトとSafe Areaとの
関連をご紹介します

385
00:27:15,836 --> 00:27:19,139
これはアプリケーションの
最初の画面です

386
00:27:19,239 --> 00:27:23,677
Tab Bar Controllerや
Navigation Controller

387
00:27:23,777 --> 00:27:26,547
そしてContent View
Controllerがあります

388
00:27:27,414 --> 00:27:31,919
３つのView Controllerのビューは
どれもフルスクリーンです

389
00:27:32,085 --> 00:27:35,889
これにより ホームインジケータや
ステータスバーの下で

390
00:27:35,989 --> 00:27:38,625
タブバーやナビゲーションバーが
拡大します

391
00:27:38,725 --> 00:27:42,095
コンテンツも拡大し
スクロールします

392
00:27:43,630 --> 00:27:49,036
ですがこれらのオーバーラップは
避けなければなりません

393
00:27:50,204 --> 00:27:53,974
safeAreaInsetsはTab Bar
Controllerを介してスタートします

394
00:27:54,074 --> 00:27:56,109
Tab Bar Controllerは

395
00:27:56,210 --> 00:27:59,780
ホームインジケータとステータス
バーの余白のみを受け取ります

396
00:28:00,647 --> 00:28:03,851
Navigation Controllerは
その内側にあるので

397
00:28:03,951 --> 00:28:07,821
タブバーを構成する
下部のSafe Areaも受け取ります

398
00:28:08,388 --> 00:28:13,293
Content View Controllerは上下の
safeAreaInsetsを受け取ります

399
00:28:14,795 --> 00:28:20,500
横向きになってもsafeAreaInsetsが
上部と下部に確認できます

400
00:28:20,601 --> 00:28:26,273
しかし画面サイズに合わせて
左右にも余白があります

401
00:28:26,373 --> 00:28:30,978
View Controllerの階層上位にある
画面から伝播されたものです

402
00:28:32,146 --> 00:28:34,515
今から この例を使って

403
00:28:34,615 --> 00:28:40,220
独自のビューを実装する場合の
Safe Areaの使い方を考えましょう

404
00:28:40,721 --> 00:28:45,392
このカスタムビューは iPhone Xで
実行されているとは知らず

405
00:28:45,492 --> 00:28:49,730
Container View Controllerの
中にあることも知りません

406
00:28:50,531 --> 00:28:53,033
これはカプセル化の考え方です

407
00:28:53,133 --> 00:28:59,006
もしビューが４辺で与えられた
safeAreaInsetsだけを読み

408
00:28:59,106 --> 00:29:04,678
異なる任意のsafeAreaInsetsに
適応できるとしましょう

409
00:28:59,106 --> 00:29:04,678
異なる任意のsafeAreaInsetsに
適応できるとしましょう

410
00:29:04,812 --> 00:29:07,514
そうすると それらのビューは

411
00:29:07,614 --> 00:29:14,154
アプリケーション全体で動かせ
環境によって異なる実行も可能です

412
00:29:16,523 --> 00:29:20,794
次は ステータスバーを
隠す方法についてです

413
00:29:22,095 --> 00:29:24,364
ステータスバーを隠すには

414
00:29:24,464 --> 00:29:29,736
矩形画面の縦スクリーンで
20ptの範囲が要求されます

415
00:29:30,737 --> 00:29:35,042
方法は prefersStatusBarHiddenを
オーバーライドし

416
00:29:35,142 --> 00:29:37,344
trueとするだけです

417
00:29:37,444 --> 00:29:41,615
これは内包するView Controllerの
階層にも伝播され

418
00:29:41,715 --> 00:29:45,385
システムのルートにも尊重されます

419
00:29:46,587 --> 00:29:52,993
しかしiPhone Xでは 同じ方法では
センサーハウジングが隠れません

420
00:29:53,160 --> 00:29:55,662
この下にコンテンツは入りませんね

421
00:29:55,762 --> 00:29:57,765
(笑い)

422
00:29:57,865 --> 00:30:01,768
UIKitは そのようなUIを
作らせないようにしています

423
00:29:57,865 --> 00:30:01,768
UIKitは そのようなUIを
作らせないようにしています

424
00:30:01,869 --> 00:30:05,772
その代わりiPhone Xの
Navigation Controllerは

425
00:30:05,939 --> 00:30:10,711
ナビゲーションバーが見える時は
常にステータスバーを表示します

426
00:30:11,812 --> 00:30:15,415
ですのでステータスバーを
隠したい時は

427
00:30:15,516 --> 00:30:20,287
ナビゲーションバーと併せて
隠すことをお勧めします

428
00:30:21,755 --> 00:30:26,026
また 没入感のある
体験を作りたい時は

429
00:30:26,126 --> 00:30:30,364
すべてのオーバーレイと
コントロールを隠しましょう

430
00:30:30,831 --> 00:30:34,701
ユーザをコンテンツに
集中させるだけでなく

431
00:30:34,802 --> 00:30:39,606
全デバイスへの適応を後押しする
デザインテクニックです

432
00:30:41,608 --> 00:30:44,545
没入感のある体験に関連して

433
00:30:44,845 --> 00:30:49,917
幅が広い環境での
テキストの表示について話します

434
00:30:51,318 --> 00:30:57,458
テキストが表示されていますが
縁いっぱいには広がっていませんね

435
00:30:58,492 --> 00:31:02,663
これを広げてしまうと
ある問題が起きます

436
00:30:58,492 --> 00:31:02,663
これを広げてしまうと
ある問題が起きます

437
00:31:02,763 --> 00:31:07,901
広い範囲を１行１行 読むのは
目にとって負担なのです

438
00:31:08,001 --> 00:31:11,104
フォントサイズによっては
特に顕著です

439
00:31:11,638 --> 00:31:17,544
それを避けるには可読領域に収めて
テキストを表示します

440
00:31:17,644 --> 00:31:20,314
システムが推奨する可読領域は

441
00:31:20,414 --> 00:31:24,918
ダイナミックタイプの
フォントサイズに基づきます

442
00:31:25,018 --> 00:31:29,923
ダイナミックタイプは iOSの
アダプティブな要素のひとつです

443
00:31:31,225 --> 00:31:34,495
可読領域の設定に役立つのが

444
00:31:34,595 --> 00:31:37,664
UIViewのAPI
readableContentGuideです

445
00:31:37,765 --> 00:31:44,471
これはマージンやSafe Areaの
レイアウトガイドと ほぼ同じです

446
00:31:46,673 --> 00:31:52,679
可読領域はダイナミックタイプの
フォントサイズに基づきます

447
00:31:52,780 --> 00:31:57,384
ですからユーザが
フォントサイズを変えると

448
00:31:57,484 --> 00:32:00,687
可読領域も拡大縮小します

449
00:31:57,484 --> 00:32:00,687
可読領域も拡大縮小します

450
00:32:03,257 --> 00:32:08,228
では 縦向きにして
サイドバーを表示します

451
00:32:08,695 --> 00:32:11,899
記事の表示は狭くなりました

452
00:32:11,999 --> 00:32:15,769
ここでの最大可読領域は

453
00:32:15,869 --> 00:32:19,573
実際はこの領域よりも
広くなっています

454
00:32:20,174 --> 00:32:27,181
readableContentGuideは必ずしも
最大可読領域を報告しません

455
00:32:27,281 --> 00:32:29,983
レイアウトマージンに
固定されるので

456
00:32:30,083 --> 00:32:33,921
readableContentGuideに
とらわれません

457
00:32:34,021 --> 00:32:37,024
レイアウトマージンの外にも
出ません

458
00:32:39,560 --> 00:32:43,597
では Safe Areaがある場合を
見ていきましょう

459
00:32:43,697 --> 00:32:47,167
readableContentGuideは
layoutMarginsと同様に

460
00:32:47,267 --> 00:32:51,839
その余白はsafeAreaInsetsの
値を含みます

461
00:32:53,474 --> 00:32:58,979
デフォルトのダイナミックタイプの
フォントサイズにおいては通常―

462
00:32:59,079 --> 00:33:05,119
可読領域はどの向きでも
iPhoneデバイスより幅広になります

463
00:32:59,079 --> 00:33:05,119
可読領域はどの向きでも
iPhoneデバイスより幅広になります

464
00:33:05,219 --> 00:33:07,421
つまり作用しません

465
00:33:07,521 --> 00:33:14,094
しかしユーザがデフォルトより
小さいフォントを選ぶと作用します

466
00:33:14,194 --> 00:33:16,730
ぜひ導入してください

467
00:33:18,866 --> 00:33:24,671
ではテーブルビューに戻り
可読領域を見ていきましょう

468
00:33:25,405 --> 00:33:32,045
テーブルビューは
多くのUI要素をレイアウトする際に

469
00:33:32,146 --> 00:33:35,082
レイアウトマージンを使います

470
00:33:35,182 --> 00:33:40,287
多くのUI要素とは
分割線やシステムのアクセサリや

471
00:33:40,387 --> 00:33:43,791
システムのセルスタイルの
ラベルなどです

472
00:33:43,891 --> 00:33:50,364
セルの中でビューをマージンに
接するようにレイアウトすると

473
00:33:51,064 --> 00:33:58,238
テーブルビューのマージンを
調節すれば要素を同時に動かせます

474
00:33:58,739 --> 00:34:05,379
テキストが複数行ある場合は
テーブルビューのマージンを調節し

475
00:33:58,739 --> 00:34:05,379
テキストが複数行ある場合は
テーブルビューのマージンを調節し

476
00:34:05,479 --> 00:34:10,250
可読領域の中で各要素を
並べるといいでしょう

477
00:34:10,617 --> 00:34:16,690
それを行えるAPIが cellLayout
MarginsFollowReadableWidthです

478
00:34:16,790 --> 00:34:20,594
falseの場合 テーブルビューは
システムのマージンを使い

479
00:34:20,694 --> 00:34:24,164
trueにすると余白が入ります

480
00:34:24,965 --> 00:34:31,505
このプロパティのデフォルト値は
iOS 12で変更されました

481
00:34:31,772 --> 00:34:37,210
以前はデフォルトでtrueでしたが
現在はfalseです

482
00:34:37,744 --> 00:34:42,382
特にスマートフォンにおいては
影響はないはずです

483
00:34:42,482 --> 00:34:46,687
通常はデフォルト値のままを
お勧めします

484
00:34:46,786 --> 00:34:53,126
テーブルビューが多くの行を
含みそうならtrueとしてください

485
00:34:54,695 --> 00:34:56,228
Interface Builderでは

486
00:34:56,330 --> 00:35:00,167
“Follow Readable Width”に
チェックを入れてください

487
00:34:56,330 --> 00:35:00,167
“Follow Readable Width”に
チェックを入れてください

488
00:35:02,903 --> 00:35:07,441
可読領域に関連する話題は
ここまでにして

489
00:35:08,242 --> 00:35:13,580
テーブルビューとSafe Areaの
関連についてお話しします

490
00:35:13,680 --> 00:35:17,384
テーブルビューのセル内の
コンテンツビューは

491
00:35:17,484 --> 00:35:20,654
Safe Areaを超えては広がりません

492
00:35:21,955 --> 00:35:26,159
しかしデフォルトでは背景および
選択された背景ビューが

493
00:35:26,260 --> 00:35:30,164
Safe Areaを超えて広がります

494
00:35:30,998 --> 00:35:34,768
例えば カスタムテーブルビューの
セルに置くコンテンツを

495
00:35:34,868 --> 00:35:39,406
Safe Areaの外に広げ
画面の縁まで表示したいとします

496
00:35:39,506 --> 00:35:45,212
その場合は背景または選択された
背景ビューに置いてください

497
00:35:45,345 --> 00:35:51,985
もしくはUITableviewのinsets
ContentViewsToSafeAreaを使います

498
00:35:52,319 --> 00:35:54,321
デフォルトではtrueですが

499
00:35:54,421 --> 00:35:59,059
falseにするとコンテンツビューも
縁まで広げられます

500
00:36:00,494 --> 00:36:03,931
Interface Builderからも
使用が可能です

501
00:36:06,700 --> 00:36:09,002
縦向きに戻します

502
00:36:09,103 --> 00:36:14,875
このアプリケーションは下部から
ピッカービューが表示されます

503
00:36:15,509 --> 00:36:22,182
この画面のSafe Areaについて
考えてみましょう

504
00:36:22,282 --> 00:36:26,487
ピッカービューのレイアウトは
Safe Area内に

505
00:36:26,587 --> 00:36:28,922
合わせる必要があります

506
00:36:30,924 --> 00:36:36,997
UIPickerViewをはじめ
大抵のシステムコントロールは

507
00:36:37,097 --> 00:36:40,868
Safe Areaについて
何も認識しません

508
00:36:40,968 --> 00:36:45,806
内的にどう再レイアウト
されるかなどが不明だからです

509
00:36:46,406 --> 00:36:50,410
こういったビューのレイアウトに
お勧めなのが

510
00:36:50,510 --> 00:36:54,147
コンテナビューの内側に
置く方法です

511
00:36:54,815 --> 00:37:01,355
コンテナビューはSafe Areaを
認識していないコンテンツを

512
00:36:54,815 --> 00:37:01,355
コンテナビューはSafe Areaを
認識していないコンテンツを

513
00:37:01,455 --> 00:37:06,193
safeAreaInsetsを分析することで
Safe Area内に置きます

514
00:37:06,293 --> 00:37:10,330
また 背景を
与えることもできるので

515
00:37:10,998 --> 00:37:16,236
Safe Areaの外にある画面の縁まで
拡大することもできます

516
00:37:18,272 --> 00:37:23,577
Safe Areaと 画面の縁に近い要素に
関連したテクニックはまだあります

517
00:37:23,677 --> 00:37:28,048
コントロールやボタンがある場合を
考えてください

518
00:37:28,148 --> 00:37:32,653
あるデバイスでは
Safe Areaの辺に沿って置きますが

519
00:37:32,753 --> 00:37:37,424
safeAreaInsetsが0のデバイスでは
余白が欲しいかもしれません

520
00:37:37,524 --> 00:37:43,897
safeAreaInsetsは見えない空白を
取り込んでいる場合があるからです

521
00:37:43,997 --> 00:37:50,804
そこで どちらのケースにおいても
使える１つの解決法をご紹介します

522
00:37:51,205 --> 00:37:56,343
ダイアグラムを使って
レイアウト制約を２つお見せします

523
00:37:56,443 --> 00:37:59,513
生まれる結果は次のとおりです

524
00:37:59,847 --> 00:38:06,687
１つ目の制約が表しているのは
一般的に加えられるような余白です

525
00:37:59,847 --> 00:38:06,687
１つ目の制約が表しているのは
一般的に加えられるような余白です

526
00:38:06,787 --> 00:38:12,226
スーパービューの下辺から
コントロールの下辺までの制約です

527
00:38:12,326 --> 00:38:14,595
ですが今回は要求しません

528
00:38:14,695 --> 00:38:18,699
safeAreaInsetsが0でない場合に
この制約を破るためです

529
00:38:20,167 --> 00:38:23,203
２つ目は不等式制約で―

530
00:38:23,303 --> 00:38:26,807
コントロールの下辺から
Safe Areaの下辺までの制約です

531
00:38:27,107 --> 00:38:31,779
これにより コントロールは常に
Safe Area内に留まります

532
00:38:33,247 --> 00:38:37,818
safeAreaInsetsを
0から変更してみましょう

533
00:38:37,918 --> 00:38:41,855
不等式制約を使えば
コンテンツは切れず

534
00:38:41,955 --> 00:38:44,858
余白は残ったままです

535
00:38:47,794 --> 00:38:55,035
今回はアダプティブなAPIを
たくさんご紹介しました

536
00:38:55,135 --> 00:38:58,438
layoutMarginsは要素の位置を保ち

537
00:38:58,705 --> 00:39:02,476
safeAreaInsetsは
ビューが見えなくなるのを防ぎます

538
00:38:58,705 --> 00:39:02,476
safeAreaInsetsは
ビューが見えなくなるのを防ぎます

539
00:39:03,377 --> 00:39:07,481
可読領域はテキストを読みやすくし

540
00:39:07,648 --> 00:39:13,821
サイズのクラスはより大きな構造を
実装すべき時を教えてくれます

541
00:39:15,122 --> 00:39:17,524
これらのAPIはフレームワークに

542
00:39:17,624 --> 00:39:22,062
よりハイレベルなコンポーネントを
実装するために使います

543
00:39:22,162 --> 00:39:24,498
スクロールビューやテーブルビュー

544
00:39:24,598 --> 00:39:26,967
コンテナビューコントローラ
などです

545
00:39:27,067 --> 00:39:31,238
他にご紹介したことも
ハイレベルなコンポーネントを―

546
00:39:31,338 --> 00:39:37,311
単純な方法ですべてのデバイスに
適応させることに役立つでしょう

547
00:39:37,978 --> 00:39:41,915
これで きっと皆さんは
“アダプティブ”という原点に返り

548
00:39:42,015 --> 00:39:45,219
アプリケーションを
デザインできるはずです

549
00:39:45,853 --> 00:39:50,290
デバイスごとのコーディングは
不要になります

550
00:39:50,691 --> 00:39:53,260
コードはシンプルで
フレキシブルになり

551
00:39:53,360 --> 00:39:58,765
異なる環境でも長く使える
アプリケーションになるでしょう

552
00:40:00,434 --> 00:40:04,605
さらなる情報や本日のスライドは
オンラインでどうぞ

553
00:40:05,272 --> 00:40:08,509
ご来場いただき
ありがとうございました

554
00:40:08,609 --> 00:40:12,579
(拍手)