
1
00:00:07,074 --> 00:00:15,649
(音楽)

2
00:00:18,118 --> 00:00:24,291
（拍手）

3
00:00:24,958 --> 00:00:28,662
ご参加いただき
ありがとうございます

4
00:00:28,762 --> 00:00:32,399
今日は新しいCocoa Touchの
紹介をします

5
00:00:33,400 --> 00:00:36,570
いつもなら
エライザがいますが

6
00:00:36,670 --> 00:00:39,206
今年は私がお話しします

7
00:00:39,306 --> 00:00:42,075
彼女のことは心配無用ですよ

8
00:00:43,010 --> 00:00:47,014
今朝のトピックは
３つの主なカテゴリです

9
00:00:47,614 --> 00:00:52,753
まずはパフォーマンスを含む
フレームワークの更新

10
00:00:53,420 --> 00:00:55,856
そしてAPIの機能強化

11
00:00:55,956 --> 00:00:59,526
SDKには
多くの異なるAPIがあり

12
00:00:59,626 --> 00:01:01,995
通知やメッセージも
その一部です

13
00:00:59,626 --> 00:01:01,995
通知やメッセージも
その一部です

14
00:01:02,563 --> 00:01:05,331
そして最後にSiri Shortcuts

15
00:01:05,933 --> 00:01:08,168
では最初のトピックから

16
00:01:08,468 --> 00:01:10,070
パフォーマンスの更新です

17
00:01:11,705 --> 00:01:15,409
次の３つの領域について
説明します

18
00:01:15,742 --> 00:01:19,012
スクロール メモリ
Auto Layoutです

19
00:01:19,746 --> 00:01:21,415
本題に入る前に

20
00:01:21,515 --> 00:01:25,819
スクロールに関する
背景情報をお話します

21
00:01:28,088 --> 00:01:32,392
iOSのスクロールは
とても一般的です

22
00:01:32,860 --> 00:01:38,432
コンテンツを画面に表示し
ただ移動させているだけ

23
00:01:38,799 --> 00:01:42,703
フレームはとても容易に
生成できます

24
00:01:42,803 --> 00:01:44,938
負荷がないからです

25
00:01:45,639 --> 00:01:49,009
今後の新規のビューに
関しては

26
00:01:49,309 --> 00:01:54,314
最初のフレームの生成が
以前の低負荷なものと比べて

27
00:01:54,414 --> 00:01:56,250
少し高負荷になります

28
00:01:57,451 --> 00:02:01,588
一旦 読み込めば
負荷はかかりません

29
00:01:57,451 --> 00:02:01,588
一旦 読み込めば
負荷はかかりません

30
00:02:02,022 --> 00:02:07,060
CPU上での作業量も
かなり少なくなります

31
00:02:09,163 --> 00:02:14,368
高負荷なフレーム生成の際は
何が起きているのか？

32
00:02:14,768 --> 00:02:17,838
UITableViewの
観点から考えます

33
00:02:17,938 --> 00:02:21,275
UICollectionViewでも
同様です

34
00:02:21,375 --> 00:02:25,579
他のビューでも
似たようなものでしょう

35
00:02:26,813 --> 00:02:32,186
高負荷なフレームの生成は
TableViewの実装から

36
00:02:32,286 --> 00:02:34,588
cellForRowAt indexPath
メソッドです

37
00:02:36,056 --> 00:02:39,593
まず表示したいセルを
取得するために

38
00:02:39,760 --> 00:02:43,230
再利用可能な
キューからデキューを試みる

39
00:02:44,031 --> 00:02:49,436
利用不可の場合は
メモリの割り当てをします

40
00:02:51,004 --> 00:02:54,575
セルを取得したら
モデルデータを入力

41
00:02:54,875 --> 00:02:58,579
アプリケーションにより
費用は異なりますが

42
00:02:58,679 --> 00:03:02,749
かなり高負荷な操作を
カバーできるでしょう

43
00:02:58,679 --> 00:03:02,749
かなり高負荷な操作を
カバーできるでしょう

44
00:03:02,850 --> 00:03:07,788
例えばデータベースからの
データの読み込みなどです

45
00:03:08,155 --> 00:03:11,391
費用は気になるところですが

46
00:03:11,492 --> 00:03:16,096
この方法が続いていく
傾向にあると思います

47
00:03:17,264 --> 00:03:20,934
高負荷な作業は
これでは終わらず

48
00:03:21,034 --> 00:03:22,736
このメソッドでは―

49
00:03:22,836 --> 00:03:27,741
セルを表示させるために
さらなる作業が必要です

50
00:03:28,141 --> 00:03:32,246
次はセルへの
コンテンツの配置です

51
00:03:32,346 --> 00:03:35,649
ビューのサイズ設定や
正しい位置情報

52
00:03:36,049 --> 00:03:39,620
これには
相当な時間がかかります

53
00:03:39,720 --> 00:03:44,324
テキストの測定といった
高負荷な操作を含むからです

54
00:03:45,626 --> 00:03:48,262
すべてが適切に決まったら

55
00:03:48,362 --> 00:03:53,567
ドローコールを使い
コンテンツを生成します

56
00:03:53,700 --> 00:03:58,005
セル内のサブビューに対し
drawRectを呼び出すのです

57
00:03:58,238 --> 00:04:00,841
この作業も長時間に
わたります

58
00:03:58,238 --> 00:04:00,841
この作業も長時間に
わたります

59
00:04:00,941 --> 00:04:04,178
テキスト描画のような
作業だからです

60
00:04:05,846 --> 00:04:10,551
このコードにより
多くの処理を実行しますが

61
00:04:11,018 --> 00:04:13,921
作業時間の短縮も必要です

62
00:04:14,087 --> 00:04:18,392
我々の60ヘルツの
デバイスだと16ミリ秒

63
00:04:18,492 --> 00:04:22,496
フレームは欠けず
スクロールも滑らかです

64
00:04:23,030 --> 00:04:26,400
120ヘルツの
iPad Proでは―

65
00:04:26,767 --> 00:04:30,003
作業完了まで
わずか８ミリ秒です

66
00:04:30,103 --> 00:04:33,307
迅速な処理が
求められるのです

67
00:04:34,241 --> 00:04:39,313
助けになるのがiOS 10の
Cell Pre-Fetching APIです

68
00:04:39,513 --> 00:04:43,083
そのアイデアは
この作業のためです

69
00:04:43,383 --> 00:04:45,385
セルにモデルデータを入力し

70
00:04:45,486 --> 00:04:50,424
不可欠な部分を
需要に応じて取り出します

71
00:04:50,691 --> 00:04:53,393
早い段階の
バックグラウンド処理なら

72
00:04:53,493 --> 00:04:56,296
他の作業とは重なりません

73
00:04:56,396 --> 00:04:59,500
特に低負荷な
スクロールフレームの

74
00:05:00,534 --> 00:05:02,836
導入はとても簡単です

75
00:05:03,036 --> 00:05:06,773
UITableViewの
先読みプロトコルは

76
00:05:06,874 --> 00:05:10,744
２つのメソッドがあり
必要なのは１つです

77
00:05:10,878 --> 00:05:16,316
それがデータ読み込みなどの
高負荷な作業の移動です

78
00:05:16,416 --> 00:05:19,520
処理を移動することにより

79
00:05:19,620 --> 00:05:23,524
セルが準備され
必要な時に表示されます

80
00:05:25,792 --> 00:05:29,596
これは大きな成功だと
言えるでしょう

81
00:05:30,230 --> 00:05:34,034
ただiOS 12のAppを
見てみると―

82
00:05:34,134 --> 00:05:38,972
この処理が多くの問題を
起こしていました

83
00:05:39,072 --> 00:05:41,108
実際に見てみましょう

84
00:05:43,076 --> 00:05:48,482
iPhone 6 Plusの
スクロール時のトレースです

85
00:05:49,149 --> 00:05:54,521
表示したいフレームが
垂直のバーで示されています

86
00:05:54,955 --> 00:05:58,125
交互の明暗は
各フレームを示します

87
00:05:58,225 --> 00:06:01,428
変更とともに
スワップしたものです

88
00:05:58,225 --> 00:06:01,428
変更とともに
スワップしたものです

89
00:06:01,828 --> 00:06:04,331
幅の広い明るい青色部分

90
00:06:04,431 --> 00:06:09,603
ここでは同一のフレームが
２フレーム分 居座ったのです

91
00:06:09,903 --> 00:06:12,472
顧客がこの現象を見ると

92
00:06:12,573 --> 00:06:17,344
フレームの欠落や
スクロール不良と考えます

93
00:06:18,178 --> 00:06:19,613
さてどうするか？

94
00:06:20,247 --> 00:06:22,816
ここに赤いバーがあります

95
00:06:22,916 --> 00:06:26,520
先ほどの高負荷作業に
費やした時間です

96
00:06:26,720 --> 00:06:29,990
IndexPathや
レイアウトなどすべてです

97
00:06:30,157 --> 00:06:34,461
明らかに16ミリ秒よりも
長くかかっています

98
00:06:34,928 --> 00:06:39,066
このデバイスは
新規フレームのみ表示可能

99
00:06:39,166 --> 00:06:41,368
時間の制限もあります

100
00:06:41,768 --> 00:06:46,440
その期限を超えると
同じフレームは表示できない

101
00:06:46,540 --> 00:06:47,908
残念な事態です

102
00:06:48,175 --> 00:06:49,610
原因は何か？

103
00:06:49,710 --> 00:06:54,147
Appは先読みメソッドを
実装しており

104
00:06:54,248 --> 00:06:57,851
迅速に処理できるはずでした

105
00:06:58,352 --> 00:07:01,288
トレースを詳しく見ましょう

106
00:06:58,352 --> 00:07:01,288
トレースを詳しく見ましょう

107
00:07:01,922 --> 00:07:07,694
先読みAPIとカレントセルの
呼び出しが同時です

108
00:07:08,061 --> 00:07:10,597
ここで呼び出された
セルは―

109
00:07:10,697 --> 00:07:13,567
将来必要になるセルです

110
00:07:13,667 --> 00:07:15,836
処理が重なって起こり

111
00:07:15,969 --> 00:07:20,908
CPU上でフレームの
競合が起こりました

112
00:07:21,008 --> 00:07:24,778
まだ必要のないデータを
取り込んだのです

113
00:07:25,679 --> 00:07:30,217
その競合により
時間がかかってしまいました

114
00:07:30,651 --> 00:07:32,119
iOS 12では―

115
00:07:32,219 --> 00:07:38,091
バックで実行する先読みの
スケジュールを改善しました

116
00:07:38,192 --> 00:07:43,997
CPUの競合を起こさず
連続的に実行させるのです

117
00:07:44,097 --> 00:07:48,168
カレントセルの
読み込み時間も短縮し

118
00:07:48,268 --> 00:07:50,871
フレームの欠落を防ぎます

119
00:07:51,772 --> 00:07:56,743
（拍手）

120
00:07:56,877 --> 00:07:59,513
修正後のAppの分析で

121
00:07:59,613 --> 00:08:05,219
フレーム欠落の驚くべき
新たな原因を発見しました

122
00:07:59,613 --> 00:08:05,219
フレーム欠落の驚くべき
新たな原因を発見しました

123
00:08:05,319 --> 00:08:09,256
それはデバイスに
負荷がない状態で

124
00:08:09,356 --> 00:08:13,994
バックでの実行もなく
スクロールのみでした

125
00:08:14,328 --> 00:08:17,998
それでも
フレーム欠落がありました

126
00:08:18,098 --> 00:08:22,035
バックグランド作業時より
多かったのです

127
00:08:22,402 --> 00:08:24,238
意味が分からず

128
00:08:24,338 --> 00:08:26,273
原因を探りました

129
00:08:26,373 --> 00:08:27,841
レベルを落として―

130
00:08:27,941 --> 00:08:33,480
予定されていた
CPUの動きを観察したのです

131
00:08:33,847 --> 00:08:35,649
別のトレースを見ましょう

132
00:08:36,250 --> 00:08:38,051
先ほどと同じです

133
00:08:38,150 --> 00:08:41,321
幅の広い部分が
フレームの欠落

134
00:08:41,421 --> 00:08:42,990
原因は我々です

135
00:08:43,457 --> 00:08:47,361
ここでCPUパフォーマンスの
時間が分かります

136
00:08:47,661 --> 00:08:52,065
低負荷なフレームで
パフォーマンスが低いのです

137
00:08:52,366 --> 00:08:57,604
バックの実行もなく
スクロールのみだからです

138
00:08:57,704 --> 00:09:00,941
高負荷な作業を
していない時には

139
00:08:57,704 --> 00:09:00,941
高負荷な作業を
していない時には

140
00:09:01,041 --> 00:09:05,345
CPUは低くなり
電池も長く持ちます

141
00:09:05,479 --> 00:09:06,713
それでいい

142
00:09:06,980 --> 00:09:11,185
問題は立ち上がるまでの
時間でした

143
00:09:11,385 --> 00:09:13,487
keynoteと同様の現象です

144
00:09:14,688 --> 00:09:17,257
最終的に立ち上った時には

145
00:09:17,357 --> 00:09:21,929
必要なセルを表示させるには
遅すぎました

146
00:09:22,029 --> 00:09:24,264
フレームは欠落します

147
00:09:24,765 --> 00:09:28,302
我々はフルソフトウエアを
持っているため

148
00:09:28,402 --> 00:09:33,106
iOS 12では高度なUIKitに
情報を格納し

149
00:09:33,207 --> 00:09:37,177
スクロールの状態や
危険域の把握に努めます

150
00:09:37,311 --> 00:09:42,115
その情報を低レベルの
CPUコントローラに移し

151
00:09:42,216 --> 00:09:46,653
より理知的に
発生した現象を把握します

152
00:09:46,753 --> 00:09:49,490
問題発生を予測するのです

153
00:09:49,590 --> 00:09:53,227
さらにCPUパフォーマンスの
デッドラインを―

154
00:09:53,327 --> 00:09:55,863
過去の要求から把握します

155
00:09:56,396 --> 00:09:58,298
この変更により

156
00:09:58,699 --> 00:10:00,968
読み込み開始後に―

157
00:09:58,699 --> 00:10:00,968
読み込み開始後に―

158
00:10:01,068 --> 00:10:05,639
CPUがより素早く
立ち上がります

159
00:10:05,739 --> 00:10:11,311
デッドラインを超えないため
適切な量にするのです

160
00:10:12,212 --> 00:10:17,518
この事実はiOSの
大きな改善をもたらしました

161
00:10:20,921 --> 00:10:25,559
すべてのアプリケーションは
拡張機能が利用できます

162
00:10:25,659 --> 00:10:29,696
しかもコストも
追加作業も必要ありません

163
00:10:30,197 --> 00:10:34,501
しかしやってほしいことも
あります

164
00:10:34,968 --> 00:10:40,007
Cell Pre-Fetching APIが
未導入の場合は

165
00:10:40,240 --> 00:10:41,441
検討を薦めます

166
00:10:41,542 --> 00:10:47,114
データを準備しておくことで
処理が短縮されるからです

167
00:10:49,082 --> 00:10:53,720
セル取り込み時の
危険域の観察も大切です

168
00:10:53,820 --> 00:10:56,423
デマンドの減少を
試みるのです

169
00:10:56,523 --> 00:11:02,329
iOS 12はニーズに応じて
期限内の処理を目指します

170
00:10:56,523 --> 00:11:02,329
iOS 12はニーズに応じて
期限内の処理を目指します

171
00:11:02,529 --> 00:11:06,967
ただ最も大切なことは
作業量の減少でしょう

172
00:11:07,067 --> 00:11:10,137
大切なのは
円滑なスクロール体験です

173
00:11:11,605 --> 00:11:13,807
以上がスクロールの話です

174
00:11:14,374 --> 00:11:17,778
次のトピックに移りましょう

175
00:11:17,978 --> 00:11:18,545
メモリです

176
00:11:19,580 --> 00:11:23,984
なぜここでメモリかと
お思いでしょうか

177
00:11:24,818 --> 00:11:27,855
これには意味があります

178
00:11:27,955 --> 00:11:32,392
メモリは
パフォーマンスだからです

179
00:11:32,759 --> 00:11:35,429
Appでメモリを使えば

180
00:11:35,863 --> 00:11:39,199
パフォーマンスに
影響を与えます

181
00:11:39,466 --> 00:11:41,301
なぜでしょう

182
00:11:41,401 --> 00:11:46,406
システム上のメモリを
高水準の概要で見ると

183
00:11:46,507 --> 00:11:48,575
問題はなさそうです

184
00:11:49,109 --> 00:11:53,447
システムそのものと
他のアプリケーションによる

185
00:11:53,547 --> 00:11:55,849
メモリが使用されており

186
00:11:56,216 --> 00:11:58,519
Appによる使用もあります

187
00:11:58,652 --> 00:12:04,124
新たな割り当て要求に対する
余地も残されています

188
00:11:58,652 --> 00:12:04,124
新たな割り当て要求に対する
余地も残されています

189
00:12:04,525 --> 00:12:09,897
中にはキャッシュを含む
メモリもあるでしょう

190
00:12:09,997 --> 00:12:12,366
急な要求を満たすために―

191
00:12:12,466 --> 00:12:16,370
すぐに使えるメモリも
あるはずですが

192
00:12:17,104 --> 00:12:19,773
大抵 何かに使われています

193
00:12:19,873 --> 00:12:21,975
ただ 利用は可能です

194
00:12:22,476 --> 00:12:25,579
アプリケーションの
メモリ要求で起こる事は？

195
00:12:25,879 --> 00:12:27,648
小さな要求であれば

196
00:12:27,748 --> 00:12:32,186
空き容量分を使えば
問題ないでしょう

197
00:12:32,486 --> 00:12:37,724
この場合は引き続き
問題なく作業を継続できます

198
00:12:39,526 --> 00:12:43,096
大きな要求だったら
どうでしょうか

199
00:12:43,263 --> 00:12:48,168
長時間は必要ないので
心配無用かもしれません

200
00:12:48,268 --> 00:12:52,039
ディスクから画像を取り込み
解凍したり

201
00:12:52,139 --> 00:12:55,742
画像処理の後
捨てるかもしれない

202
00:12:55,843 --> 00:12:59,112
何てことのない
素早い操作です

203
00:12:59,479 --> 00:13:01,081
大きい要求では？

204
00:12:59,479 --> 00:13:01,081
大きい要求では？

205
00:13:01,748 --> 00:13:06,019
今はシステムに取り込める
メモリが増えており

206
00:13:06,119 --> 00:13:08,422
満足ができない場合は―

207
00:13:08,522 --> 00:13:11,625
どこかでメモリを
探したりします

208
00:13:12,192 --> 00:13:17,631
この要求が収まるのは
グレー部分になるでしょう

209
00:13:18,832 --> 00:13:24,638
今のところ心配するのは
自分のAppだけでしょう

210
00:13:25,539 --> 00:13:26,073
しかし

211
00:13:26,740 --> 00:13:32,379
それぞれの顧客の要求により
影響が出てくるはずです

212
00:13:32,646 --> 00:13:37,451
もちろんAppへの影響が
現時点では重要です

213
00:13:37,718 --> 00:13:41,255
システムはメモリを
明け渡す必要があり

214
00:13:41,355 --> 00:13:45,959
実際 空きを見つけるのは
カーネルなのです

215
00:13:46,059 --> 00:13:50,430
カーネルがCPU上で操作し
利用可能にします

216
00:13:50,764 --> 00:13:53,100
メモリに費やす時間は―

217
00:13:53,200 --> 00:13:56,737
Appが行う本来の作業に
費やされるべきです

218
00:13:57,070 --> 00:14:02,176
大量の要求を受け入れるか
要求を減らすことで

219
00:13:57,070 --> 00:14:02,176
大量の要求を受け入れるか
要求を減らすことで

220
00:14:02,276 --> 00:14:07,080
Appのパフォーマンスに
大きな影響を与えます

221
00:14:07,181 --> 00:14:11,118
さらに顧客満足にも
つながるでしょう

222
00:14:12,619 --> 00:14:17,124
メモリ使用量の圧縮には
多くの方法があります

223
00:14:17,224 --> 00:14:20,527
分析や調査をしても
いいでしょう

224
00:14:20,727 --> 00:14:24,031
ここで１つのテクニックを
紹介します

225
00:14:24,131 --> 00:14:28,302
iOS 12でメモリ使用量の
減少を助けるのが

226
00:14:28,869 --> 00:14:31,138
Automatic Backing Storeです

227
00:14:31,839 --> 00:14:36,710
ポートレートモードで
プレーリードッグを描くと

228
00:14:37,244 --> 00:14:39,012
その容量は？

229
00:14:39,446 --> 00:14:42,616
iPhone Xの
解像度は横375

230
00:14:42,716 --> 00:14:46,086
アスペクト比を保護するため
縦は250です

231
00:14:47,621 --> 00:14:49,356
使用メモリ量は？

232
00:14:49,523 --> 00:14:55,662
375×250の３倍解像度で
ピクセルあたり64ビット

233
00:14:55,762 --> 00:15:01,735
ディープカラー対応のため
2.2メガバイトが必要です

234
00:14:55,762 --> 00:15:01,735
ディープカラー対応のため
2.2メガバイトが必要です

235
00:15:01,969 --> 00:15:07,074
妥当な数字ですが
メモリは消費されます

236
00:15:07,174 --> 00:15:10,878
完全な忠実性を持った
画像なので

237
00:15:10,978 --> 00:15:13,914
相当のメモリ量が必要です

238
00:15:14,014 --> 00:15:15,849
これは予測どおりです

239
00:15:16,350 --> 00:15:21,522
今度は忠実性のない
プレーリードッグを描きます

240
00:15:21,622 --> 00:15:25,359
Core Graphicsを使った
モノクロ画像です

241
00:15:25,459 --> 00:15:28,061
Apple Pencilで描きました

242
00:15:28,161 --> 00:15:29,797
こんな感じです

243
00:15:30,497 --> 00:15:34,868
この画に必要な
メモリはどれくらいか？

244
00:15:35,435 --> 00:15:38,906
実は同じメモリ量なのです

245
00:15:39,273 --> 00:15:43,577
メモリの使い方としては
良くありません

246
00:15:43,777 --> 00:15:48,649
特徴であるディープカラーも
使われていません

247
00:15:49,116 --> 00:15:51,151
改善の余地ありです

248
00:15:51,251 --> 00:15:54,888
iOS 12の
Automatic Backing Storeは

249
00:15:54,988 --> 00:15:58,125
このケースにぴったりです

250
00:15:58,759 --> 00:16:03,831
drawRectの実装により
バッキングストアに保存され

251
00:15:58,759 --> 00:16:03,831
drawRectの実装により
バッキングストアに保存され

252
00:16:03,931 --> 00:16:07,234
コンテンツの奥行きごとに
分けられます

253
00:16:07,334 --> 00:16:11,572
このモノクロの
スケッチの画像ですが

254
00:16:11,705 --> 00:16:15,275
自動的に８ビットに
定義されるでしょう

255
00:16:15,375 --> 00:16:17,744
64ビットではありません

256
00:16:17,911 --> 00:16:22,316
これにより各ビューの
要求メモリが減少します

257
00:16:22,449 --> 00:16:26,720
2.2メガバイトから
275キロバイトになりました

258
00:16:27,187 --> 00:16:32,392
異なるアプリケーションに
対応した大きな改善です

259
00:16:32,526 --> 00:16:36,497
（拍手）

260
00:16:36,830 --> 00:16:42,069
これはiOS 12 SDKに
デフォルト搭載されています

261
00:16:43,070 --> 00:16:47,474
UIViewに実装されたdrawRect
では自動で実行されます

262
00:16:47,574 --> 00:16:49,476
UIGraphicsImageRendererで

263
00:16:49,576 --> 00:16:52,913
オフスクリーンビットマップに
描画する際も同様です

264
00:16:53,113 --> 00:16:55,415
UIGraphicsImageRendererに関しては

265
00:16:55,516 --> 00:17:00,454
画の最終的な使用目的を
決めておく必要はありません

266
00:16:55,516 --> 00:17:00,454
画の最終的な使用目的を
決めておく必要はありません

267
00:17:00,554 --> 00:17:04,892
そのため
自動的な操作が必要ない場合

268
00:17:05,224 --> 00:17:09,863
希望の保存方法を
選ぶことができます

269
00:17:09,963 --> 00:17:15,536
例えば新しいRange APIで
拡張範囲を指定するのです

270
00:17:16,103 --> 00:17:21,241
UIImageについて
さらに多くを学ぶには―

271
00:17:21,340 --> 00:17:24,912
週の後半のセッションに
ご参加ください

272
00:17:26,079 --> 00:17:28,080
では次のトピックです

273
00:17:28,415 --> 00:17:30,984
Auto Layoutに移りましょう

274
00:17:31,718 --> 00:17:36,757
iOS 10のAuto Layoutを
大きく改善させました

275
00:17:36,857 --> 00:17:42,396
Auto Layoutの最適化は
とても困難だったのです

276
00:17:42,629 --> 00:17:47,434
iOS 12では標準で
高速になりました

277
00:17:47,534 --> 00:17:49,503
多くの事例があります

278
00:17:49,970 --> 00:17:53,173
Auto Layoutを分析しながら

279
00:17:53,273 --> 00:17:58,679
我々のシステムやAppでの
使用状況も考えました

280
00:17:58,812 --> 00:18:03,717
そしてたくさんの
欠陥が見つかったのです

281
00:17:58,812 --> 00:18:03,717
そしてたくさんの
欠陥が見つかったのです

282
00:18:03,951 --> 00:18:09,723
ここでは最適化のための
最良の方法をお見せします

283
00:18:10,724 --> 00:18:15,696
Auto Layoutの
速さを実感してください

284
00:18:16,230 --> 00:18:18,799
一般的なビューを追加して
Auto Layoutの―

285
00:18:18,899 --> 00:18:20,534
漸近特性を見ます

286
00:18:20,634 --> 00:18:24,738
一般的なユーザに対し
ビューを追加しました

287
00:18:25,606 --> 00:18:29,476
ビューの数を
劇的に増やすことで

288
00:18:29,576 --> 00:18:32,246
何が起きるかを見るためです

289
00:18:32,346 --> 00:18:34,615
膨大な数のビューにより

290
00:18:34,715 --> 00:18:38,452
パフォーマンスへの悪影響が
明らかになるのです

291
00:18:38,852 --> 00:18:41,655
その結果をもとに
最適化を行えば

292
00:18:41,755 --> 00:18:45,058
ビューの数が少なくても
高速化が実現できるのです

293
00:18:45,292 --> 00:18:49,162
最も単純なケースを
見てみましょう

294
00:18:49,263 --> 00:18:52,833
枠の中に
兄弟ビューがあります

295
00:18:53,000 --> 00:18:56,970
外枠や他のビューからの
制約はありますが

296
00:18:57,070 --> 00:19:00,240
互いの制約はなく
独立しています

297
00:18:57,070 --> 00:19:00,240
互いの制約はなく
独立しています

298
00:19:00,607 --> 00:19:04,044
iOS 11では
ビューの数を増やすほど

299
00:19:04,144 --> 00:19:07,080
コストは増えていきました

300
00:19:07,481 --> 00:19:12,186
これは当然のことで
想像しうる事態です

301
00:19:12,286 --> 00:19:15,722
基本的に
固定負荷がかかりますし

302
00:19:15,823 --> 00:19:19,026
独立した新たなビューを
追加するたびに

303
00:19:19,126 --> 00:19:21,662
固定負荷がかかるからです

304
00:19:22,496 --> 00:19:28,268
予測どおりの状態が
iOS 12でも続くはずでした

305
00:19:28,535 --> 00:19:32,773
しかし担当チームが
固定負荷の減少を試み

306
00:19:32,873 --> 00:19:36,343
ビューを低負荷に
追加できたのです

307
00:19:37,311 --> 00:19:39,880
さらに興味深い例です

308
00:19:39,980 --> 00:19:43,083
こちらは依存した
兄弟ビューです

309
00:19:43,283 --> 00:19:46,520
複数の子ビューが

310
00:19:46,620 --> 00:19:49,156
お互いを制約しています

311
00:19:49,256 --> 00:19:52,059
依存したレイアウトです

312
00:19:52,659 --> 00:19:57,664
残念ながらiOS 11の
漸近線は良くありません

313
00:19:58,131 --> 00:20:00,500
急増しているのです

314
00:19:58,131 --> 00:20:00,500
急増しているのです

315
00:20:00,634 --> 00:20:02,703
ビューを追加すると

316
00:20:02,803 --> 00:20:07,574
驚くほどのコストが
発生するのが分かります

317
00:20:07,808 --> 00:20:11,578
チームは原因を
必死で追求しました

318
00:20:11,678 --> 00:20:15,215
そしてアルゴリズムを
修正したのです

319
00:20:15,349 --> 00:20:19,086
iOS 12では緩やかな
増加になりました

320
00:20:19,186 --> 00:20:22,756
（拍手）

321
00:20:23,857 --> 00:20:28,328
チームは多くのケースで
固定負荷削減に努めています

322
00:20:29,096 --> 00:20:33,734
さて ネストビューという
一般的なビューがあります

323
00:20:33,834 --> 00:20:38,005
内側が外側から
制約を受けるのです

324
00:20:38,105 --> 00:20:41,241
Appでは一般的な
パターンで―

325
00:20:41,341 --> 00:20:45,746
残念ながらiOS 11での
コストは急増しました

326
00:20:45,913 --> 00:20:50,951
しかしこちらもiOS 12での
改善に成功しました

327
00:20:51,084 --> 00:20:54,288
（拍手）

328
00:20:55,022 --> 00:20:59,693
iOS 12のAuto Layoutでの
改善は多数あり

329
00:20:59,793 --> 00:21:04,398
iOS 12のインストール後に
実感できるでしょう

330
00:20:59,793 --> 00:21:04,398
iOS 12のインストール後に
実感できるでしょう

331
00:21:04,898 --> 00:21:08,368
Auto Layoutを習得するには

332
00:21:08,469 --> 00:21:11,438
さまざまなレイアウトを
実際に試し

333
00:21:11,538 --> 00:21:14,374
感覚を養ってください

334
00:21:14,474 --> 00:21:18,779
一般的な落とし穴については

335
00:21:18,879 --> 00:21:22,549
週後半のセッションを
チェックしてください

336
00:21:25,052 --> 00:21:29,389
最後のトピックは
Swiftificationです

337
00:21:30,791 --> 00:21:34,394
iOS 12では
Swift 4.2を導入

338
00:21:34,561 --> 00:21:37,264
Swift 4.2で
感じてほしいのは

339
00:21:37,364 --> 00:21:42,736
App全体でSwiftを
使用した時の快適さです

340
00:21:42,836 --> 00:21:49,076
特に他のSwiftとの間にある
相互作用を感じてほしいです

341
00:21:49,576 --> 00:21:51,445
我々はUIKitを査定し

342
00:21:51,545 --> 00:21:55,182
自然にフィットするように
しました

343
00:21:55,616 --> 00:22:00,854
UIKitに加えた変更も
自動に移行できたのです

344
00:21:55,616 --> 00:22:00,854
UIKitに加えた変更も
自動に移行できたのです

345
00:22:00,954 --> 00:22:04,758
この更新による
追加作業はありません

346
00:22:05,692 --> 00:22:09,897
お話ししている
３つのカテゴリについて

347
00:22:09,997 --> 00:22:16,303
SDKを確認すれば大幅な
改善と向上に気づくでしょう

348
00:22:16,603 --> 00:22:19,973
型 定数 関数の
ネスティングの話です

349
00:22:20,541 --> 00:22:22,876
まずは型のネスティング

350
00:22:23,510 --> 00:22:25,045
Swift 4において

351
00:22:25,145 --> 00:22:30,517
グローバル名前空間に
UIApplication.Stateの存在が

352
00:22:30,651 --> 00:22:36,356
このように他のクラスと
強力に併用されている場合

353
00:22:36,457 --> 00:22:38,625
クラス内に
ネスティングします

354
00:22:38,725 --> 00:22:43,297
我々はすべての列挙型や
グローバル型を調査

355
00:22:43,397 --> 00:22:46,733
そして関連するクラスの
子型へ移動

356
00:22:46,833 --> 00:22:49,670
これが
UIApplication.Stateです

357
00:22:49,770 --> 00:22:55,609
より強力なメッセージを送り
互いを見つけやすくなります

358
00:22:56,076 --> 00:23:00,180
それは理解力の向上にも
つながるうえに

359
00:22:56,076 --> 00:23:00,180
それは理解力の向上にも
つながるうえに

360
00:23:00,280 --> 00:23:02,516
混乱を避けられます

361
00:23:02,616 --> 00:23:05,352
UITabBarItemPositioningを
見ましょう

362
00:23:05,619 --> 00:23:08,689
UITabBar ItemPositioning
でしょうか？

363
00:23:08,789 --> 00:23:11,258
それとも
UITabBarItem Positioning？

364
00:23:11,725 --> 00:23:14,261
どちらでもいいのですが

365
00:23:15,229 --> 00:23:20,300
UITabBar ItemPositioningが
Swift 4.2では正解です

366
00:23:21,969 --> 00:23:25,939
型に加え多くの定数も
ネスティングしました

367
00:23:26,039 --> 00:23:29,276
Swift 4では
NSnotificationで―

368
00:23:29,376 --> 00:23:33,080
NSNotification.Nameという
名前空間でした

369
00:23:33,180 --> 00:23:37,784
関連するユーザ情報キーは
グローバル定数だけでした

370
00:23:38,018 --> 00:23:43,123
AppKitとの一貫性を保ち
型と関連づけるため

371
00:23:43,390 --> 00:23:46,326
クラスの下で
ネスティングをしました

372
00:23:46,427 --> 00:23:50,764
そのため変更指示なども
UIApplicationの下です

373
00:23:50,864 --> 00:23:56,803
ユーザキーも移したため
同じ位置に配置されました

374
00:23:58,205 --> 00:24:02,309
さらにUIKitの
グローバル定数も調査のうえ

375
00:23:58,205 --> 00:24:02,309
さらにUIKitの
グローバル定数も調査のうえ

376
00:24:02,409 --> 00:24:05,179
適切な位置にネスティング
しました

377
00:24:05,279 --> 00:24:08,649
UIFloatRangeZeroや
UIFloatRangeInfiniteも

378
00:24:08,749 --> 00:24:11,785
UIFloatRange上で
属性を持つだけでなく

379
00:24:11,919 --> 00:24:14,988
容易に見つけ
使うことができます

380
00:24:15,089 --> 00:24:19,927
UIFloatRangeには
.zeroや .infiniteを使い

381
00:24:20,060 --> 00:24:26,066
Xcodeが自動完了を提案し
意味のある役割を果たせます

382
00:24:28,035 --> 00:24:31,271
最後にグローバル関数の
調査です

383
00:24:31,472 --> 00:24:35,008
UIEdgeInsetsや
UIImageなどには

384
00:24:35,109 --> 00:24:38,445
異なる型の
グローバル関数があります

385
00:24:38,545 --> 00:24:44,251
Swift 4.2でこれらは
適切な型のメソッドになり

386
00:24:44,518 --> 00:24:46,854
insetRectが容易になります

387
00:24:46,954 --> 00:24:51,492
イメージからpngDataも
取得できます

388
00:24:52,192 --> 00:24:57,498
（拍手）

389
00:24:57,598 --> 00:25:00,901
さらに重要な
関数を紹介します

390
00:24:57,598 --> 00:25:00,901
さらに重要な
関数を紹介します

391
00:25:01,001 --> 00:25:05,606
UIKitの多くの型が
文字列変換関数でした

392
00:25:05,706 --> 00:25:09,376
CGPoint CGRect CGSize
CGVectorなどが―

393
00:25:09,476 --> 00:25:12,379
toとfromの文字列
だったのです

394
00:25:12,479 --> 00:25:15,916
これらの行き先を判断する時

395
00:25:16,183 --> 00:25:19,253
異なる役割に気づきました

396
00:25:19,353 --> 00:25:21,555
１つはエンコードと
デコード

397
00:25:21,655 --> 00:25:26,627
他方はデバッグの記述より
見つけたprintコードでした

398
00:25:26,860 --> 00:25:29,263
役割は全く違いますが

399
00:25:29,496 --> 00:25:33,433
Swiftは
どちらのサポートも可能です

400
00:25:33,600 --> 00:25:38,505
Swiftのおかげで
すべての型が機能しています

401
00:25:38,739 --> 00:25:42,576
さらにすべてが
コードに準拠しています

402
00:25:42,676 --> 00:25:48,448
異なる型のエンコードや
デコードが簡単にできます

403
00:25:48,649 --> 00:25:53,587
（拍手）

404
00:25:54,121 --> 00:25:57,891
Swiftのデバッグプリントは
Objective-Cより簡単で

405
00:25:57,991 --> 00:26:01,061
変換を行う必要がありません

406
00:25:57,991 --> 00:26:01,061
変換を行う必要がありません

407
00:26:01,261 --> 00:26:05,065
内部の型により
直接入力ができます

408
00:26:05,165 --> 00:26:07,067
デバッグ用に
プリントする場合や

409
00:26:07,167 --> 00:26:09,036
ログ記録を取る場合には

410
00:26:09,136 --> 00:26:12,406
print関数に直接
当てはめればいいだけです

411
00:26:12,940 --> 00:26:15,676
既に存在するコードは

412
00:26:15,776 --> 00:26:19,479
古い文字列変換関数を
使っており

413
00:26:19,580 --> 00:26:23,050
今後のためには
互換性が必要です

414
00:26:23,350 --> 00:26:28,388
実際に我々はリネームをして
NSCoderに移動させました

415
00:26:28,489 --> 00:26:33,961
これでこのメソッドの役目が
強調されることになり

416
00:26:34,094 --> 00:26:36,230
自然にフィットしたのです

417
00:26:37,898 --> 00:26:43,036
これらはSwift 4.2における
iOS 12 SDK向上の―

418
00:26:44,371 --> 00:26:48,308
数件の例にすぎず
改善は他にもあります

419
00:26:49,443 --> 00:26:53,814
次はエンコードとデコード
NSSecureCodingの話です

420
00:26:55,115 --> 00:27:00,654
iOS 12のAPIはデフォルトで
セキュアな状態です

421
00:26:55,115 --> 00:27:00,654
iOS 12のAPIはデフォルトで
セキュアな状態です

422
00:27:01,221 --> 00:27:05,626
エンコードに
NSSecureCodingを採用すると

423
00:27:05,726 --> 00:27:09,029
悪意あるデータと
破損したデータから―

424
00:27:09,129 --> 00:27:11,965
顧客を守ることにもなります

425
00:27:12,566 --> 00:27:16,170
安全でないAPIは
なくなりました

426
00:27:16,703 --> 00:27:20,040
その詳細を知りたい場合は

427
00:27:20,140 --> 00:27:23,377
木曜日のセッションに
ご参加ください

428
00:27:25,012 --> 00:27:26,447
以上です

429
00:27:27,114 --> 00:27:31,652
次に既存のAPIの
強化に注目しましょう

430
00:27:31,885 --> 00:27:33,754
まずは通知です

431
00:27:34,254 --> 00:27:37,991
通知機能は
大きく改善しています

432
00:27:38,091 --> 00:27:40,661
今朝の注目点は３つです

433
00:27:41,128 --> 00:27:43,730
カスタム通知内の相互作用

434
00:27:43,831 --> 00:27:45,566
通知のグルーピング

435
00:27:45,666 --> 00:27:49,336
そしてApp内の
通知設定へのアクセスです

436
00:27:50,137 --> 00:27:51,939
まずは相互作用です

437
00:27:53,240 --> 00:27:56,777
カスタム通知は
個人の定義が可能で

438
00:27:56,877 --> 00:28:00,848
事前定義された
設定も可能です

439
00:27:56,877 --> 00:28:00,848
事前定義された
設定も可能です

440
00:28:01,248 --> 00:28:05,018
さらにiOS 12では
動きが増えました

441
00:28:05,119 --> 00:28:09,990
プログラム定義はもちろん
実行中の変更も可能です

442
00:28:10,457 --> 00:28:13,727
これらの機能が
追加されたことで

443
00:28:13,827 --> 00:28:17,931
通知自体の
相互作用が可能になりました

444
00:28:18,098 --> 00:28:23,337
例えばメッセージには
すぐに返信が可能で

445
00:28:23,437 --> 00:28:26,306
通知画面で
直接入力ができます

446
00:28:28,108 --> 00:28:33,547
さらに通知のグルーピングが
可能になりました

447
00:28:33,647 --> 00:28:39,119
特定のAppの通知を
１グループにまとめます

448
00:28:39,219 --> 00:28:43,457
Appによって さらに細かい
グルーピングが必要かも

449
00:28:43,824 --> 00:28:48,829
例えばiMessageが
特定の会話をグループ化して

450
00:28:48,929 --> 00:28:52,566
他の通知と
分離するといった感じです

451
00:28:53,433 --> 00:28:55,469
通知にスレッド識別子の

452
00:28:55,569 --> 00:28:59,973
タグ付けをすればいいのです

453
00:29:00,073 --> 00:29:04,945
識別された通知は
１グループで表示されます

454
00:29:06,313 --> 00:29:10,250
iOS 12の通知における
UIの更新でも

455
00:29:10,350 --> 00:29:13,921
ユーザにとっての
新機能があります

456
00:29:14,021 --> 00:29:17,724
通知の配信動作の
カスタマイズ機能です

457
00:29:18,425 --> 00:29:22,729
しかしながら
各appには通知を管理し―

458
00:29:22,830 --> 00:29:26,166
制御する機能が
すでにあるのです

459
00:29:26,400 --> 00:29:28,402
iOS 12の新しいAPIでは

460
00:29:28,502 --> 00:29:34,308
顧客が通知設定のUIに
より詳細な制御を望めば―

461
00:29:34,408 --> 00:29:37,211
直接 関わることが可能です

462
00:29:38,278 --> 00:29:41,215
通知機能の詳細については

463
00:29:41,315 --> 00:29:45,986
週の後半のセッションに
ご参加ください

464
00:29:47,054 --> 00:29:48,455
以上が通知です

465
00:29:49,022 --> 00:29:51,191
次はメッセージ

466
00:29:52,559 --> 00:29:57,598
iOS 12のメッセージは
カメラに注目してください

467
00:29:58,131 --> 00:30:02,636
iMessageのステッカーが
カメラで使えます

468
00:29:58,131 --> 00:30:02,636
iMessageのステッカーが
カメラで使えます

469
00:30:02,903 --> 00:30:05,005
Xcodeを使っているなら

470
00:30:05,105 --> 00:30:09,510
自動的に機能して
追加作業は必要ありません

471
00:30:10,110 --> 00:30:13,847
さらにステッカーを
カスタムしたければ

472
00:30:13,947 --> 00:30:16,383
ビューコントローラを
使うことにより

473
00:30:16,750 --> 00:30:19,253
少しの処理で可能です

474
00:30:19,586 --> 00:30:23,724
新しいMSMessagesApp
PresentationContext APIは

475
00:30:23,824 --> 00:30:26,493
Info.plistに追加できます

476
00:30:26,593 --> 00:30:31,832
メッセージとメディアの
両方に表示が可能なのです

477
00:30:32,032 --> 00:30:35,335
この処理を経ると
appがApp Stripと

478
00:30:35,435 --> 00:30:38,539
カメラに表示されます

479
00:30:39,039 --> 00:30:42,476
実行中であれば
コンテキストを確認します

480
00:30:42,576 --> 00:30:46,346
ステッカーの表示を
カスタマイズしたい場合は

481
00:30:46,447 --> 00:30:48,382
新たなAPIがあります

482
00:30:50,284 --> 00:30:54,922
コンテキストの確認で
自分の居場所が分かります

483
00:30:56,223 --> 00:30:57,891
これらに加えて

484
00:30:57,991 --> 00:31:02,796
iOS 12はメッセージへの
新たなアクセスがあります

485
00:30:57,991 --> 00:31:02,796
iOS 12はメッセージへの
新たなアクセスがあります

486
00:31:02,896 --> 00:31:04,264
コンパクトモードでは

487
00:31:04,364 --> 00:31:08,435
以前は横にスワイプすると
Appを

488
00:31:08,535 --> 00:31:10,571
切り替えることができました

489
00:31:10,737 --> 00:31:12,072
iOS 12では

490
00:31:12,172 --> 00:31:17,978
水平スワイプと移動の
相互作用が可能になりました

491
00:31:18,078 --> 00:31:22,049
切り替えの必要が
なくなったのです

492
00:31:23,450 --> 00:31:24,451
以上です

493
00:31:25,085 --> 00:31:29,823
次はパスワードと
セキュリティーコードです

494
00:31:30,591 --> 00:31:34,661
自動パスワード機能は
iOS 11にもありました

495
00:31:36,163 --> 00:31:38,332
Appへの
パスワードエントリです

496
00:31:39,133 --> 00:31:42,503
iOS 12はさらに
進化をしています

497
00:31:43,771 --> 00:31:48,976
まずは少し全体的な
経験に戻るとしましょう

498
00:31:49,676 --> 00:31:53,814
パスワードをiCloudに
保存している場合

499
00:31:53,914 --> 00:31:59,720
iOS 11以降ログインフローで
自動的に入力されます

500
00:32:00,120 --> 00:32:05,058
iOS 12でもAppの
ログインフローから

501
00:32:05,159 --> 00:32:08,595
iCloudへのパスワードの
保存が可能です

502
00:32:08,695 --> 00:32:12,766
パスワード変更の
UIからも同様です

503
00:32:13,267 --> 00:32:17,704
ユーザログインをすると
即座に保存されます

504
00:32:18,472 --> 00:32:22,376
アカウント登録や
パスワード変更において

505
00:32:22,476 --> 00:32:26,713
iOS 12はパスワードの
自動生成も行います

506
00:32:26,813 --> 00:32:28,816
導入は簡単です

507
00:32:28,916 --> 00:32:34,354
ログイン時もしくは
新規や変更時に応じて

508
00:32:34,454 --> 00:32:38,192
パスワード入力欄に
パスワードのテキストタイプを

509
00:32:38,292 --> 00:32:41,128
タグ付けするだけです

510
00:32:43,497 --> 00:32:46,967
パスワードに関して
特定の要件がある場合

511
00:32:47,067 --> 00:32:50,504
例えば
不許可の文字がある場合や

512
00:32:50,604 --> 00:32:56,143
同じ文字の連続入力の
上限がある場合

513
00:32:56,343 --> 00:33:03,851
その要求を特定して
確認することができます

514
00:32:56,343 --> 00:33:03,851
その要求を特定して
確認することができます

515
00:33:05,052 --> 00:33:08,889
ログインの際に
手間がかかるのは

516
00:33:08,989 --> 00:33:14,828
２段階認証コードの通知を
Appへ取り込むことです

517
00:33:15,028 --> 00:33:20,334
iOS 12では
その通知を自動的に識別し

518
00:33:20,500 --> 00:33:22,603
セキュリティコードを
取り込み

519
00:33:23,036 --> 00:33:25,305
QuickTypeのバーで
表示します

520
00:33:25,405 --> 00:33:28,208
とても簡単に実行できます

521
00:33:28,509 --> 00:33:31,311
たった１つ
確認が必要なのは―

522
00:33:31,411 --> 00:33:35,782
iOS標準テキストを
使用しているかどうかです

523
00:33:35,883 --> 00:33:38,151
パスコード認証のためです

524
00:33:40,854 --> 00:33:45,826
iOS 12はより安全な
未来を可能にしています

525
00:33:46,293 --> 00:33:50,164
特殊で安全な
パスワードを使い

526
00:33:50,264 --> 00:33:52,933
暗記の必要もありません

527
00:33:54,001 --> 00:33:59,973
週後半のセッションで
さらに詳しく説明をします

528
00:34:01,575 --> 00:34:06,613
最後のトピックですが
少し復習になります

529
00:34:06,713 --> 00:34:08,882
コンテキストの話です

530
00:34:09,449 --> 00:34:12,585
iOS 11ではsafeAreaInsetsを
導入しました

531
00:34:12,686 --> 00:34:17,458
これはコンテンツを
確実にする優秀な機能で

532
00:34:17,558 --> 00:34:22,161
インターフェイスの
重なりを避けるものです

533
00:34:22,262 --> 00:34:24,998
例えば上下のバーです

534
00:34:25,899 --> 00:34:29,737
iPhoneのバーは
とても単純ですが

535
00:34:29,837 --> 00:34:32,406
パワフルな面もあります

536
00:34:32,505 --> 00:34:35,342
safeAreaInsetsは
アプリケーション内で

537
00:34:35,442 --> 00:34:39,446
ビューを正しい場所に
配置します

538
00:34:39,545 --> 00:34:42,815
どんなに複雑でも
機能するのです

539
00:34:43,083 --> 00:34:44,885
例えばiPadのSplit View

540
00:34:44,985 --> 00:34:50,424
マスター側とディテール側に
高さの異なるバーがあります

541
00:34:52,059 --> 00:34:56,295
どんなビューであっても
適切なサイズで

542
00:34:56,396 --> 00:34:59,666
適度に
重なりあっているのです

543
00:35:01,101 --> 00:35:04,571
横長のスクリーンは
美しいですね

544
00:35:04,905 --> 00:35:10,844
しかしiPhone Xにおいても
その能力は変わりません

545
00:35:11,645 --> 00:35:17,417
ボタンがない分だけ
大きなバーが上下にあります

546
00:35:17,718 --> 00:35:21,722
大きなサイズに
適用できているのです

547
00:35:21,922 --> 00:35:25,426
iPhone Xに限っては
バーがなくても

548
00:35:25,526 --> 00:35:28,028
safeAreaInsetsが
機能しており

549
00:35:28,695 --> 00:35:31,098
ランドスケープモードにも
対応します

550
00:35:31,331 --> 00:35:35,436
横長の領域は
必ず存在していて―

551
00:35:35,536 --> 00:35:38,338
なくなることはありません

552
00:35:40,974 --> 00:35:45,679
safeAreaInsetsの採用と
iPhone Xへの更新に対し

553
00:35:45,779 --> 00:35:47,948
お礼を申し上げます

554
00:35:48,649 --> 00:35:51,018
すばらしい経験でした

555
00:35:51,118 --> 00:35:56,457
未対応の方がいたら
是非 更新をお願いします

556
00:35:56,857 --> 00:36:00,661
顧客は常に
アップデートを求めます

557
00:35:56,857 --> 00:36:00,661
顧客は常に
アップデートを求めます

558
00:36:00,761 --> 00:36:04,998
iPhone Xへのサポートは
その指標です

559
00:36:05,098 --> 00:36:07,534
すぐの対応をお薦めします

560
00:36:07,668 --> 00:36:10,704
もし必要な情報があるなら

561
00:36:10,804 --> 00:36:15,309
UIKitのセッションに
参加してください

562
00:36:15,409 --> 00:36:21,815
safeAreaInsetsを含めた
UIKitのAPIについて話します

563
00:36:21,915 --> 00:36:26,320
すべての形とサイズに合った
Appが作成できます

564
00:36:27,988 --> 00:36:29,790
以上がフレームワークと

565
00:36:29,890 --> 00:36:31,925
APIの強化でした

566
00:36:32,025 --> 00:36:34,795
次はSiri Shortcutsです

567
00:36:34,895 --> 00:36:39,867
Siri ShortcutsはiOS 12で
新登場したAPIです

568
00:36:41,435 --> 00:36:45,406
Appから一般的な操作を
簡単に取得し―

569
00:36:45,506 --> 00:36:48,408
Siri経由でアクセスできます

570
00:36:49,543 --> 00:36:53,447
Siri Shortcutsは
初期画面にも表示でき

571
00:36:53,614 --> 00:36:59,253
希望のタイミングと場所で
簡単にアクセスできます

572
00:37:00,621 --> 00:37:05,426
Apple Watchには
Siriの文字盤です

573
00:37:06,693 --> 00:37:09,596
Siriのアクション
だけではなく

574
00:37:09,697 --> 00:37:14,167
カスタムボイスフレーズも
設定可能です

575
00:37:17,571 --> 00:37:21,208
このサポートは
簡単に追加できます

576
00:37:21,542 --> 00:37:23,143
使うのは２つのAPI

577
00:37:23,243 --> 00:37:27,548
１つはNSUserActivityで
ハンドオフや―

578
00:37:27,648 --> 00:37:30,250
Spotlightの統合に
使用します

579
00:37:30,350 --> 00:37:34,154
さらに複雑なシナリオを
サポートするために

580
00:37:34,254 --> 00:37:36,623
カスタムインタラクションが
あります

581
00:37:36,723 --> 00:37:39,026
まずNSUserActivityですが

582
00:37:39,359 --> 00:37:43,497
ハンドオフやSpotlightの
統合に使用します

583
00:37:43,597 --> 00:37:45,532
すばらしいAPIです

584
00:37:45,632 --> 00:37:50,237
特定のメッセージや
ドキュメントの読み込みなど

585
00:37:50,337 --> 00:37:53,740
顧客の特別な
要求に対応できます

586
00:37:53,841 --> 00:37:56,877
他のデバイスへの
受け渡しも同様です

587
00:37:57,144 --> 00:38:01,415
APIに対応済みの場合
追加はとても簡単です

588
00:37:57,144 --> 00:38:01,415
APIに対応済みの場合
追加はとても簡単です

589
00:38:01,515 --> 00:38:04,017
適切な予測を
“true”にするだけ

590
00:38:04,117 --> 00:38:08,889
未対応の場合は
ぜひ試してみてください

591
00:38:09,790 --> 00:38:14,561
さらなる顧客のニーズが
存在するのであれば

592
00:38:14,661 --> 00:38:17,331
SiriKit Intents APIを
採用してください

593
00:38:17,865 --> 00:38:22,903
独自で導入可能な
計画が提供されています

594
00:38:23,003 --> 00:38:26,273
前年のSiriKit Intentsと
同じ機能です

595
00:38:26,540 --> 00:38:29,243
カスタム機能が必要ならば

596
00:38:29,343 --> 00:38:32,613
iOS 12で独自に定義できます

597
00:38:34,114 --> 00:38:37,784
カスタムインテントには
柔軟性があります

598
00:38:37,885 --> 00:38:41,588
これは来年のWWDCの
スライドで

599
00:38:42,422 --> 00:38:46,093
計画はかなり広範囲に
及んでいます

600
00:38:46,193 --> 00:38:48,562
使用したのは
Createカテゴリです

601
00:38:48,729 --> 00:38:51,632
より一般的な要求でいいなら

602
00:38:51,732 --> 00:38:56,603
単にDo Run Goといった
オプションも可能です

603
00:38:58,105 --> 00:39:03,544
顧客がショートカットを
作りやすいことも大切です

604
00:38:58,105 --> 00:39:03,544
顧客がショートカットを
作りやすいことも大切です

605
00:39:03,977 --> 00:39:09,717
音声ショートカットができる
APIを紹介します

606
00:39:09,883 --> 00:39:12,286
このボタンを押すと

607
00:39:12,386 --> 00:39:17,691
新しいショートカットを
作成することができます

608
00:39:17,891 --> 00:39:20,227
コーヒーの注文と同じように

609
00:39:20,327 --> 00:39:24,498
何度も繰り返す行動の場合は

610
00:39:24,598 --> 00:39:29,103
次回のためショートカットを
作成しておけるのは便利です

611
00:39:29,570 --> 00:39:35,609
別のショートカットAppと
組み合わせることもできます

612
00:39:35,876 --> 00:39:40,714
Siri Shortcutsの詳細や
Voice Siri Shortcutsの構築

613
00:39:40,814 --> 00:39:46,487
Siriの文字盤上の
Siri Shortcutsは今週後半に

614
00:39:47,554 --> 00:39:51,291
iOS 12について
たくさん話しましたが

615
00:39:51,391 --> 00:39:56,463
まだまだすばらしい
セッションを用意しています

616
00:39:56,830 --> 00:40:02,169
iOS用のApp開発が
初めての方もぜひご参加を

617
00:39:56,830 --> 00:40:02,169
iOS用のApp開発が
初めての方もぜひご参加を

618
00:40:02,269 --> 00:40:05,873
セッションの内容を
チェックしてください

619
00:40:06,440 --> 00:40:11,278
既に開発済みの方は
一層の向上を目指して

620
00:40:11,378 --> 00:40:15,682
ご覧のセッションに
ご参加ください

621
00:40:15,782 --> 00:40:19,286
ご清聴
ありがとうございました

622
00:40:19,386 --> 00:40:22,790
またラボでお会いしましょう

623
00:40:23,156 --> 00:40:24,024
ありがとう

624
00:40:24,124 --> 00:40:25,092
（拍手）