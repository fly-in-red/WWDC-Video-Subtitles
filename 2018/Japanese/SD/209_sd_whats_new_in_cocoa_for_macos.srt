
1
00:00:07,140 --> 00:00:16,116
(音楽)

2
00:00:21,788 --> 00:00:28,228
(拍手)

3
00:00:29,530 --> 00:00:31,765
どうも 私はアリです

4
00:00:31,865 --> 00:00:35,002
同僚のクリスとジェスと

5
00:00:35,102 --> 00:00:38,939
macOS Mojaveの
Cocoaの新機能を説明します

6
00:00:40,841 --> 00:00:44,745
AppKitの新機能の話を
昨日しましたが

7
00:00:44,845 --> 00:00:48,115
今日も様々な機能や―

8
00:00:48,215 --> 00:00:50,817
APIの改良点も紹介します

9
00:00:50,918 --> 00:00:55,856
ダークモードや
Layer Backing

10
00:00:55,956 --> 00:00:58,192
クイックアクションの
カスタムです

11
00:00:58,792 --> 00:01:03,630
では まずは
我らが誇るAPIの話です

12
00:00:58,792 --> 00:01:03,630
では まずは
我らが誇るAPIの話です

13
00:01:03,730 --> 00:01:09,036
我々は機能的で力強い
APIを目指してきました

14
00:01:09,703 --> 00:01:14,174
その思いの下で
Objective-CやSwiftの

15
00:01:14,274 --> 00:01:16,810
改善に努めてきました

16
00:01:16,910 --> 00:01:21,748
AppKitや
Foundationに限らず

17
00:01:21,849 --> 00:01:25,419
UIKitにも対応しています

18
00:01:26,720 --> 00:01:31,525
APIを Objective-Cに
完全にソース互換させ

19
00:01:31,625 --> 00:01:37,130
将来的にはSwiftでの利用も
目指しています

20
00:01:37,764 --> 00:01:41,201
APIの改良点を
見ていきましょう

21
00:01:43,170 --> 00:01:47,441
まずは文字列型の
アップデートです

22
00:01:48,208 --> 00:01:50,611
前回は列挙型を紹介しました

23
00:01:50,711 --> 00:01:54,081
関連する定数を
まとめる方法で

24
00:01:54,181 --> 00:01:57,751
APIの文字列型の扱いが
明確になります

25
00:01:58,785 --> 00:02:00,120
例えば１行目

26
00:01:58,785 --> 00:02:00,120
例えば１行目

27
00:02:00,220 --> 00:02:03,423
NS STRING ENUMと
宣言します

28
00:02:03,524 --> 00:02:08,628
これは 拡張性のない
フレームワークの

29
00:02:08,729 --> 00:02:12,332
値を指定するための
列挙型です

30
00:02:12,432 --> 00:02:15,903
次にNS EXTENSIBLE
STRING ENUMです

31
00:02:16,003 --> 00:02:21,842
これで列挙型を宣言し
ボックスの値が指定できます

32
00:02:21,942 --> 00:02:25,512
他のフレームワークでも
使えます

33
00:02:26,647 --> 00:02:30,017
改良点は２つで
１つ目はシンプルです

34
00:02:30,117 --> 00:02:36,056
今紹介した２つの文字列を
類似のものに置き換えました

35
00:02:36,156 --> 00:02:40,961
これは
ノーオペレーション命令で

36
00:02:41,061 --> 00:02:44,498
コードなどに
変化はありません

37
00:02:44,598 --> 00:02:46,633
次はNSImageNameです

38
00:02:46,767 --> 00:02:51,872
列挙型に代わる
最も重要な変化となります

39
00:02:51,972 --> 00:02:54,975
NS SWIFT BRIDGED
TYPEDEFと

40
00:02:55,075 --> 00:02:57,411
Typedefを宣言します

41
00:02:57,578 --> 00:03:00,247
Swiftなら こんな具合です

42
00:02:57,578 --> 00:03:00,247
Swiftなら こんな具合です

43
00:03:00,814 --> 00:03:04,618
Swift 4では構造体になり

44
00:03:04,718 --> 00:03:07,721
このように列挙型を
宣言します

45
00:03:07,821 --> 00:03:14,094
Swift 4.2では昔ながらの
Typealiasを使います

46
00:03:14,194 --> 00:03:15,262
シンプルですね

47
00:03:15,896 --> 00:03:17,931
なぜこれをするのか？

48
00:03:18,031 --> 00:03:20,267
コールサイトの例です

49
00:03:22,836 --> 00:03:28,275
Swift 4では文字列に
NSImageを使って

50
00:03:28,375 --> 00:03:29,743
名前を表示できます

51
00:03:29,843 --> 00:03:34,715
文字列を選び
NSImage.Nameを用い

52
00:03:34,815 --> 00:03:37,751
さらにNSImage namedと
します

53
00:03:37,851 --> 00:03:42,689
NSImage.Nameを
繰り返すのは面倒ですね

54
00:03:42,823 --> 00:03:46,093
次に Swift 4.2です

55
00:03:46,193 --> 00:03:48,495
NSImage.Nameは重複せず

56
00:03:48,595 --> 00:03:52,232
より合理的で
ムダが少ないですね

57
00:03:52,332 --> 00:03:57,171
こちらのTypedefの方が
普遍的な値です

58
00:03:57,638 --> 00:04:01,108
(拍手)

59
00:03:57,638 --> 00:04:01,108
(拍手)

60
00:04:01,208 --> 00:04:03,477
皆さんの意見を聞き―

61
00:04:04,511 --> 00:04:09,183
こちらが適していると
確信を得ました

62
00:04:09,283 --> 00:04:12,219
値とは
フレームワークに関わらず

63
00:04:12,319 --> 00:04:14,955
普遍的であるものです

64
00:04:15,055 --> 00:04:18,659
画像や色 自動保存の
名前も同様ですから

65
00:04:18,759 --> 00:04:21,028
普遍的な方が適しています

66
00:04:21,128 --> 00:04:27,167
この新機能があっても
API独自の宣言が使えます

67
00:04:27,267 --> 00:04:29,770
NSImageの宣言方法です

68
00:04:29,870 --> 00:04:33,941
NSImage.Nameの話が
先ほど出ましたが

69
00:04:34,041 --> 00:04:36,210
ここでもまた出てきます

70
00:04:36,410 --> 00:04:38,912
３種類のリストです

71
00:04:39,012 --> 00:04:44,017
これは実に多くの型で
用いられているのです

72
00:04:45,352 --> 00:04:50,724
まだまだあります
多くの型が変更になります

73
00:04:53,527 --> 00:04:56,196
次はプレフィックスです

74
00:04:56,296 --> 00:05:00,634
今まで サフィックスから
移行してきました

75
00:04:56,296 --> 00:05:00,634
今まで サフィックスから
移行してきました

76
00:05:00,734 --> 00:05:05,005
数年来 Objective-Cは
プレフィックスを用いています

77
00:05:05,105 --> 00:05:10,511
グループに名前をつけたり
見つけやすくなったり

78
00:05:10,611 --> 00:05:12,880
Swiftが容易になります

79
00:05:13,480 --> 00:05:15,148
例を見てみましょう

80
00:05:16,717 --> 00:05:19,686
macOS 10.13のSDKには

81
00:05:19,786 --> 00:05:21,688
NSLineJoinStyleと
出てきます

82
00:05:21,788 --> 00:05:24,057
macOS 10.14では
こうなります

83
00:05:24,158 --> 00:05:30,731
MiterLineJoinStyleが
LineJoinStyleMiterとなり

84
00:05:30,831 --> 00:05:35,235
Swiftのプレフィックスが
変化しました

85
00:05:35,335 --> 00:05:38,672
MiterLineJoinStyleが
Miterにです

86
00:05:38,772 --> 00:05:41,909
この型を
繰り返す必要がなくなり

87
00:05:42,009 --> 00:05:44,678
コールサイトも
簡潔になりました

88
00:05:44,778 --> 00:05:47,314
思わずニッコリですね

89
00:05:48,015 --> 00:05:49,283
(拍手)

90
00:05:49,383 --> 00:05:50,117
どうも

91
00:05:51,084 --> 00:05:56,156
そして 他の型でも
同様のことを行いました

92
00:05:56,256 --> 00:05:58,325
型のリストです

93
00:06:00,460 --> 00:06:02,796
次はプロトコルの話です

94
00:06:03,564 --> 00:06:06,567
かつては
NSObjectといった

95
00:06:06,667 --> 00:06:10,771
非形式のプロトコルを
使っていました

96
00:06:10,871 --> 00:06:14,675
以来 オプショナルな
機能を加え

97
00:06:14,775 --> 00:06:17,578
形式プロトコルに
移行してきました

98
00:06:17,678 --> 00:06:21,849
その例を１つ
お見せしましょう

99
00:06:23,183 --> 00:06:27,387
validateMenuItemで

100
00:06:27,487 --> 00:06:31,158
macOS 10.13の
非形式プロトコルの機能です

101
00:06:31,258 --> 00:06:35,496
形式プロトコルでは
NSMenuItemValidation

102
00:06:35,596 --> 00:06:40,767
Swiftの表示はNSObjectから
形式プロトコルに変わります

103
00:06:40,868 --> 00:06:45,906
Swift 4.2では
NSMenuItemValidationです

104
00:06:46,006 --> 00:06:51,745
このプロトコルに従った
オブジェクトと宣言されます

105
00:06:51,845 --> 00:06:55,649
他の多くのAPIで
同様のことを行いました

106
00:06:55,749 --> 00:06:59,853
AppKitに追加した
形式プロトコルのリストです

107
00:06:59,953 --> 00:07:02,523
色やフォントの
切り替えといった

108
00:06:59,953 --> 00:07:02,523
色やフォントの
切り替えといった

109
00:07:02,623 --> 00:07:07,661
NSEditorや
NSEditorRegistration

110
00:07:07,761 --> 00:07:10,631
形式プロトコルの一覧です

111
00:07:11,899 --> 00:07:15,035
次はインスタンス変数への
アクセスです

112
00:07:15,702 --> 00:07:19,106
現在 我々のAPIでは

113
00:07:19,206 --> 00:07:22,376
インスタンス変数は
ほぼプライベートです

114
00:07:22,476 --> 00:07:27,915
しかし 古いAppKitでは
宣言のされ方次第で

115
00:07:28,015 --> 00:07:33,520
インスタンス変数に
直接アクセスできるのです

116
00:07:33,620 --> 00:07:38,325
お気付きでなかった方は
試さないでください

117
00:07:38,425 --> 00:07:42,296
自分で書いたのではない
古いコードが

118
00:07:42,396 --> 00:07:44,565
インスタンス変数を
直接 使うのです

119
00:07:44,665 --> 00:07:49,203
今後は こういった現象に
もう少し注意して

120
00:07:49,303 --> 00:07:50,938
非推奨していきます

121
00:07:51,038 --> 00:07:55,108
直接インスタンス変数に
アクセスした際の警告です

122
00:07:55,209 --> 00:07:57,678
次回の更新で削除されます

123
00:07:57,778 --> 00:08:01,515
このような警告が出たら
修正してください

124
00:07:57,778 --> 00:08:01,515
このような警告が出たら
修正してください

125
00:08:02,282 --> 00:08:07,487
直接アクセスするより
修正はよっぽど簡単です

126
00:08:07,588 --> 00:08:12,159
ゲッターを呼ぶか
プロパティに行ってください

127
00:08:12,259 --> 00:08:18,098
理由があってのアクセスなら
我々に知らせてください

128
00:08:18,866 --> 00:08:22,102
非推奨の話が出たので
お話しします

129
00:08:23,337 --> 00:08:25,672
非推奨公式ソフトです

130
00:08:25,873 --> 00:08:30,744
多くのAPIが非推奨になり
代替が提案されています

131
00:08:30,878 --> 00:08:35,849
緊急でない場合は
手順を踏んで非推奨にします

132
00:08:35,948 --> 00:08:40,154
リリースノートを出すなど
非推奨の勧告をし

133
00:08:40,254 --> 00:08:42,623
その後 非推奨にします

134
00:08:42,722 --> 00:08:44,725
混乱を防ぐためです

135
00:08:44,825 --> 00:08:48,362
一方 公式に非推奨にする
方法があります

136
00:08:48,462 --> 00:08:50,030
例を見せましょう

137
00:08:50,697 --> 00:08:53,634
非推奨の記号があります

138
00:08:53,734 --> 00:08:57,004
NSBoxOldStyleは
非推奨され

139
00:08:57,104 --> 00:09:00,140
非推奨と明記されていますね

140
00:08:57,104 --> 00:09:00,140
非推奨と明記されていますね

141
00:09:00,240 --> 00:09:03,911
バージョンナンバーは
API TO BE DEPRECATED

142
00:09:04,745 --> 00:09:10,951
コンパイラに非推奨の警告を
出さないようにしています

143
00:09:11,051 --> 00:09:17,424
もし この記号をXcodeや
新しいコードで用いたら

144
00:09:17,524 --> 00:09:22,029
警告を受け
代替の記号が提示されます

145
00:09:22,129 --> 00:09:24,665
Swiftでも同様です

146
00:09:24,765 --> 00:09:29,503
バージョンナンバー100000に
注目してください

147
00:09:29,603 --> 00:09:33,507
これは遠い将来発売される
SDKではなく

148
00:09:33,607 --> 00:09:37,911
プレースホルダ番号で
この機能を示します

149
00:09:40,113 --> 00:09:43,150
公式の非推奨の他の例です

150
00:09:43,717 --> 00:09:45,986
これを見てください

151
00:09:46,086 --> 00:09:50,757
MiterLineJoinStyleは
LineJoinStyleMiterになり

152
00:09:50,858 --> 00:09:54,628
Objective-Cのソースコードは
互換性があります

153
00:09:54,728 --> 00:09:58,632
では 自分がリネームした
古い記号は？

154
00:09:58,732 --> 00:10:04,671
API TO BE DEPRECATEDが
古い記号には使われ

155
00:09:58,732 --> 00:10:04,671
API TO BE DEPRECATEDが
古い記号には使われ

156
00:10:04,771 --> 00:10:10,878
新たに使おうとすると
警告が出るようになります

157
00:10:10,978 --> 00:10:16,016
しかしObjective-Cの
ソースコードを乱さないため

158
00:10:16,116 --> 00:10:18,886
既存のものは残されます

159
00:10:21,355 --> 00:10:26,093
こういった対象になる記号が
多かったため

160
00:10:26,193 --> 00:10:29,763
多くのAPIが非推奨と
記されています

161
00:10:29,863 --> 00:10:34,268
多くはプレフィックスへの
移行のためで

162
00:10:34,368 --> 00:10:39,573
新機能への転換のため
非推奨にしたものもあります

163
00:10:39,673 --> 00:10:44,178
あとで話す ダークモードが
いい例です

164
00:10:45,946 --> 00:10:48,782
最後は
セキュアコーディングです

165
00:10:49,082 --> 00:10:50,984
OS X 10.8とiOS 6で

166
00:10:51,084 --> 00:10:56,256
セキュアコーディングを
復活させました

167
00:10:56,356 --> 00:10:58,826
これによりアーカイブの際

168
00:10:58,926 --> 00:11:02,663
クラスを特定するのに
役立ちます

169
00:10:58,926 --> 00:11:02,663
クラスを特定するのに
役立ちます

170
00:11:02,763 --> 00:11:07,501
エラーがあった場合は
アーカイブに入れられません

171
00:11:08,001 --> 00:11:11,772
我々の
セキュアコーディングは

172
00:11:12,172 --> 00:11:14,708
オプショナルな機能でした

173
00:11:14,808 --> 00:11:19,913
しかし新しいAPIでは
デフォルトにできます

174
00:11:20,013 --> 00:11:22,883
エラーリターンも得られます

175
00:11:22,983 --> 00:11:27,354
エラーリターンは
あった方がいいですね

176
00:11:27,454 --> 00:11:31,558
新APIはエラーリターンが
デフォルトです

177
00:11:32,659 --> 00:11:36,930
一番興味深い
APIをお見せしましょう

178
00:11:37,030 --> 00:11:39,833
NSKeyedUnarchiverです

179
00:11:39,933 --> 00:11:45,172
keyedUnarchiverを作り
エラーを返します

180
00:11:45,672 --> 00:11:49,143
他にも２つのメソッドが
適用されます

181
00:11:49,243 --> 00:11:51,578
unarchivedObject
(ofClasses fromと

182
00:11:51,678 --> 00:11:54,081
unarchivedObject
(ofClassfromです

183
00:11:54,181 --> 00:11:57,718
これらはオブジェクトを
安全に

184
00:11:57,818 --> 00:12:02,756
アンアーカイブし
問題時にエラーを返します

185
00:11:57,818 --> 00:12:02,756
アンアーカイブし
問題時にエラーを返します

186
00:12:02,856 --> 00:12:08,128
２つめのメソッドです
かなりゴテゴテですね

187
00:12:08,228 --> 00:12:14,001
これでSwiftがリターンの
タイプを識別できます

188
00:12:14,101 --> 00:12:16,637
Swiftの得意分野ですね

189
00:12:16,737 --> 00:12:20,941
注意してほしいのは
これらのすべてが

190
00:12:21,041 --> 00:12:24,011
macOS 10.13やiOS 11に
対応することです

191
00:12:24,111 --> 00:12:27,481
古いバージョンのSDKでも
利用可能です

192
00:12:28,782 --> 00:12:32,519
一覧のメソッドが
入れ替わります

193
00:12:33,086 --> 00:12:38,392
macOS 10.14やiOS 12では
これらは非推奨になります

194
00:12:38,492 --> 00:12:42,496
セキュアコーディングでは
ないため

195
00:12:42,596 --> 00:12:46,333
通常の手順を踏まず
非推奨にします

196
00:12:46,433 --> 00:12:50,404
セキュアコーディングを
推奨するためです

197
00:12:52,439 --> 00:12:55,876
次にValue Transformerに
ついて

198
00:12:55,976 --> 00:12:58,412
NSValueTransformerは

199
00:12:58,512 --> 00:13:01,849
自動的に値を変換する
クラスです

200
00:12:58,512 --> 00:13:01,849
自動的に値を変換する
クラスです

201
00:13:01,949 --> 00:13:07,521
unarchiveFromDataと
keyedUnarchivedFromDataで

202
00:13:07,621 --> 00:13:12,226
アーカイブをロックしたり
解除したりします

203
00:13:12,326 --> 00:13:15,662
思ったように
機能しなかったので

204
00:13:15,762 --> 00:13:19,633
非推奨し
新しいものに置き換えます

205
00:13:19,733 --> 00:13:23,103
安全にアンアーカイブする
FromDataTransformerName

206
00:13:23,203 --> 00:13:25,806
こちらを使ってください

207
00:13:27,407 --> 00:13:30,511
さらに
セキュアコーディングを

208
00:13:30,611 --> 00:13:33,447
多くのAppKitにも
適用していきます

209
00:13:33,547 --> 00:13:35,916
NSAppearanceは

210
00:13:36,016 --> 00:13:40,120
新しいですが
かなり利用されています

211
00:13:40,220 --> 00:13:44,825
ダークモードや
他のAppKitの機能にもです

212
00:13:44,925 --> 00:13:48,529
セキュアコーディングを
導入したAPIの

213
00:13:48,629 --> 00:13:50,330
リストになります

214
00:13:51,098 --> 00:13:52,799
最後にもう１つ

215
00:13:52,900 --> 00:13:57,838
木曜のセッション
“Data You Can Trust”で

216
00:13:57,938 --> 00:14:03,143
堅固で安全なコーディングや
アーカイブの話をします

217
00:13:57,938 --> 00:14:03,143
堅固で安全なコーディングや
アーカイブの話をします

218
00:14:03,243 --> 00:14:06,647
木曜の朝９時に
お待ちしています

219
00:14:07,881 --> 00:14:12,920
ここからはAppKitの
新機能の話に移ります

220
00:14:13,020 --> 00:14:15,689
クリスを呼びましょう

221
00:14:16,190 --> 00:14:21,261
(拍手)

222
00:14:21,395 --> 00:14:22,329
どうも

223
00:14:22,429 --> 00:14:26,066
ダークモードは
注目の新機能です

224
00:14:26,166 --> 00:14:29,803
もうご存知の人も
いると思いますが

225
00:14:29,903 --> 00:14:31,471
見てみましょう

226
00:14:31,839 --> 00:14:35,909
すばらしいアートワークの
システムですね

227
00:14:36,009 --> 00:14:38,946
インターフェイスの
見た目がよくなり

228
00:14:39,046 --> 00:14:41,048
コンテンツが引き立ちます

229
00:14:41,148 --> 00:14:44,251
さて
これを導入する方法です

230
00:14:45,452 --> 00:14:47,721
第一段階は簡単です

231
00:14:47,821 --> 00:14:52,226
macOS 10.14のSDKに
リンクします

232
00:14:52,326 --> 00:14:56,497
美しいアプリケーションを
作るのに 多くの場合は

233
00:14:56,597 --> 00:14:58,465
これだけでは不十分です

234
00:14:58,565 --> 00:15:04,404
次に色を設定した値の箇所を
アプリケーション内で探し

235
00:14:58,565 --> 00:15:04,404
次に色を設定した値の箇所を
アプリケーション内で探し

236
00:15:04,505 --> 00:15:08,008
アピアランス対応の
色に置き換えます

237
00:15:08,542 --> 00:15:13,714
AppKitは
ほとんどのUIに対応し

238
00:15:13,814 --> 00:15:19,253
現状のアピアランスに準じた
カラーシステムを提供します

239
00:15:19,353 --> 00:15:23,490
macOS 10.14のものも
加えましょう

240
00:15:24,625 --> 00:15:27,027
システムの設定をしなくても

241
00:15:27,127 --> 00:15:31,465
ドキュメントモデルの
見た目も映えます

242
00:15:31,565 --> 00:15:35,335
Asset Catalogから
色を選べます

243
00:15:35,769 --> 00:15:38,739
Xcodeの色編集機能に行き

244
00:15:38,839 --> 00:15:44,845
右のサイドバーを使って
見た目や色の設定ができます

245
00:15:44,945 --> 00:15:49,683
ここでモードの明暗によって
色を選択します

246
00:15:49,783 --> 00:15:52,653
フォールバックカラーも
あります

247
00:15:54,688 --> 00:15:55,989
色と同様

248
00:15:56,089 --> 00:15:59,693
テンプレート画像も
見ていきましょう

249
00:16:00,260 --> 00:16:03,464
テンプレート画像は
モードに関わらず

250
00:16:03,564 --> 00:16:06,333
明るい色になっています

251
00:16:06,433 --> 00:16:11,939
グレーや黒のアートワークの
アプリケーションは

252
00:16:12,039 --> 00:16:15,976
ダークモードでは
映えませんでした

253
00:16:16,076 --> 00:16:21,849
そこで テンプレートを作り
カタログに追加できます

254
00:16:22,583 --> 00:16:26,053
ダークモードでも
制限することなく

255
00:16:26,153 --> 00:16:30,724
ダークモードで映える画像を
特定できます

256
00:16:30,824 --> 00:16:36,063
このアプリケーションで
北米はダークモードで夜です

257
00:16:36,163 --> 00:16:39,066
他のモードでは北米は昼です

258
00:16:41,668 --> 00:16:44,238
ダークモードの特徴の１つは

259
00:16:44,338 --> 00:16:47,107
デスクトップの
写真の処理です

260
00:16:47,207 --> 00:16:48,976
例を見せましょう

261
00:16:49,376 --> 00:16:54,581
システム環境設定は
ダークグレーに見えますが

262
00:16:54,681 --> 00:16:56,517
実際はもっと複雑です

263
00:16:56,683 --> 00:17:03,290
背景の砂丘には 青や
光やダークグレーがあります

264
00:16:56,683 --> 00:17:03,290
背景の砂丘には 青や
光やダークグレーがあります

265
00:17:03,390 --> 00:17:06,560
この写真に
平均色の長方形を重ね

266
00:17:06,660 --> 00:17:09,663
ダークブルーで
塗りつぶします

267
00:17:10,130 --> 00:17:14,233
インターフェイスの背景は
ダークグレーにしました

268
00:17:14,334 --> 00:17:16,336
ダークブルーも残ります

269
00:17:16,435 --> 00:17:20,140
ウインドウの内容を戻しても
変わりません

270
00:17:20,240 --> 00:17:22,910
デスクトップで映えるのです

271
00:17:23,777 --> 00:17:27,848
違う写真ではどうなるか
お見せしましょう

272
00:17:27,948 --> 00:17:32,686
もっと明るい紫や緑の
デスクトップの色が

273
00:17:32,786 --> 00:17:35,289
ウインドウに影響します

274
00:17:35,389 --> 00:17:39,259
赤い花の写真にしたら
もっと分かります

275
00:17:39,359 --> 00:17:43,864
デスクトップの暖かい色が
ウインドウに反映され

276
00:17:43,964 --> 00:17:46,500
インターフェイス全体が
変わります

277
00:17:47,334 --> 00:17:50,671
みなさんは
疑問に思うでしょう

278
00:17:50,771 --> 00:17:54,441
ウインドウ位置や
平均色を特定し

279
00:17:54,541 --> 00:17:57,778
変更するのは
大変じゃないかとね

280
00:17:57,878 --> 00:18:03,450
心配しなくても大丈夫
AppKitがしてくれます

281
00:17:57,878 --> 00:18:03,450
心配しなくても大丈夫
AppKitがしてくれます

282
00:18:04,184 --> 00:18:09,189
すでにご存知の
これらのクラスを使います

283
00:18:09,289 --> 00:18:12,593
ウインドウや
スクロールビューなどは

284
00:18:12,693 --> 00:18:15,896
何も変えずに
ダークモードで使えます

285
00:18:15,996 --> 00:18:19,867
カスタマイズしたければ
それも可能です

286
00:18:20,734 --> 00:18:23,136
背景のカラープロパティです

287
00:18:23,237 --> 00:18:27,474
そして 私が
特に紹介したいのが

288
00:18:27,574 --> 00:18:31,278
ここに挙げた４種類の
NSColorです

289
00:18:31,378 --> 00:18:36,116
これらは デスクトップの
写真と調和し

290
00:18:36,216 --> 00:18:40,420
インターフェイスの
役割によって変化します

291
00:18:41,088 --> 00:18:45,726
もう１つ紹介したいのが
NSBoxです

292
00:18:45,826 --> 00:18:50,063
ボックスのカスタマイズに
塗りつぶし機能が使えます

293
00:18:50,164 --> 00:18:53,500
NSColorや
他のカラーも使えます

294
00:18:53,600 --> 00:18:58,539
NSBoxでボックスを
きれいな色で塗れるのです

295
00:18:58,639 --> 00:19:01,775
他のクラスでは難しいですね

296
00:18:58,639 --> 00:19:01,775
他のクラスでは難しいですね

297
00:19:02,776 --> 00:19:07,714
もっとこだわる人には
別のクラスを紹介します

298
00:19:07,814 --> 00:19:09,750
“NSVisualEffectView”です

299
00:19:09,850 --> 00:19:12,519
マテリアルの
プロパティがあり

300
00:19:12,619 --> 00:19:16,757
背景に合わせた視覚効果を
決定できます

301
00:19:16,857 --> 00:19:19,226
色のブレンドをするのです

302
00:19:19,326 --> 00:19:24,231
使用された例を
いくつか見せましょう

303
00:19:24,331 --> 00:19:27,267
macOS 10.14には
もっとあります

304
00:19:27,367 --> 00:19:33,173
どんなインターフェイスにも
合ったマテリアルがあります

305
00:19:33,273 --> 00:19:38,345
過去のOSではダークか
ライトか明記されていました

306
00:19:38,445 --> 00:19:43,217
新しいモードでは
見え方が違ってきます

307
00:19:45,419 --> 00:19:48,489
そこで
アクセントカラーの話です

308
00:19:48,589 --> 00:19:52,693
これらのUIは
目を引くものですが

309
00:19:52,793 --> 00:19:56,130
それは色や
様々な要素のおかげです

310
00:19:56,230 --> 00:19:59,132
macOS 10.14には

311
00:19:59,233 --> 00:20:02,503
アクセントカラーを
多数追加しました

312
00:19:59,233 --> 00:20:02,503
アクセントカラーを
多数追加しました

313
00:20:02,603 --> 00:20:04,471
すばらしいでしょう？

314
00:20:04,805 --> 00:20:08,976
自分で作るなら…
拍手を待ってます

315
00:20:09,209 --> 00:20:13,146
(拍手)

316
00:20:13,247 --> 00:20:14,681
どうも

317
00:20:14,781 --> 00:20:16,817
これらのUIを作る時は

318
00:20:16,917 --> 00:20:20,521
モチーフも自分で作って
色を加えます

319
00:20:20,621 --> 00:20:25,392
以前はNSColor.
currentControlTintを使って

320
00:20:25,492 --> 00:20:29,630
システムがアクアか
グラファイトか選択しました

321
00:20:29,730 --> 00:20:33,801
今はこれより
もっと多くの色があります

322
00:20:33,901 --> 00:20:37,037
macOS 10.14ではNSColorの

323
00:20:37,137 --> 00:20:40,707
controlAccentColorを
推奨します

324
00:20:41,341 --> 00:20:45,212
NSColorは
アクセントカラーだけでなく

325
00:20:45,312 --> 00:20:47,181
他の機能も満載です

326
00:20:47,281 --> 00:20:51,084
UIの作成時
一番気にかけるのが

327
00:20:51,185 --> 00:20:55,222
ユーザインタラクションで
色が反映されるかです

328
00:20:55,322 --> 00:20:59,159
そこでwithSystemEffectを
導入しました

329
00:20:59,259 --> 00:21:03,397
起動時と非起動時の
効果を設定します

330
00:20:59,259 --> 00:21:03,397
起動時と非起動時の
効果を設定します

331
00:21:03,497 --> 00:21:07,468
将来的にはベースカラーから
新しい色を作り

332
00:21:07,568 --> 00:21:12,739
アピアランスに
加えられるようにしたいです

333
00:21:12,839 --> 00:21:15,776
そうすれば色を変える際

334
00:21:15,876 --> 00:21:18,445
自分で式を作る必要は
ありません

335
00:21:18,545 --> 00:21:21,482
インタラクションごとの

336
00:21:21,582 --> 00:21:24,117
複雑なコードも
必要ありません

337
00:21:24,451 --> 00:21:26,320
便利なAPIになります

338
00:21:28,622 --> 00:21:30,257
さらに色の話です

339
00:21:30,357 --> 00:21:35,362
コンテンツの明清色と
呼んでいるものです

340
00:21:35,896 --> 00:21:41,068
このモックアップにあるのは
一見 テキストだけですが

341
00:21:41,201 --> 00:21:44,071
いくつかの要素があります

342
00:21:45,772 --> 00:21:49,276
これは ユーザが
クリックする箇所です

343
00:21:49,376 --> 00:21:54,414
一般的なボーダーは
使いたくありませんでした

344
00:21:54,515 --> 00:21:58,652
macOS 10.14ならボーダーのない
ボタンにできます

345
00:21:58,752 --> 00:22:03,023
画像表示で
クリックできると認識します

346
00:21:58,752 --> 00:22:03,023
画像表示で
クリックできると認識します

347
00:22:03,724 --> 00:22:05,993
簡単な操作です

348
00:22:06,093 --> 00:22:08,228
NSButtonと
NSImageViewの総称が

349
00:22:08,328 --> 00:22:10,631
Content Tint Colorです

350
00:22:10,731 --> 00:22:15,569
好きな色や
色調の変更も設定できます

351
00:22:15,669 --> 00:22:20,841
これをInterface Builderに
組み込めます

352
00:22:21,141 --> 00:22:23,377
画像表示の設定です

353
00:22:23,477 --> 00:22:26,380
色調の選択は
右のサイドバーです

354
00:22:28,248 --> 00:22:33,453
macOS 10.14の
アピアランスに関する

355
00:22:33,554 --> 00:22:37,758
さらなるセッションが WWDCの
アプリケーションにあります

356
00:22:37,858 --> 00:22:39,459
ぜひご覧ください

357
00:22:40,561 --> 00:22:42,696
次のトピックです

358
00:22:42,796 --> 00:22:46,333
CocoaはLayer Backingなしに
語れません

359
00:22:47,334 --> 00:22:48,869
まずは確認です

360
00:22:48,969 --> 00:22:52,906
macOS 10.14で新しいSDKに
リンクすると

361
00:22:53,006 --> 00:22:56,677
AppKitは従来の
バッキングストアを使いません

362
00:22:56,777 --> 00:23:01,748
Core Animationのレイヤを
使います

363
00:22:56,777 --> 00:23:01,748
Core Animationのレイヤを
使います

364
00:23:02,416 --> 00:23:06,320
iOSユーザなら
親しみのある機能ですが

365
00:23:06,420 --> 00:23:08,922
詳しく見ていきましょう

366
00:23:09,022 --> 00:23:12,392
UIKitでの
ビューの関連図です

367
00:23:12,493 --> 00:23:15,062
とてもシンプルですね

368
00:23:15,162 --> 00:23:17,297
各ビューにレイヤが１つ

369
00:23:17,397 --> 00:23:21,969
ビュー間の親子関係も
表されています

370
00:23:22,936 --> 00:23:25,239
AppKitでのレイヤ関連図は

371
00:23:25,339 --> 00:23:29,476
ビュー階層のプロセスで
決められます

372
00:23:29,843 --> 00:23:35,616
複数のビューに対し
１つのレイヤを選択できます

373
00:23:35,716 --> 00:23:41,054
するとシステムやGPUの
メモリ消費を減らし

374
00:23:41,155 --> 00:23:45,425
ウインドウサーバの
負荷も軽減できます

375
00:23:45,559 --> 00:23:47,461
強調しておきたいのは

376
00:23:47,561 --> 00:23:51,165
ビュー階層の設定に
基づくということです

377
00:23:51,265 --> 00:23:53,400
だから変化できるのです

378
00:23:53,500 --> 00:24:00,040
iOSのような親子関係に
縛られることもありません

379
00:23:53,500 --> 00:24:00,040
iOSのような親子関係に
縛られることもありません

380
00:24:03,243 --> 00:24:07,681
ここでのプログラムとしての
大きな変化は

381
00:24:07,781 --> 00:24:12,052
wantsLayerを
使わなくてもいいことです

382
00:24:12,152 --> 00:24:16,890
macOS 10.14を使えば
AppKitがしてくれます

383
00:24:19,493 --> 00:24:21,028
macOS 10.14を…

384
00:24:21,228 --> 00:24:25,499
(拍手)

385
00:24:25,599 --> 00:24:29,636
このプロパティを使う
推奨すらしません

386
00:24:29,736 --> 00:24:33,574
“true”にすれば
ビューのレイヤが決まります

387
00:24:33,674 --> 00:24:36,310
最適化しなくとも
複数のビューが

388
00:24:36,410 --> 00:24:38,846
１つのレイヤに表示されます

389
00:24:38,946 --> 00:24:42,049
古いOSでは
必要な手順ですが

390
00:24:42,149 --> 00:24:44,718
無視して
飛ばすこともできます

391
00:24:45,752 --> 00:24:51,225
次に CALayerを使う際の
他のパターンを紹介します

392
00:24:51,325 --> 00:24:56,997
簡単なのは CALayerを
上書きするか

393
00:24:57,097 --> 00:24:59,333
デリゲートメソッドを
実行します

394
00:24:59,433 --> 00:25:02,836
NSViewには
様々な機能があるので

395
00:24:59,433 --> 00:25:02,836
NSViewには
様々な機能があるので

396
00:25:02,936 --> 00:25:05,572
そちらを
使った方がいいでしょう

397
00:25:06,840 --> 00:25:08,509
NSViewを使う場合は

398
00:25:08,609 --> 00:25:13,146
ダイナミックカラーの反映も
管理してくれます

399
00:25:13,247 --> 00:25:15,682
バッキングストアの
解像度も管理します

400
00:25:15,782 --> 00:25:18,752
レイヤメソッドと同様に
簡単なので

401
00:25:18,852 --> 00:25:22,956
ビューレベルでの
描画の上書きをお勧めします

402
00:25:24,625 --> 00:25:29,296
CALayerを使って
レイヤプロパティを

403
00:25:29,396 --> 00:25:31,465
更新することもあります

404
00:25:31,565 --> 00:25:35,435
その方が効果的で
作業も早いからです

405
00:25:35,536 --> 00:25:40,240
NSViewを使って
レイヤに上書きすれば

406
00:25:40,340 --> 00:25:44,177
drawRectでも
同じ効果が得られます

407
00:25:45,045 --> 00:25:50,617
レイヤとNSView
両方の手法が使えるのです

408
00:25:50,717 --> 00:25:55,823
レイヤにビューが１つの場合
レイヤのメソッドを使い

409
00:25:55,923 --> 00:26:00,694
他のビューもある場合は
drawRectを用います

410
00:25:55,923 --> 00:26:00,694
他のビューもある場合は
drawRectを用います

411
00:26:00,794 --> 00:26:04,765
両方使用した方が
いいわけです

412
00:26:05,332 --> 00:26:10,404
CGやAppKitのAPIでも
表現しきれないなら

413
00:26:10,504 --> 00:26:15,342
wantsUpdateLayerを
上書きします

414
00:26:15,442 --> 00:26:20,414
それで“true”と返ってきたら
レイヤを明示にします

415
00:26:22,916 --> 00:26:27,788
AppKitとCore Animationの
別の便利な利用法です

416
00:26:27,888 --> 00:26:33,093
NSViewsの基本的な用語で
インターフェイスを設定します

417
00:26:33,260 --> 00:26:36,663
NSImageViewとNSBox
NSTextFieldです

418
00:26:36,763 --> 00:26:39,700
複雑なインターフェイスの
設定には最適で

419
00:26:39,800 --> 00:26:44,338
表示にどんな技術を使っても
正確に起動します

420
00:26:45,539 --> 00:26:48,141
Layer Backingの変更点です

421
00:26:48,242 --> 00:26:51,812
これはmacOS 10.14では
もう使えません

422
00:26:51,912 --> 00:26:54,448
NSViewのlockFocusと
unlockFocusを使う場合

423
00:26:54,548 --> 00:26:57,985
直接ウインドウに
アクセスする場合は

424
00:26:58,085 --> 00:27:02,689
NSViewをサブクラスにし
drawRectを実行します

425
00:26:58,085 --> 00:27:02,689
NSViewをサブクラスにし
drawRectを実行します

426
00:27:02,790 --> 00:27:06,727
どちらのメソッドも
細心の注意を払い

427
00:27:06,827 --> 00:27:08,796
トラブルを避けましょう

428
00:27:08,896 --> 00:27:12,032
これはObjective-C用で

429
00:27:12,132 --> 00:27:14,735
Swift関連で話すのは変です

430
00:27:14,835 --> 00:27:20,107
Swiftではこのコードを
見たことがありませんから

431
00:27:20,240 --> 00:27:25,078
試して私を驚かせようなんて
しないでください

432
00:27:27,581 --> 00:27:31,251
Layer Backingの
もう１つの変化です

433
00:27:31,351 --> 00:27:34,288
NSOpenGLのクラスで
OpenGLで表示し

434
00:27:34,388 --> 00:27:36,657
macOS 10.14にリンクします

435
00:27:36,757 --> 00:27:41,828
MacでのOpenGLの技法は
少し違います

436
00:27:41,929 --> 00:27:44,364
何点かあります

437
00:27:44,464 --> 00:27:48,235
しかし重要なのはmacOS 10.14の
プラットフォームで

438
00:27:48,335 --> 00:27:50,838
OpenGLは
非推奨だということです

439
00:27:50,938 --> 00:27:56,009
NSOpenGLより
MTKViewをお勧めします

440
00:27:56,143 --> 00:28:00,914
Metalのセッションが
今日予定されています

441
00:27:56,143 --> 00:28:00,914
Metalのセッションが
今日予定されています

442
00:28:03,317 --> 00:28:08,322
最後の改良点はフォントの
アンチエイリアスです

443
00:28:08,422 --> 00:28:10,524
比較してみましょう

444
00:28:10,624 --> 00:28:12,860
左がmacOS 10.13で

445
00:28:12,960 --> 00:28:14,795
右がmacOS 10.14です

446
00:28:14,895 --> 00:28:18,699
ウインドウのテキストは
基本的に同じです

447
00:28:18,799 --> 00:28:23,203
しかしスケール因子48倍まで
拡大すると

448
00:28:23,303 --> 00:28:28,709
macOS 10.13はカラーフリンジが
用いられています

449
00:28:29,409 --> 00:28:33,413
一方 macOS 10.14では
使用されていません

450
00:28:33,514 --> 00:28:37,751
どんな大きさのパネルで
拡大しても

451
00:28:37,851 --> 00:28:39,686
テキストがぼやけません

452
00:28:40,521 --> 00:28:43,290
他にもいろいろありますが

453
00:28:43,390 --> 00:28:46,793
その説明はジェスに
代わりましょう

454
00:28:48,028 --> 00:28:52,032
(拍手)

455
00:28:52,132 --> 00:28:55,335
みなさん どうも

456
00:28:55,435 --> 00:28:59,773
まず ユーザ通知の
フレームワークです

457
00:28:59,873 --> 00:29:05,846
iOSにあったものを
macOS Mojaveにも導入しました

458
00:28:59,873 --> 00:29:05,846
iOSにあったものを
macOS Mojaveにも導入しました

459
00:29:07,948 --> 00:29:11,018
ユーザ通知の
管理を容易にします

460
00:29:11,118 --> 00:29:15,489
iOSと同様にアプリケーションが
作動するのです

461
00:29:15,589 --> 00:29:18,692
使うのは
NSApplicationの

462
00:29:18,792 --> 00:29:20,994
registerFor
RemoteNotificationsか

463
00:29:21,094 --> 00:29:25,632
userNotificationCenterの
requestAuthorizationです

464
00:29:27,601 --> 00:29:32,706
同時に関連するAPIを
非推奨にしました

465
00:29:32,806 --> 00:29:37,211
NSApplicationの
remoteNotificationTypeや

466
00:29:37,311 --> 00:29:38,278
OptionSetです

467
00:29:38,378 --> 00:29:41,582
registerForRemote
Notificationsや

468
00:29:41,682 --> 00:29:45,119
enabledRemote
NotificationTypesもです

469
00:29:45,219 --> 00:29:48,255
NSUserNotificationも
非推奨にしました

470
00:29:49,056 --> 00:29:51,625
SDKを再設定する際は

471
00:29:51,725 --> 00:29:54,728
フレームワークを
更新してください

472
00:29:56,497 --> 00:29:59,733
次にNSToolbarの話です

473
00:30:00,334 --> 00:30:04,004
ツールバーの中央に
アイテムを入れる際

474
00:30:04,104 --> 00:30:07,508
両サイドに
スペースが必要でした

475
00:30:07,608 --> 00:30:09,910
これには欠点があり

476
00:30:10,010 --> 00:30:14,681
さらにアイテムを入れると
押し出されてしまいます

477
00:30:14,781 --> 00:30:19,219
しかし NSToolbarの
新しいプロパティでは

478
00:30:19,319 --> 00:30:22,990
中央にしたいアイテムを
特定できます

479
00:30:23,090 --> 00:30:25,292
そして そのアイテムは

480
00:30:25,392 --> 00:30:30,197
他のアイテムが入っても
押し出されません

481
00:30:31,198 --> 00:30:34,001
他の改良点も
お伝えしましょう

482
00:30:35,736 --> 00:30:39,573
Auto Layoutが
アイテムのサイズを測ります

483
00:30:39,673 --> 00:30:43,143
最小値 最大値が
未設定なのが条件です

484
00:30:44,745 --> 00:30:47,981
この機能はmacOS 10.14のみ
対応しています

485
00:30:48,081 --> 00:30:53,921
ボタンのサイズを変える際
サイズが自動で測られます

486
00:30:59,860 --> 00:31:01,562
Interface Builderで

487
00:30:59,860 --> 00:31:01,562
Interface Builderで

488
00:31:01,662 --> 00:31:04,331
centeredItemIdentifierも
できます

489
00:31:04,431 --> 00:31:07,601
これが
インスペクタペインです

490
00:31:07,701 --> 00:31:11,004
一番下に
新しいボタンがあります

491
00:31:11,104 --> 00:31:14,408
ここをクリックする
だけでよく

492
00:31:14,508 --> 00:31:17,144
APIに戻る必要がないのです

493
00:31:17,244 --> 00:31:21,748
インターフェイスの
ほぼすべての設定ができます

494
00:31:21,849 --> 00:31:27,521
Interface Builderの
すばらしい新サポートは

495
00:31:27,621 --> 00:31:30,524
編集のための
NSGridViewです

496
00:31:30,624 --> 00:31:33,961
グリッドビューは
数年前に開発されました

497
00:31:34,061 --> 00:31:37,931
ビューをグリッドで
表示します

498
00:31:38,031 --> 00:31:40,500
例をお見せしましょう

499
00:31:40,601 --> 00:31:46,006
このレイアウトを設定する
制約はとても少ないです

500
00:31:46,106 --> 00:31:51,178
しかしNSGridViewで
もっと簡単に作れます

501
00:31:51,278 --> 00:31:55,182
Interface Builderの
新サポートです

502
00:31:55,282 --> 00:32:00,087
これはStoryboardファイルの
インターフェイスです

503
00:31:55,282 --> 00:32:00,087
これはStoryboardファイルの
インターフェイスです

504
00:32:00,187 --> 00:32:03,557
コントロールを選択し
グリッドビューを適用します

505
00:32:03,657 --> 00:32:08,295
そして 余白や
セルのそろえを調整し

506
00:32:08,395 --> 00:32:11,031
レイアウトしていきます

507
00:32:11,765 --> 00:32:17,504
表計算のように
セルにビューを入れられます

508
00:32:17,604 --> 00:32:22,209
列と行からセルを選び
プロパティを調整します

509
00:32:22,309 --> 00:32:25,879
下の２行のように
セルの結合もできます

510
00:32:26,480 --> 00:32:29,583
試しに列を選びましょう

511
00:32:29,683 --> 00:32:32,686
インスペクタペインは
このようになります

512
00:32:32,786 --> 00:32:38,158
この行のセルの位置と
上と下の余白を調整します

513
00:32:38,258 --> 00:32:42,763
サイズインスペクタで
行の幅を明示しなければ

514
00:32:42,863 --> 00:32:47,468
行のサイズは内容によって
自動的に決まります

515
00:32:48,936 --> 00:32:54,208
この機能のいい点は
過去のOSでも使える点です

516
00:32:54,308 --> 00:32:56,810
Interface Builderの
グリッドビューは

517
00:32:56,910 --> 00:33:00,881
macOS 10.13.4に戻しても
使えます

518
00:32:56,910 --> 00:33:00,881
macOS 10.13.4に戻しても
使えます

519
00:33:00,981 --> 00:33:05,385
セルの結合以外は
macOS 10.12でも使えます

520
00:33:05,485 --> 00:33:09,523
古いバージョンで
アプリケーションを設計する時も

521
00:33:09,623 --> 00:33:13,293
このすばらしい新機能が
使えるのです

522
00:33:15,062 --> 00:33:19,266
次はNSTextViewの改良点です

523
00:33:20,067 --> 00:33:22,569
新ファクトリメソッドは
数点です

524
00:33:22,669 --> 00:33:26,840
fieldEditorが
NSTextFieldと同様に

525
00:33:26,940 --> 00:33:29,776
テキストビューの
編集をします

526
00:33:29,877 --> 00:33:35,716
これによりテキストビューの
設定を簡単にします

527
00:33:36,150 --> 00:33:40,754
下の３つは
スクロールビューで

528
00:33:40,854 --> 00:33:43,724
一般的な使用ケースです

529
00:33:43,824 --> 00:33:46,226
さらに編集を加えたければ

530
00:33:46,326 --> 00:33:51,231
ドキュメントビューを
見てください

531
00:33:51,331 --> 00:33:53,333
Interface Builderでも
これらは可能で

532
00:33:53,433 --> 00:33:57,070
APIに戻る必要がありません

533
00:33:57,171 --> 00:34:02,042
４つすべてを示した
サンプルウインドウです

534
00:33:57,171 --> 00:34:02,042
４つすべてを示した
サンプルウインドウです

535
00:34:02,142 --> 00:34:07,214
テキストビューの
ミスコンフィグレーションは

536
00:34:07,314 --> 00:34:11,217
FieldEditorの
ファクトリメソッドで防げます

537
00:34:11,719 --> 00:34:15,621
scrollableTextViewは
テキストビューに使われます

538
00:34:15,722 --> 00:34:20,661
ポップオーバーなどの
補足テキストのためです

539
00:34:20,761 --> 00:34:24,264
下の２つはメイン文書の
テキストです

540
00:34:24,364 --> 00:34:28,502
左はリッチテキスト
右はプレーンテキストです

541
00:34:28,735 --> 00:34:33,407
何が違うのかと
疑問に思うでしょうね

542
00:34:33,507 --> 00:34:37,210
一番は システム設定の
心配が要りません

543
00:34:37,311 --> 00:34:41,782
ダークモードの方が
もっと分かりやすいですね

544
00:34:42,416 --> 00:34:45,719
リッチテキストの背景は
白のままですが

545
00:34:45,819 --> 00:34:49,857
プレーンテキストは黒になり
システムにマッチします

546
00:34:49,956 --> 00:34:52,025
このファクトリメソッドで

547
00:34:52,125 --> 00:34:56,496
システムの他の仕様と
一貫性が出ます

548
00:34:58,599 --> 00:35:04,004
他の改良点としては
テキストの変更メソッドの

549
00:34:58,599 --> 00:35:04,004
他の改良点としては
テキストの変更メソッドの

550
00:35:04,104 --> 00:35:06,073
PerformValidated
Replacementです

551
00:35:06,173 --> 00:35:12,012
テキストビューでの
テキストの扱いが簡単になり

552
00:35:12,112 --> 00:35:16,383
ユーザ自身で変更した際の
対応もします

553
00:35:16,783 --> 00:35:20,487
デリゲートメソッドも
実行してくれます

554
00:35:20,587 --> 00:35:25,959
何よりも 入力文字列が
特定されていない属性は

555
00:35:26,059 --> 00:35:30,030
typingAttributesで
自動的に属性を持たせます

556
00:35:30,330 --> 00:35:32,332
例をお見せしましょう

557
00:35:32,432 --> 00:35:34,301
リッチテキストの
ウインドウです

558
00:35:34,401 --> 00:35:38,005
スニペット“performValidated
Replacement”に

559
00:35:38,105 --> 00:35:40,574
“Developers”と入れます

560
00:35:41,175 --> 00:35:44,445
そうすると文字になって
現れます

561
00:35:44,545 --> 00:35:49,983
周囲のスタイルと合っていて
属性の指定は不要です

562
00:35:50,551 --> 00:35:52,986
ここで少し注意が必要です

563
00:35:53,086 --> 00:35:57,191
属性の指定は
typingAttributesが行います

564
00:35:57,291 --> 00:36:01,628
それなので
リッチテキストから始め

565
00:35:57,291 --> 00:36:01,628
それなので
リッチテキストから始め

566
00:36:01,729 --> 00:36:05,933
最後を薄い字にして
真ん中に挿入すると

567
00:36:06,033 --> 00:36:11,305
スタイルの属性は最後の
薄い字になります

568
00:36:12,339 --> 00:36:16,310
そのためperformValidated
Replacementを呼ぶ前に

569
00:36:16,410 --> 00:36:20,480
範囲を選択するか
見極めないといけません

570
00:36:22,783 --> 00:36:25,619
選択すると こうなります

571
00:36:27,187 --> 00:36:31,658
次にContinuity Cameraの
説明を簡単に

572
00:36:31,759 --> 00:36:35,996
macOS Mojaveの
特徴の１つです

573
00:36:36,096 --> 00:36:39,533
NSTextViewを使っているなら

574
00:36:39,633 --> 00:36:44,838
フレームワークが
自動で起動してくれます

575
00:36:44,938 --> 00:36:48,408
しかし もっと特化した
利用がしたければ

576
00:36:48,509 --> 00:36:51,178
直接使うこともできます

577
00:36:51,278 --> 00:36:56,450
これは既存のAPIサービスの
実装になります

578
00:36:56,550 --> 00:37:01,822
応用クラスが画像を
処理できるようにするのです

579
00:36:56,550 --> 00:37:01,822
応用クラスが画像を
処理できるようにするのです

580
00:37:01,922 --> 00:37:04,958
validRequestorで
可能です

581
00:37:05,058 --> 00:37:09,596
validRequestorや
関連のメソッドの説明に

582
00:37:09,697 --> 00:37:11,732
目を通しておきましょう

583
00:37:13,600 --> 00:37:16,270
次はクイックアクションの
カスタムです

584
00:37:16,370 --> 00:37:21,909
クイックアクションについては
昨日も紹介されました

585
00:37:22,009 --> 00:37:27,648
アプリケーションを
開くといった簡単な動作から

586
00:37:27,748 --> 00:37:33,620
複雑な動作では ファイルに
フィルタをかけたりできます

587
00:37:33,720 --> 00:37:36,123
クイックアクションの
カスタムは

588
00:37:36,223 --> 00:37:40,761
App Extensionや
Automatorを使ってできます

589
00:37:41,028 --> 00:37:45,232
様々な場所で使え
起動の仕方も様々ですが

590
00:37:45,332 --> 00:37:48,168
一押しはTouch Barです

591
00:37:48,268 --> 00:37:52,339
Touch Barに
クイックアクションを加えれば

592
00:37:52,439 --> 00:37:54,475
いつでも簡単に使えます

593
00:37:54,575 --> 00:37:57,978
システム環境設定の
“キーボード”に行き

594
00:37:58,078 --> 00:38:04,084
Touch Barの表示のさせ方を
設定します

595
00:37:58,078 --> 00:38:04,084
Touch Barの表示のさせ方を
設定します

596
00:38:04,318 --> 00:38:09,623
カスタムしたいなら
一番下にボタンがあります

597
00:38:11,491 --> 00:38:16,296
また ショートカットの
サービスを見ると

598
00:38:16,396 --> 00:38:21,001
何を表示させるかを
選択することができます

599
00:38:21,101 --> 00:38:23,570
Touch Barに
表示されないのは

600
00:38:23,670 --> 00:38:25,706
例えばFinderウインドウです

601
00:38:25,806 --> 00:38:29,877
コンテキストメニューに
クイックアクションがあります

602
00:38:31,345 --> 00:38:34,815
プレビューにも
クイックアクションがあり

603
00:38:34,915 --> 00:38:38,185
“More”を押すと
リストが出てきます

604
00:38:38,285 --> 00:38:42,122
Automatorのアクションは
サービスで見られます

605
00:38:42,222 --> 00:38:46,360
TrimLogsはデバッグログを
検索するものです

606
00:38:47,394 --> 00:38:51,732
次にアクションのまとめ方を
説明します

607
00:38:51,832 --> 00:38:56,336
これはAutomatorの
新機能です

608
00:38:56,437 --> 00:39:01,475
新規ドキュメントを作ると
オプションが出てきます

609
00:38:56,437 --> 00:39:01,475
新規ドキュメントを作ると
オプションが出てきます

610
00:39:01,575 --> 00:39:05,579
一般的なワークフローですが
１番上のボタンで

611
00:39:05,679 --> 00:39:10,684
インプットやアウトプット
アイコンの色も設定できます

612
00:39:11,351 --> 00:39:13,854
簡単な例をお見せします

613
00:39:13,954 --> 00:39:17,424
テキストエディットで
ファイルを開きたくても

614
00:39:17,524 --> 00:39:20,427
拡張子のため
開けないことがあります

615
00:39:20,527 --> 00:39:24,097
Automatorなら
簡単に解決です

616
00:39:24,565 --> 00:39:29,903
ライブラリに行き
Finderアイテムを開くを選び

617
00:39:30,003 --> 00:39:35,208
テキストエディットで開くと
設定すればいいのです

618
00:39:35,542 --> 00:39:40,080
これはFinder内の
全ファイルに適用されます

619
00:39:40,180 --> 00:39:43,350
名前を付けて保存すれば

620
00:39:43,450 --> 00:39:48,322
Touch Barや他のメニューにも
表示されます

621
00:39:50,490 --> 00:39:56,130
さて 様々な新機能や
改良点を説明してきました

622
00:39:56,230 --> 00:39:58,832
皆さんのエクスペリエンスや

623
00:39:58,932 --> 00:40:02,002
アプリケーションを
向上させるものです

624
00:39:58,932 --> 00:40:02,002
アプリケーションを
向上させるものです

625
00:40:02,703 --> 00:40:09,376
新SDKのリストをチェックし
アプリケーションに使ってください

626
00:40:10,077 --> 00:40:14,214
よりよいアプリケーションになり
ユーザも喜ぶでしょう

627
00:40:14,948 --> 00:40:17,784
さらなる詳細はこのURLで

628
00:40:18,352 --> 00:40:21,955
WWDCのアプリケーションも
見てみてください

629
00:40:22,055 --> 00:40:24,792
関連する
セッションもあります

630
00:40:24,925 --> 00:40:26,093
ありがとうございました

631
00:40:26,326 --> 00:40:31,899
(拍手)