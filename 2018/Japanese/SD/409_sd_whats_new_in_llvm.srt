
1
00:00:07,107 --> 00:00:15,849
(音楽)

2
00:00:20,487 --> 00:00:27,327
(拍手)

3
00:00:27,427 --> 00:00:30,764
LLVMのセッションへようこそ

4
00:00:31,298 --> 00:00:33,834
ジム･グロスバッチです

5
00:00:33,934 --> 00:00:38,739
LLVMプロジェクトについて
少し触れたあと

6
00:00:38,839 --> 00:00:44,578
驚きの新機能について
技術面を詳しく紹介します

7
00:00:45,345 --> 00:00:49,950
LLVMは単なる
コンパイラではありません

8
00:00:50,217 --> 00:00:56,323
C系言語に対応する
Clangコンパイラの基盤でもあり

9
00:00:56,423 --> 00:01:02,229
スタティックアナライザ
Sanitizer LLDBデバッガを作動

10
00:00:56,423 --> 00:01:02,229
スタティックアナライザ
Sanitizer LLDBデバッガを作動

11
00:01:02,329 --> 00:01:07,801
また弊社の製品に適応する
GPUシェーダコンパイラを通じ

12
00:01:07,901 --> 00:01:11,438
最適コードを生成します

13
00:01:11,939 --> 00:01:14,408
そして皆さんも時々耳にする―

14
00:01:14,608 --> 00:01:19,880
Swiftというプロジェクトの
基盤も成しています

15
00:01:20,981 --> 00:01:25,219
Swift同様 LLVMは
オープンソースプロジェクトです

16
00:01:26,386 --> 00:01:30,724
このロゴのワイバーンが
私たちの監視役です

17
00:01:30,824 --> 00:01:35,829
ドラゴンと呼ぶと
機嫌を損ねてしまいますので

18
00:01:35,929 --> 00:01:38,498
注意してくださいね

19
00:01:39,466 --> 00:01:43,637
オープンソースのLLVMは
共同運営です

20
00:01:44,137 --> 00:01:49,409
私たちのパートナーも
多様性に富んでいます

21
00:01:49,510 --> 00:01:53,514
企業 学術関係者
研究員 趣味で扱う人

22
00:01:53,680 --> 00:01:56,517
誰でも自由に参加できます

23
00:01:56,617 --> 00:02:00,621
協力しながら
最高のツールを作ることで

24
00:01:56,617 --> 00:02:00,621
協力しながら
最高のツールを作ることで

25
00:02:00,721 --> 00:02:04,124
技術を前進させられるでしょう

26
00:02:04,791 --> 00:02:09,630
自分もコンパイラの改良に
協力したいと思う方は

27
00:02:09,729 --> 00:02:13,066
プロジェクトに参加してください

28
00:02:13,267 --> 00:02:16,436
詳細は
LLVMのウェブサイトか―

29
00:02:16,670 --> 00:02:20,974
セッション後にLLVMのラボに
お越しください

30
00:02:21,074 --> 00:02:25,412
弊社のコンパイラエンジニアたちが

31
00:02:25,512 --> 00:02:30,250
どんな質問に対しても
詳しく説明します

32
00:02:30,350 --> 00:02:32,119
何でも聞いてください

33
00:02:32,953 --> 00:02:37,491
それでは こちらが
今日ご紹介する内容です

34
00:02:37,591 --> 00:02:39,726
ARCのアップデートにより

35
00:02:39,826 --> 00:02:44,631
コンパイラのメモリ管理が
簡易化されました

36
00:02:44,731 --> 00:02:50,003
Xcode 10の新しい検出機能や
スタティックアナライザは

37
00:02:50,103 --> 00:02:54,141
ビルド時間の早い段階でバグを検出

38
00:02:54,241 --> 00:02:56,610
コードの質を向上させます

39
00:02:56,710 --> 00:03:02,115
またプラットフォームや
アプリケーションの安全性も向上

40
00:02:56,710 --> 00:03:02,115
またプラットフォームや
アプリケーションの安全性も向上

41
00:03:02,216 --> 00:03:05,352
さらに
ハードウェアアーキテクチャの

42
00:03:05,452 --> 00:03:09,389
新機能を活用する方法も
お伝えします

43
00:03:09,623 --> 00:03:14,261
誰もが望んだパフォーマンスを
得られます

44
00:03:14,695 --> 00:03:19,533
ではARCについて
アレックスが説明します

45
00:03:20,400 --> 00:03:21,068
アレックス

46
00:03:21,168 --> 00:03:27,074
(拍手)

47
00:03:27,908 --> 00:03:29,009
ありがとう　ジム

48
00:03:29,643 --> 00:03:34,748
ARCが導入されて以来
Objective-Cプログラムは

49
00:03:34,848 --> 00:03:37,518
かなり簡素化されています

50
00:03:37,985 --> 00:03:41,221
しかし いくつかの規制が

51
00:03:41,321 --> 00:03:45,225
ARCへの移行の
妨げとなっていました

52
00:03:45,492 --> 00:03:48,662
今回 その規制の１つが解消

53
00:03:49,029 --> 00:03:53,267
Xcode 10では
ARCオブジェクトポインタが

54
00:03:53,367 --> 00:03:55,002
C構造体に対応

55
00:03:55,302 --> 00:04:00,440
(拍手)

56
00:03:55,302 --> 00:04:00,440
(拍手)

57
00:04:00,541 --> 00:04:04,845
料理を注文する
アプリケーションを例とし

58
00:04:05,312 --> 00:04:09,383
メニューの構造体を作ってみます

59
00:04:10,684 --> 00:04:12,786
Xcode 9以前の旧版では

60
00:04:12,886 --> 00:04:18,858
通常 ARCオブジェクトポインタを
Cの構造体で使えません

61
00:04:18,959 --> 00:04:23,096
Objective-Cクラスの
作成が必須でした

62
00:04:24,231 --> 00:04:28,001
しかし Xcode 10では
そのまま―

63
00:04:28,101 --> 00:04:30,904
Cの構造体が作成できます

64
00:04:34,474 --> 00:04:37,845
アプリケーションを作っていきます

65
00:04:38,045 --> 00:04:41,481
まず無料で注文できる関数を用意

66
00:04:41,582 --> 00:04:47,287
メニューの変数アイテムは
価格を０にしておきます

67
00:04:48,388 --> 00:04:53,694
そして注文用の別の関数に
アイテムを移行します

68
00:04:54,761 --> 00:04:59,900
アイテムができると
コンパイラはretainを合成

69
00:05:00,000 --> 00:05:04,204
ARCオブジェクトポインタを
アイテム内で保持します

70
00:05:05,105 --> 00:05:10,744
このコメントは
コンパイラが合成するコードです

71
00:05:11,111 --> 00:05:15,048
このコードにより
アイテムが使われる前に

72
00:05:15,148 --> 00:05:19,086
料理名と価格は解放されません

73
00:05:21,288 --> 00:05:25,025
ここでアイテムがスコープ外となり

74
00:05:25,259 --> 00:05:27,294
スタックから外れます

75
00:05:27,394 --> 00:05:30,731
そこでコンパイラが
releaseを合成し

76
00:05:30,831 --> 00:05:34,868
ARCオブジェクトポインタを
解放します

77
00:05:35,602 --> 00:05:40,874
これでアイテムの解放時
料理名と価格はリークしません

78
00:05:42,876 --> 00:05:47,481
今まで Objective-Cの
オブジェクトポインタを

79
00:05:47,581 --> 00:05:50,517
MRRで管理していました

80
00:05:50,984 --> 00:05:54,755
コードの記述が手間だったのですが

81
00:05:55,122 --> 00:05:59,326
ARCならコンパイラが
助けてくれます

82
00:05:59,426 --> 00:06:03,030
自動でretainやreleaseを補います

83
00:05:59,426 --> 00:06:03,030
自動でretainやreleaseを補います

84
00:06:03,597 --> 00:06:06,600
とても使いやすいコンパイラで

85
00:06:06,900 --> 00:06:11,238
スタック上の変数のメモリを
適切に管理します

86
00:06:11,772 --> 00:06:14,775
また別の構造体の領域や

87
00:06:14,875 --> 00:06:18,879
Object-Cクラスの
インスタンス変数にも対応します

88
00:06:19,646 --> 00:06:23,684
しかしARCオブジェクトポインタを
適用するには

89
00:06:23,784 --> 00:06:26,920
多少 操作する場所があります

90
00:06:27,788 --> 00:06:29,790
それはヒープです

91
00:06:30,557 --> 00:06:32,025
構造体に戻ります

92
00:06:32,125 --> 00:06:36,430
ヒープにメニューアイテムを
割り当てます

93
00:06:36,763 --> 00:06:42,269
Objective-Cを適用するなら
NSArrayを使いますが

94
00:06:42,503 --> 00:06:45,639
今回はmallocとfreeを使います

95
00:06:46,139 --> 00:06:49,343
このコードの問題点は２つ

96
00:06:49,977 --> 00:06:54,748
１つ目はメモリの割り当て時
０に初期化されず

97
00:06:55,082 --> 00:06:58,385
ポインタが無効化されます

98
00:06:58,619 --> 00:07:03,590
そのためプログラム実行時
予想外の動作をします

99
00:06:58,619 --> 00:07:03,590
そのためプログラム実行時
予想外の動作をします

100
00:07:05,225 --> 00:07:07,361
２つ目はメモリ解放の前に

101
00:07:07,461 --> 00:07:12,299
ARCオブジェクトポインタが
クリアされません

102
00:07:12,533 --> 00:07:17,304
そのためプログラム実行時
メモリリークが起きます

103
00:07:19,139 --> 00:07:21,642
１つ目の問題を修正します

104
00:07:21,742 --> 00:07:25,245
mallocをcallocに置き換えます

105
00:07:25,746 --> 00:07:29,583
これでメモリは０に初期化され

106
00:07:30,050 --> 00:07:34,688
実行時の厄介な問題は
すべて解消されます

107
00:07:35,756 --> 00:07:42,062
２つ目はメモリに割り当てる前に
ループを書くことで

108
00:07:42,162 --> 00:07:45,599
ARCオブジェクトポインタを
クリアできます

109
00:07:46,266 --> 00:07:49,837
これでアイテムの名前と価格は

110
00:07:49,937 --> 00:07:52,606
解放時にリークしません

111
00:07:56,009 --> 00:07:58,712
ARCは非常に便利です

112
00:07:59,046 --> 00:08:01,315
このような機能がないため

113
00:07:59,046 --> 00:08:01,315
このような機能がないため

114
00:08:01,415 --> 00:08:06,987
ARCへの移行を
敬遠していた人もいるでしょう

115
00:08:07,087 --> 00:08:10,524
Xcode 10のサポート機能を受けて

116
00:08:10,891 --> 00:08:13,160
ARCを試してみてください

117
00:08:13,994 --> 00:08:19,733
では Objective-Cのポインタや
構造体を取り上げます

118
00:08:19,833 --> 00:08:23,504
Xcode 10で
異なる言語モードにおける―

119
00:08:23,604 --> 00:08:26,740
構造体の作成に注目します

120
00:08:27,808 --> 00:08:30,944
Xcode 10は異なる言語モードで

121
00:08:31,044 --> 00:08:36,383
Objective-Cのオブジェクト
ポインタを適用できます

122
00:08:36,482 --> 00:08:44,024
CやObjective-C Objective-C++でも
同じ構造体が使用できます

123
00:08:44,758 --> 00:08:49,463
ARCやMRRで
コードをコンパイルする時も

124
00:08:49,563 --> 00:08:52,900
適切に機能させることができます

125
00:08:54,067 --> 00:08:59,039
Xcode 10では
Objective-C++のABIを

126
00:08:59,239 --> 00:09:03,844
構造体を処理する関数の
呼び出し間で統一

127
00:08:59,239 --> 00:09:03,844
構造体を処理する関数の
呼び出し間で統一

128
00:09:03,977 --> 00:09:08,248
構造体はARCオブジェクト
ポインタを持ちます

129
00:09:08,682 --> 00:09:12,986
Xcode 10ではABIを変えることで

130
00:09:13,220 --> 00:09:17,491
Objective-C++の関数を
対応させています

131
00:09:17,825 --> 00:09:21,395
ARCオブジェクトポインタを
持つ構造体を

132
00:09:21,495 --> 00:09:24,198
値で処理する関数です

133
00:09:24,398 --> 00:09:28,702
コンストラクタや
デストラクタなどは対象外です

134
00:09:30,037 --> 00:09:33,774
この調整で対象となるコードが

135
00:09:33,874 --> 00:09:36,910
あいまいな人もいるでしょう

136
00:09:37,010 --> 00:09:39,813
Xcodeのリリースノートで

137
00:09:39,913 --> 00:09:45,352
ABIの調整による影響を
詳しく説明しています

138
00:09:48,956 --> 00:09:54,761
ARCオブジェクトポインタを持つ
C構造体の注意点として

139
00:09:55,629 --> 00:09:57,564
Swiftは対応しません

140
00:09:57,664 --> 00:10:02,803
SwiftではARCオブジェクト
ポインタを持つ構造体は

141
00:09:57,664 --> 00:10:02,803
SwiftではARCオブジェクト
ポインタを持つ構造体は

142
00:10:03,170 --> 00:10:07,241
判定されず
コンパイルエラーとなります

143
00:10:13,847 --> 00:10:19,319
Xcode 10はARCオブジェクト
ポインタのサポートに加え

144
00:10:19,453 --> 00:10:24,358
新しいコンパイラ検出機能を
いくつも備えています

145
00:10:24,791 --> 00:10:28,395
Xcode 10にある
100種類以上の警告から

146
00:10:28,695 --> 00:10:31,164
２つを取り上げます

147
00:10:31,932 --> 00:10:34,902
１つ目はSwiftとObjective-Cを

148
00:10:35,569 --> 00:10:39,339
組み合わせた人に興味深いでしょう

149
00:10:39,840 --> 00:10:44,778
Swiftのコードは
Objective-Cにインポート可能です

150
00:10:45,245 --> 00:10:50,083
Xcodeの場合
Objective-Cの宣言を使って

151
00:10:50,184 --> 00:10:54,888
Swiftのインターフェイスを
構成するヘッダファイルを作成

152
00:10:56,456 --> 00:11:00,260
このヘッダファイルを
Objective-Cにインポートし

153
00:10:56,456 --> 00:11:00,260
このヘッダファイルを
Objective-Cにインポートし

154
00:11:00,360 --> 00:11:04,131
基底のSwiftの宣言に
アクセスします

155
00:11:04,865 --> 00:11:06,300
詳細を説明します

156
00:11:06,400 --> 00:11:11,672
重要なのは Swiftでの
クロージャのパラメータです

157
00:11:12,139 --> 00:11:14,041
こちらをご覧ください

158
00:11:14,141 --> 00:11:18,178
Executorという
Swiftのプロトコルです

159
00:11:18,679 --> 00:11:22,783
performOperationという
メンバ関数を定義し

160
00:11:22,883 --> 00:11:26,320
クロージャにhandlerを
取り入れます

161
00:11:27,454 --> 00:11:31,358
今 このパラメータは
エスケープ不可です

162
00:11:31,458 --> 00:11:34,561
つまり関数が返した後に

163
00:11:34,661 --> 00:11:37,464
保持や呼び出しはできません

164
00:11:38,565 --> 00:11:43,737
Objective-Cで
このようなプロトコルに従う時

165
00:11:43,837 --> 00:11:47,674
プログラマは
この規定を忘れがちです

166
00:11:48,075 --> 00:11:51,378
例えば Objective-C言語で

167
00:11:51,478 --> 00:11:55,215
インターフェイスは
DispatchExecutor

168
00:11:55,315 --> 00:11:58,185
Executorプロトコルに従います

169
00:11:58,285 --> 00:12:01,221
performOperationを提供し

170
00:11:58,285 --> 00:12:01,221
performOperationを提供し

171
00:12:01,321 --> 00:12:07,194
クロージャのパラメータに対応する
ハンドラブロックを取り込みます

172
00:12:07,394 --> 00:12:10,731
しかしコードを見ただけでは

173
00:12:10,831 --> 00:12:15,002
handlerがエスケープ可能か
分かりません

174
00:12:16,003 --> 00:12:19,206
そこでXcode 10は警告を出し

175
00:12:19,306 --> 00:12:25,012
パラメータがエスケープ不可だと
知らせてくれます

176
00:12:27,414 --> 00:12:28,815
修正するには

177
00:12:28,916 --> 00:12:33,787
ブロックの値に
NS NOESCAPEと注釈を補います

178
00:12:34,555 --> 00:12:37,624
メソッドのimplementationか

179
00:12:38,158 --> 00:12:43,063
そのパラメータにも
注釈を補っておきましょう

180
00:12:44,131 --> 00:12:48,268
NS NOESCAPEが
明白なリマインダとなります

181
00:12:48,368 --> 00:12:52,773
performOperationが返した後

182
00:12:52,873 --> 00:12:57,477
ハンドラブロックの保存や
呼び出しはしません

183
00:12:58,979 --> 00:13:04,117
SwiftとObjective-Cの間で
規定があると

184
00:12:58,979 --> 00:13:04,117
SwiftとObjective-Cの間で
規定があると

185
00:13:04,218 --> 00:13:07,821
私たちに気付かせてくれるのです

186
00:13:10,057 --> 00:13:13,760
２つ目は低水準コードを扱う人や

187
00:13:14,161 --> 00:13:17,764
メモリ内の配置を気にする人

188
00:13:17,865 --> 00:13:21,034
そんな人の関心を引くでしょう

189
00:13:21,735 --> 00:13:23,637
こちらを見てください

190
00:13:23,737 --> 00:13:29,009
Cでは構造体の配置や
アライメントは厳格です

191
00:13:29,776 --> 00:13:36,116
スライドの構造体では
コンパイラが２行目と３行目の間に

192
00:13:36,216 --> 00:13:39,620
２バイトのパディングを挿入します

193
00:13:40,687 --> 00:13:43,991
気楽に組みたいと思う人のために

194
00:13:44,091 --> 00:13:48,629
コンパイラは
pragma packディレクティブを提供

195
00:13:48,729 --> 00:13:52,299
配置やアライメントを
調整してくれます

196
00:13:54,434 --> 00:13:59,473
この例では
push, 1ディレクティブを使います

197
00:13:59,673 --> 00:14:01,909
既定の配置が解除します

198
00:13:59,673 --> 00:14:01,909
既定の配置が解除します

199
00:14:02,176 --> 00:14:06,580
構造体を隙間なく
埋めることができます

200
00:14:07,347 --> 00:14:09,149
構造体の直列化や

201
00:14:09,316 --> 00:14:13,921
ネットワーク上を
移動させる時に便利です

202
00:14:14,721 --> 00:14:19,993
pragma packは通例
PushとPopを指示します

203
00:14:20,327 --> 00:14:25,799
しかし忘れがちなのが
Popのコード挿入です

204
00:14:27,201 --> 00:14:30,103
Xcode 10はコードを警告

205
00:14:30,404 --> 00:14:34,408
Popが対応していないと伝えます

206
00:14:34,908 --> 00:14:37,978
またPushの位置を示します

207
00:14:39,646 --> 00:14:44,952
この警告を修正するには
Pushの位置を確認し

208
00:14:45,285 --> 00:14:50,724
Popをコードの対応する位置に
挿入します

209
00:14:51,692 --> 00:14:56,163
コードを詰めた後でも
直接 挿入できます

210
00:14:57,064 --> 00:14:58,866
新たな配置の規則は

211
00:14:59,466 --> 00:15:03,604
その詰めた構造体にだけ
適用されます

212
00:14:59,466 --> 00:15:03,604
その詰めた構造体にだけ
適用されます

213
00:15:03,704 --> 00:15:08,075
プログラム内の
他の構造体には影響しません

214
00:15:11,845 --> 00:15:17,284
この２つの警告は
Xcode 10のデフォルトです

215
00:15:17,885 --> 00:15:22,956
より適切で安定したコードが
書けるでしょう

216
00:15:23,357 --> 00:15:29,163
さらに安定したコード作成に関して
このあとジョージより

217
00:15:29,263 --> 00:15:33,367
改善したスタティックアナライザを
ご紹介します

218
00:15:33,967 --> 00:15:34,635
ジョージ

219
00:15:34,735 --> 00:15:40,307
(拍手)

220
00:15:40,908 --> 00:15:42,643
ありがとう アレックス

221
00:15:42,910 --> 00:15:46,780
私からは
Clangスタティックアナライザの

222
00:15:46,880 --> 00:15:49,783
改善点をご紹介します

223
00:15:50,284 --> 00:15:51,785
このアナライザは

224
00:15:51,885 --> 00:15:56,723
潜在的で再現困難なバグ検出に
適しています

225
00:15:57,157 --> 00:16:00,060
バグを発見するだけでなく

226
00:15:57,157 --> 00:16:00,060
バグを発見するだけでなく

227
00:16:00,160 --> 00:16:05,265
バグの原因となるパスを
Xcodeで表示します

228
00:16:05,532 --> 00:16:10,871
この例はNSMutableArrayに
nilがあるためクラッシュします

229
00:16:11,038 --> 00:16:14,174
スタティックアナライザが
そのパスを表示

230
00:16:14,274 --> 00:16:16,810
修正の流れを確認できます

231
00:16:17,978 --> 00:16:22,482
では３つの新たな改善点を
紹介します

232
00:16:22,749 --> 00:16:28,288
１つ目にGrand Central Dispatchの
アンチパターンを解析

233
00:16:28,388 --> 00:16:31,992
パフォーマンスの劣化を探ります

234
00:16:32,326 --> 00:16:35,829
２つ目は自動解放プール内の

235
00:16:35,929 --> 00:16:39,299
変数の誤用を検出する機能です

236
00:16:39,399 --> 00:16:42,202
use-after-freeを防ぎます

237
00:16:42,936 --> 00:16:48,275
３つ目はアナライザの性能と
表示機能の向上です

238
00:16:49,376 --> 00:16:54,448
まずはGCDアンチパターンの
解析機能を紹介します

239
00:16:54,848 --> 00:16:59,052
プラットフォームのAPIは
大抵 非同期です

240
00:16:59,153 --> 00:17:04,724
しかし同期させて
使いたい状況もあるでしょう

241
00:16:59,153 --> 00:17:04,724
しかし同期させて
使いたい状況もあるでしょう

242
00:17:05,526 --> 00:17:09,229
バックグラウンドで
コードが実行中の時や

243
00:17:09,463 --> 00:17:14,201
必須の値が使えるまで
関数が機能しない場合など

244
00:17:14,701 --> 00:17:19,772
有効な解決策は
同期化を確保するセマフォです

245
00:17:20,440 --> 00:17:22,843
こちらの例をご覧ください

246
00:17:22,943 --> 00:17:27,681
NSXPCConnectionの
オブジェクトです

247
00:17:27,781 --> 00:17:31,785
プロパティの
remoteObjectProxyを呼び出し

248
00:17:31,885 --> 00:17:36,857
異なるプロセスから非同期で
CurrentTaskNameを得ます

249
00:17:37,491 --> 00:17:39,860
そしてセマフォを対応させ

250
00:17:39,960 --> 00:17:42,829
コールバックはsignalに

251
00:17:43,163 --> 00:17:49,369
これで関数が返す前に
taskNameが有効になります

252
00:17:49,703 --> 00:17:53,974
しかし この方法は
パフォーマンスに影響します

253
00:17:54,341 --> 00:18:00,547
非同期でセマフォを使う時
問題が生じる可能性があります

254
00:17:54,341 --> 00:18:00,547
非同期でセマフォを使う時
問題が生じる可能性があります

255
00:18:00,781 --> 00:18:04,985
優先順位の低いキューが実行されて

256
00:18:05,085 --> 00:18:09,590
パフォーマンスの劣化や
ハングを起こすのです

257
00:18:10,057 --> 00:18:13,794
他にもパフォーマンスを
下げる原因となる―

258
00:18:13,927 --> 00:18:17,731
無用なスレッドを作ってしまいます

259
00:18:18,932 --> 00:18:21,301
この問題を解決するため

260
00:18:21,401 --> 00:18:24,805
スタティックアナライザが
警告します

261
00:18:26,206 --> 00:18:29,476
問題が生じた場所を示します

262
00:18:31,512 --> 00:18:33,680
修正方法はこちら

263
00:18:33,981 --> 00:18:40,020
最良の例として
同期が可能なAPIを用意しました

264
00:18:40,154 --> 00:18:42,489
NSXPCConnectionには

265
00:18:42,589 --> 00:18:47,394
類似APIのsynchronous
RemoteObjectProxyを配置

266
00:18:47,661 --> 00:18:53,267
セマフォの必要性を消し
より高速に実行させます

267
00:18:55,102 --> 00:18:59,606
次は同期したAPIが
無い場合の方法です

268
00:18:59,706 --> 00:19:03,277
startメソッドに継続を使用し

269
00:18:59,706 --> 00:19:03,277
startメソッドに継続を使用し

270
00:19:03,377 --> 00:19:06,480
コールバックに
必須の関数を呼び出します

271
00:19:09,116 --> 00:19:14,188
この検出機能は
ビルド設定で使用可能です

272
00:19:14,288 --> 00:19:19,927
アプリケーションを保護し
可能な限り速い動作を実現します

273
00:19:21,261 --> 00:19:24,364
では２つ目の解析機能です

274
00:19:24,464 --> 00:19:28,869
対象は自動解放プールに
残った変数です

275
00:19:30,304 --> 00:19:35,309
autoreleasingの修飾子は
自動解放プールから

276
00:19:35,409 --> 00:19:38,312
値が解放されることを示します

277
00:19:38,479 --> 00:19:42,849
例ではエラー変数を
プールに登録しています

278
00:19:42,950 --> 00:19:47,087
変数の制御が
プールの範囲外になると

279
00:19:47,187 --> 00:19:50,891
変数は解放され その後消滅します

280
00:19:51,058 --> 00:19:55,262
自動解放プールは
Objective-Cの機能です

281
00:19:55,362 --> 00:20:01,635
大容量メモリのアプリケーションの
処理を手軽にしてくれます

282
00:19:55,362 --> 00:20:01,635
大容量メモリのアプリケーションの
処理を手軽にしてくれます

283
00:20:02,970 --> 00:20:06,540
しかし
予期せぬクラッシュも起きます

284
00:20:07,040 --> 00:20:09,543
全く想定できないでしょう

285
00:20:09,643 --> 00:20:14,848
autoreleasingの修飾子で
明示していないからです

286
00:20:15,015 --> 00:20:18,719
今回 妥当性関数にoutパラメータの

287
00:20:18,952 --> 00:20:21,989
NSErrorを組み込んでいます

288
00:20:22,256 --> 00:20:27,728
outパラメータは
ARCにより自動解放されます

289
00:20:28,028 --> 00:20:33,066
今回 自動解放プールに
outパラメータを登録します

290
00:20:35,269 --> 00:20:39,439
関数が終了した後
エラー変数の値が解放

291
00:20:39,807 --> 00:20:43,744
呼び出し元が
値を読み込もうとすると

292
00:20:43,844 --> 00:20:47,181
use-after-freeでクラッシュします

293
00:20:50,818 --> 00:20:53,821
先ほどは検出困難な例でしたが

294
00:20:53,954 --> 00:21:00,394
自動解放プールの管理を
少しでも怠るとより難しくなります

295
00:20:53,954 --> 00:21:00,394
自動解放プールの管理を
少しでも怠るとより難しくなります

296
00:21:00,661 --> 00:21:05,899
こちらの関数もoutパラメータの
エラーを起こします

297
00:21:06,133 --> 00:21:09,770
enumerateObjectsUsingBlockを
呼び出します

298
00:21:09,870 --> 00:21:12,639
基盤となる定番のAPIで

299
00:21:12,739 --> 00:21:15,976
各要素にブロックを呼び出します

300
00:21:16,410 --> 00:21:19,346
しかし実際
enumerateObjectsUsingBlockは

301
00:21:19,446 --> 00:21:23,817
戻り値の自動解放プールに
呼び出します

302
00:21:24,017 --> 00:21:26,220
同じ問題が生じます

303
00:21:26,320 --> 00:21:32,292
エラー変数を作り ブロック内の
値をoutパラメータに書くと

304
00:21:32,526 --> 00:21:38,465
enumerateObjectsUsingBlockから
制御が外れる前に解放されます

305
00:21:39,533 --> 00:21:42,669
呼び出し元が値を読み込む時

306
00:21:42,769 --> 00:21:45,672
use-after-freeでクラッシュします

307
00:21:47,941 --> 00:21:51,245
先ほど紹介したコンパイラの警告は

308
00:21:51,345 --> 00:21:56,717
自動解放の明示が無い
outパラメータに対応します

309
00:21:56,984 --> 00:22:01,555
そしてパラメータの
自動解放の明示を促します

310
00:21:56,984 --> 00:22:01,555
そしてパラメータの
自動解放の明示を促します

311
00:22:02,055 --> 00:22:05,192
このような問題に対処するため

312
00:22:05,492 --> 00:22:11,265
Xcode 10にはClangスタティック
アナライザを導入しました

313
00:22:11,832 --> 00:22:14,101
自動解放プールの中に

314
00:22:15,102 --> 00:22:20,407
ブロックを呼び出したAPIを判断し
警告を出します

315
00:22:23,544 --> 00:22:25,846
問題を修正していきます

316
00:22:26,180 --> 00:22:30,717
手順は強力なローカル変数を
導入するだけ

317
00:22:30,984 --> 00:22:33,554
ブロック内の値を

318
00:22:33,654 --> 00:22:37,324
そのローカル変数に書き込みます

319
00:22:37,624 --> 00:22:42,729
制御がブロックから外れると
outパラメータにコピー

320
00:22:42,829 --> 00:22:45,332
自動解放プール内ではないので

321
00:22:45,432 --> 00:22:48,469
autoreleasingの変数は安全です

322
00:22:53,140 --> 00:22:58,912
最後に向上した性能と
表示方法をお伝えします

323
00:22:59,546 --> 00:23:01,448
Xcode 10では

324
00:22:59,546 --> 00:23:01,448
Xcode 10では

325
00:23:01,648 --> 00:23:05,652
アナライザがプログラムを
より効率的な手段で解析

326
00:23:05,752 --> 00:23:11,325
同じ解析時間で
検出できるバグは15％増加しました

327
00:23:12,125 --> 00:23:14,528
また検出するだけでなく

328
00:23:14,728 --> 00:23:19,900
バグレポートも
より分かりやすくなりました

329
00:23:20,000 --> 00:23:23,937
旧版のXcodeではエラー表示の際

330
00:23:24,638 --> 00:23:30,911
多くのステップや矢印ばかりで
理解に時間がかかりました

331
00:23:31,345 --> 00:23:35,582
Xcode 10ではエラーの解析結果を

332
00:23:35,782 --> 00:23:39,720
より短く単純な内容で表示します

333
00:23:39,820 --> 00:23:41,989
問題を素早く把握できます

334
00:23:43,357 --> 00:23:47,227
スタティックアナライザを
使用するには

335
00:23:47,327 --> 00:23:50,497
ProductからAnalyzeを選択します

336
00:23:50,864 --> 00:23:53,801
Analyze During Buildからでも

337
00:23:53,901 --> 00:23:57,004
アナライザが確認できるでしょう

338
00:23:57,237 --> 00:24:02,676
これは事前にバグを検出できる
最高のツールなのです

339
00:23:57,237 --> 00:24:02,676
これは事前にバグを検出できる
最高のツールなのです

340
00:24:03,010 --> 00:24:07,281
では低水準の改善点を
アーメドが紹介します

341
00:24:07,815 --> 00:24:10,184
(拍手)

342
00:24:10,284 --> 00:24:11,151
ありがとう ジョージ

343
00:24:11,251 --> 00:24:14,321
(拍手)

344
00:24:14,488 --> 00:24:18,592
紹介したとおり
コンパイラは多種の警告や

345
00:24:18,692 --> 00:24:21,228
アナライザ検出が可能です

346
00:24:21,395 --> 00:24:26,934
Sanitizerも多くのバグを
検出する上で役立ちます

347
00:24:28,101 --> 00:24:31,438
皆さんもすでにバグ検出ツールで

348
00:24:31,538 --> 00:24:34,541
何度も検査したことでしょう

349
00:24:34,975 --> 00:24:37,878
しかし ある種の厄介なバグは

350
00:24:38,045 --> 00:24:44,084
検査を潜り抜け リリースビルドに
入り込むことがあります

351
00:24:45,085 --> 00:24:47,054
そのためリリースビルド内で

352
00:24:47,154 --> 00:24:51,525
常にバグを軽減する措置を
用意しました

353
00:24:52,559 --> 00:24:58,632
Xcode 10に備わった
新たなバグ軽減措置を紹介します

354
00:25:00,033 --> 00:25:03,070
まずスタックの機能を把握します

355
00:25:04,905 --> 00:25:08,976
ここにdlogというC関数があります

356
00:25:09,309 --> 00:25:13,380
デバッグの文字列を含んでいます

357
00:25:14,715 --> 00:25:17,651
今回 Helloを呼び出します

358
00:25:18,285 --> 00:25:24,358
この呼び出しを記録していくために
メモリを割り当てます

359
00:25:26,026 --> 00:25:29,196
割り当てる場所がスタックで

360
00:25:29,663 --> 00:25:33,834
領域はnullポインタか
０のアドレスまでです

361
00:25:35,903 --> 00:25:40,774
スタックフレームという単位に
Helloを割り当てます

362
00:25:41,375 --> 00:25:46,813
スタックフレームは
戻りアドレスなどを含みます

363
00:25:47,681 --> 00:25:51,018
他にはローカル変数もあります

364
00:25:51,652 --> 00:25:55,389
ローカル変数を
logfile pathにすると

365
00:25:56,023 --> 00:25:58,058
スタックフレームに入ります

366
00:26:00,227 --> 00:26:04,598
このdlogflileに
別の関数を呼び出すと

367
00:26:05,699 --> 00:26:08,202
独自のスタックフレームができます

368
00:26:09,336 --> 00:26:14,441
処理が済むとフレームから外れ
呼び出し元に戻ります

369
00:26:16,777 --> 00:26:20,147
スタックフレームを分析しましょう

370
00:26:21,515 --> 00:26:27,654
４バイトのローカルバッファを
持つ関数に変更します

371
00:26:29,723 --> 00:26:32,960
デバッグの文字列を用意するため

372
00:26:33,060 --> 00:26:36,964
bufferを含むstrcpyを配置します

373
00:26:38,499 --> 00:26:41,502
バイト単位で文字をコピーします

374
00:26:41,602 --> 00:26:44,905
“H　e　l　l”

375
00:26:46,006 --> 00:26:49,643
しかし４バイトを使い切ったことで

376
00:26:49,843 --> 00:26:53,614
バッファには
バイトが余っていません

377
00:26:54,515 --> 00:26:59,953
そうなるとstrcpyは戻りアドレスを
オーバーライドします

378
00:27:01,021 --> 00:27:02,656
これは危険です

379
00:27:02,856 --> 00:27:06,527
攻撃者はコピー中の
文字列と同様に―

380
00:27:06,627 --> 00:27:09,897
戻りアドレスも制御できます

381
00:27:10,164 --> 00:27:15,903
よって次の動作まで制御できるため
安全性を脅かします

382
00:27:18,739 --> 00:27:24,645
この問題を検出するため
Address Sanitizerを使います

383
00:27:24,845 --> 00:27:27,981
これで簡単に修正できます

384
00:27:28,382 --> 00:27:33,821
重要なのはサイズを
把握しているstrncpyです

385
00:27:33,921 --> 00:27:37,257
より高レベルなAPIも効果的です

386
00:27:38,959 --> 00:27:42,729
このバグはリリースビルドに
残る場合があり

387
00:27:43,030 --> 00:27:48,135
対策として
Stack Protectorを使います

388
00:27:49,736 --> 00:27:54,341
スタックフレームの順序を変え
カナリーを加えます

389
00:27:55,609 --> 00:27:57,644
コードを書く時に

390
00:27:58,378 --> 00:28:04,051
returnの上のコードで
カナリーが有効か確認します

391
00:27:58,378 --> 00:28:04,051
returnの上のコードで
カナリーが有効か確認します

392
00:28:06,120 --> 00:28:09,923
最初にカナリーを
オーバーライドします

393
00:28:11,391 --> 00:28:17,197
返す前にカナリーで確認が入るため
処理が停止します

394
00:28:17,564 --> 00:28:23,170
悪用できる脆弱性が
信頼性の高いクラッシュに変わり

395
00:28:23,337 --> 00:28:25,272
攻撃者には不利です

396
00:28:26,640 --> 00:28:28,842
これがStack Protectorです

397
00:28:32,780 --> 00:28:37,684
バッファのオーバーフローを
検出してくれます

398
00:28:38,418 --> 00:28:41,855
Xcodeはデフォルトで
実装しています

399
00:28:44,324 --> 00:28:49,229
次はさらに厄介なケースへの
軽減措置です

400
00:28:50,664 --> 00:28:54,535
関数は先ほどと同じ
dlogを使いますが

401
00:28:55,002 --> 00:28:58,205
可変長配列になっています

402
00:28:59,072 --> 00:29:01,842
パラメータにはlenを使用

403
00:28:59,072 --> 00:29:01,842
パラメータにはlenを使用

404
00:29:04,011 --> 00:29:10,117
特定の呼び出しで
１万5000バイトの容量を要します

405
00:29:10,918 --> 00:29:14,388
スタックフレームも同等の長さに

406
00:29:16,990 --> 00:29:19,993
しかし全メモリは即座に使えず

407
00:29:20,094 --> 00:29:25,999
ページに分かれることで
スタックが必要に応じて拡張

408
00:29:26,567 --> 00:29:30,771
１万バイトのバッファで
アクセスしても

409
00:29:30,871 --> 00:29:35,342
次ページにあるため
有効ではありません

410
00:29:35,442 --> 00:29:38,912
CPU内のページ不良に備えて

411
00:29:39,012 --> 00:29:44,351
OSがスタックを延長すべきか
判断しているのです

412
00:29:44,852 --> 00:29:46,854
システムが管理します

413
00:29:49,056 --> 00:29:52,292
しかし 攻撃者が長さを制御し

414
00:29:52,392 --> 00:29:56,396
ページを増やしてしまった
としましょう

415
00:29:57,798 --> 00:29:59,233
新たな問題です

416
00:29:59,800 --> 00:30:05,372
メモリは有限ですから
スタックに割り当て続ければ

417
00:29:59,800 --> 00:30:05,372
メモリは有限ですから
スタックに割り当て続ければ

418
00:30:05,472 --> 00:30:09,343
ヒープなどの別領域に
達してしまいます

419
00:30:10,777 --> 00:30:13,580
するとクラッシュを起こします

420
00:30:13,680 --> 00:30:17,618
mallocなどで
確保していても無駄です

421
00:30:20,521 --> 00:30:24,391
先ほどのstrcpyの例にならうように

422
00:30:24,491 --> 00:30:28,262
１バイトずつ書いていきましょう

423
00:30:30,030 --> 00:30:33,167
“H　e　l”

424
00:30:33,600 --> 00:30:38,839
CPU 生成したコード OSは
問題ないと判断します

425
00:30:39,006 --> 00:30:43,143
すでに有効なページを
使っているからです

426
00:30:44,778 --> 00:30:51,185
しかしローカルなスタックではない
ヒープ上では問題です

427
00:30:51,485 --> 00:30:54,988
コードを書く時
オーバーライドするのは

428
00:30:55,189 --> 00:30:59,626
Boolean値など
関連性のない情報にします

429
00:31:00,294 --> 00:31:03,130
これも危険な問題になります

430
00:31:06,967 --> 00:31:10,204
そこで新機能が役に立ちます

431
00:31:10,838 --> 00:31:16,176
関数の始まる部分に
新たなコードが入ります

432
00:31:16,877 --> 00:31:20,714
スタックフレームの有効性を
確認するものです

433
00:31:21,348 --> 00:31:24,718
スタックの最大容量を把握し

434
00:31:25,285 --> 00:31:29,723
容量を超えた場合
処理を停止させます

435
00:31:31,125 --> 00:31:35,229
こちらも悪用の恐れがあるバグを

436
00:31:35,329 --> 00:31:39,032
信頼性の高いクラッシュに変えます

437
00:31:41,068 --> 00:31:46,540
これがStack Clashを検出する
Stack Checkingという機能です

438
00:31:46,840 --> 00:31:49,109
Xcode 10ではデフォルトです

439
00:31:53,313 --> 00:31:57,651
次はXcode 10に追加された拡張機能

440
00:31:57,751 --> 00:32:01,088
Set Extensionを紹介します

441
00:31:57,751 --> 00:32:01,088
Set Extensionを紹介します

442
00:32:02,923 --> 00:32:06,360
Appleには様々な端末があります

443
00:32:06,727 --> 00:32:10,931
Xcodeでは
少しビルド設定を行うだけで

444
00:32:11,031 --> 00:32:13,667
各端末にコードを互換できます

445
00:32:15,135 --> 00:32:20,641
macOS iOS watchOSなど
システム内で微調整を行い

446
00:32:20,741 --> 00:32:26,313
特定のハードウェアで
使えるコードを各端末で共有

447
00:32:26,413 --> 00:32:29,783
性能を最大限に引き出せます

448
00:32:31,151 --> 00:32:35,355
高い性能を必要とする
アプリケーションでも

449
00:32:35,455 --> 00:32:37,825
求める機能が使えます

450
00:32:39,726 --> 00:32:41,995
取り上げる３つの特徴は

451
00:32:42,095 --> 00:32:45,732
iMac Pro iPhone 8 iPhone 8 Plus
iPhone Xのものです

452
00:32:47,034 --> 00:32:48,769
iMac Proから始めます

453
00:32:51,238 --> 00:32:54,508
iMac ProはCPUにIntel Xeonを搭載

454
00:32:56,009 --> 00:33:00,214
AVX-512という新たな特徴を
備えています

455
00:32:56,009 --> 00:33:00,214
AVX-512という新たな特徴を
備えています

456
00:33:02,015 --> 00:33:06,320
AVX-512は
新しいベクトル指示です

457
00:33:08,689 --> 00:33:13,627
X86-64を上回る処理能力が
期待できます

458
00:33:13,727 --> 00:33:17,431
X86-64で想定できる処理容量は

459
00:33:17,531 --> 00:33:20,000
128ビットベクトル以下です

460
00:33:20,100 --> 00:33:24,204
Intelの動力源を持つMacに
対応可能です

461
00:33:25,038 --> 00:33:28,475
しかし現在の新型Macは進化し

462
00:33:28,709 --> 00:33:33,146
iMac Proでは初となる
512ビットレジスタを実現

463
00:33:35,649 --> 00:33:39,953
そこでClangの
自動ベクトル化機能が生きます

464
00:33:40,420 --> 00:33:45,592
ベクトルはいくつもの要素を
構成しているからです

465
00:33:46,260 --> 00:33:48,729
処理能力が向上します

466
00:33:51,198 --> 00:33:53,500
さらにAVX-512の利点に

467
00:33:53,767 --> 00:33:59,640
ベクトルレジスタが
増えたことが挙げられます

468
00:33:59,873 --> 00:34:05,612
X86-64の16個を上回る
32個でデータを管理します

469
00:33:59,873 --> 00:34:05,612
X86-64の16個を上回る
32個でデータを管理します

470
00:34:07,214 --> 00:34:13,454
自動ベクトル化機能が
これらのベクトルを生かせずとも

471
00:34:13,554 --> 00:34:19,025
スカラレジスタは増えており
float型 double型も対応します

472
00:34:20,060 --> 00:34:22,663
他にも多くの利点があります

473
00:34:24,164 --> 00:34:29,969
計算に負担のかかる関数を
例に取り上げてみましょう

474
00:34:31,772 --> 00:34:35,742
まずは既存の関数を備えておきます

475
00:34:36,009 --> 00:34:40,047
どのMacも
フォールバックとして有効です

476
00:34:41,681 --> 00:34:44,051
次に関数を特殊化します

477
00:34:44,150 --> 00:34:47,321
方法は属性のターゲット指定です

478
00:34:49,156 --> 00:34:52,292
iMac Proのみですが この関数に

479
00:34:52,391 --> 00:34:55,762
AVX-512の適用を
コンパイラに伝えます

480
00:34:57,331 --> 00:35:02,135
128ビットベクトルの
simd float4を使えば

481
00:34:57,331 --> 00:35:02,135
128ビットベクトルの
simd float4を使えば

482
00:35:02,603 --> 00:35:07,041
AVX-512を上回る性能に
なるかもしれません

483
00:35:09,109 --> 00:35:13,447
さらに大きい容量の
simd float16なら

484
00:35:13,547 --> 00:35:19,653
512ビットベクトルがネイティブの
性能を大きく超えるでしょう

485
00:35:21,955 --> 00:35:24,792
X86のモデルをご使用なら

486
00:35:24,892 --> 00:35:30,030
m512データ型と共に
AVX-512遷移をお試しください

487
00:35:32,766 --> 00:35:37,471
より大きなユニットのコードも
特殊化できます

488
00:35:37,871 --> 00:35:40,607
ファイル ターゲット
ライブラリなどです

489
00:35:40,741 --> 00:35:46,647
ベクトル拡張のビルド設定から
AVX-512の値が使えます

490
00:35:49,383 --> 00:35:51,752
AVX-1やAVX-2と同様―

491
00:35:51,919 --> 00:35:56,990
使用する時の注意点が
いくつかあります

492
00:35:58,759 --> 00:36:02,896
256ビット以上のベクトルであれば

493
00:35:58,759 --> 00:36:02,896
256ビット以上のベクトルであれば

494
00:36:03,130 --> 00:36:05,432
AVX-512関数は対応します

495
00:36:05,532 --> 00:36:09,603
特殊化してABIに
差異が出るようなら

496
00:36:09,703 --> 00:36:11,839
遷移はできません

497
00:36:14,074 --> 00:36:17,177
またベクトルの容量が大きく

498
00:36:17,277 --> 00:36:22,916
自然なアライメントを
mallocなどでは確保し切れません

499
00:36:23,116 --> 00:36:25,953
スタック以外に割り当てる際

500
00:36:26,420 --> 00:36:28,122
注意してください

501
00:36:30,457 --> 00:36:33,026
これらの注意事項はすべて―

502
00:36:33,126 --> 00:36:36,196
OS上で解決することができます

503
00:36:36,430 --> 00:36:41,468
Accelerateフレームワークを使えば
簡単に扱えます

504
00:36:41,568 --> 00:36:46,240
全関数を細部まで
特殊化済みだからです

505
00:36:48,542 --> 00:36:50,344
AVX-512でした

506
00:36:51,511 --> 00:36:56,583
次にiPhone 8 iPhone 8 Plus
iPhone Xの新しい特徴です

507
00:36:59,253 --> 00:37:04,024
最初に紹介するのは
ARMv8.1 Atomicsです

508
00:36:59,253 --> 00:37:04,024
最初に紹介するのは
ARMv8.1 Atomicsです

509
00:37:04,958 --> 00:37:10,164
iPhone Xの特徴の１つを
生かしています

510
00:37:10,464 --> 00:37:12,699
A11 Bionicチップです

511
00:37:16,336 --> 00:37:18,539
A10と比較すると

512
00:37:18,672 --> 00:37:22,910
このチップには
新たな特徴があります

513
00:37:23,010 --> 00:37:25,546
A11はiOSで初となる―

514
00:37:25,646 --> 00:37:30,450
６つのコアによる
同時処理が可能です

515
00:37:32,386 --> 00:37:37,057
そのため処理できる
スレッドも増えそうですが

516
00:37:37,157 --> 00:37:41,729
スレッドが増えれば
同期化が求められます

517
00:37:42,663 --> 00:37:44,631
そこでAtomicsです

518
00:37:45,666 --> 00:37:49,703
A11は新たな
アトミックの指示を導入

519
00:37:49,803 --> 00:37:55,175
使い切れていなかったコアを
最大限に活用します

520
00:37:57,377 --> 00:37:58,712
詳しく解説します

521
00:38:00,614 --> 00:38:05,419
アトミックは一連のコードを
介して機能します

522
00:38:05,886 --> 00:38:09,990
スレッドからメインメモリに
アクセスしてみます

523
00:38:10,424 --> 00:38:13,527
アトミックな共有変数を持ち

524
00:38:13,694 --> 00:38:15,396
インクリメントします

525
00:38:17,431 --> 00:38:21,468
システム下で
一連のコードが生成され

526
00:38:21,969 --> 00:38:25,772
キャッシュラインに
独占的にアクセス

527
00:38:25,939 --> 00:38:31,245
アトミック変数のみの
小さなメモリ領域ができます

528
00:38:33,714 --> 00:38:37,184
その後 変数をロードします

529
00:38:37,284 --> 00:38:40,587
一時的にロードした値を
インクリメントし

530
00:38:40,754 --> 00:38:42,689
結果を返します

531
00:38:44,858 --> 00:38:47,561
独占的なアクセスなので

532
00:38:47,661 --> 00:38:52,633
値を変えるような
別のスレッドは受け付けません

533
00:38:53,934 --> 00:38:56,603
しかし同じキャッシュラインに

534
00:38:56,703 --> 00:39:00,340
別のスレッドが
アクセスしたとします

535
00:38:56,703 --> 00:39:00,340
別のスレッドが
アクセスしたとします

536
00:39:02,676 --> 00:39:07,047
両スレッドが
変数へのアクセスを試みますが

537
00:39:07,581 --> 00:39:10,784
独占的なアクセスになりません

538
00:39:12,152 --> 00:39:16,056
そのため
どちらもアクセス失敗となり

539
00:39:16,523 --> 00:39:19,693
成功するまで繰り返します

540
00:39:21,995 --> 00:39:24,131
これは性能に影響します

541
00:39:25,933 --> 00:39:31,271
A11のCPUアーキテクチャである
ARMv8.1なら

542
00:39:31,371 --> 00:39:34,074
１つのステップで処理します

543
00:39:34,341 --> 00:39:37,010
飛躍的な改善も見込めます

544
00:39:38,412 --> 00:39:41,348
これは各関数の特殊化や

545
00:39:41,448 --> 00:39:46,253
ターゲットを示すコードを
特殊化してくれます

546
00:39:47,154 --> 00:39:52,459
C11かC++11のAtomicsのみに
非常に有効です

547
00:39:52,993 --> 00:39:55,963
GCDやPThreadといった―

548
00:39:56,063 --> 00:39:59,833
高水準なライブラリが
手軽に使えます

549
00:40:00,834 --> 00:40:03,103
ARMv8.1用に調整済みですが

550
00:40:03,203 --> 00:40:07,174
OSと連動させて
より性能を引き出せます

551
00:40:11,111 --> 00:40:15,716
A11の別の特徴は
16ビット浮動小数点です

552
00:40:16,250 --> 00:40:21,255
２種類の標準的な浮動小数点は
よくご存知でしょう

553
00:40:21,355 --> 00:40:25,259
64ビットと32ビットの
浮動小数点です

554
00:40:26,093 --> 00:40:30,397
A11では
さらに16ビットが加わります

555
00:40:30,964 --> 00:40:34,735
これは桁数が少なく精度も低いため

556
00:40:34,902 --> 00:40:37,471
大抵 役に立ちません

557
00:40:38,072 --> 00:40:44,578
しかし機械学習やMetalを介した
GPUの使用などに適しています

558
00:40:45,412 --> 00:40:47,814
ベクトルの容量が同じなら

559
00:40:47,915 --> 00:40:51,051
より多く配置できます

560
00:40:53,354 --> 00:40:56,323
これもコードの特殊化が可能です

561
00:40:56,857 --> 00:41:02,596
これらの特徴は どの端末でも
使えるわけではありません

562
00:40:56,857 --> 00:41:02,596
これらの特徴は どの端末でも
使えるわけではありません

563
00:41:03,430 --> 00:41:07,568
実行中の端末で動的に対応できるか

564
00:41:07,668 --> 00:41:09,937
常に確認が必要です

565
00:41:10,404 --> 00:41:12,639
sysctlbynameを利用します

566
00:41:14,074 --> 00:41:19,213
System frameworkに
対応を委ねても構いません

567
00:41:21,782 --> 00:41:24,351
３つの特徴をまとめます

568
00:41:24,451 --> 00:41:27,521
iMac Proに備わったAVX-512

569
00:41:27,621 --> 00:41:31,125
各種iPhoneはAtomicsと
16ビット浮動小数点でした

570
00:41:33,727 --> 00:41:36,964
Xcodeの新機能は以上です

571
00:41:37,197 --> 00:41:39,933
本日 紹介した機能以外にも

572
00:41:40,033 --> 00:41:44,271
Xcode 10は
様々な機能を備えています

573
00:41:44,972 --> 00:41:48,142
100種類以上の新しい警告や

574
00:41:48,242 --> 00:41:54,014
C++17の標準的なライブラリなど
まだまだあります

575
00:41:55,749 --> 00:42:00,788
より詳しく知りたい人は
デベロッパWebサイトや

576
00:41:55,749 --> 00:42:00,788
より詳しく知りたい人は
デベロッパWebサイトや

577
00:42:01,088 --> 00:42:04,525
ラボにお立ち寄りください

578
00:42:05,092 --> 00:42:05,659
ありがとうございました

579
00:42:05,759 --> 00:42:12,266
(拍手)