
1
00:00:07,074 --> 00:00:16,183
(音楽)

2
00:00:25,859 --> 00:00:28,896
(拍手)

3
00:00:28,996 --> 00:00:30,163
おはようございます

4
00:00:30,831 --> 00:00:33,133
今回のテーマはSwiftです

5
00:00:33,467 --> 00:00:37,771
SwiftとSwiftコミュニティは
進化しました

6
00:00:37,871 --> 00:00:42,910
スラヴァと私が
改良された点をご紹介します

7
00:00:43,610 --> 00:00:45,846
主な議題は２つです

8
00:00:46,046 --> 00:00:51,418
まずはオープンソースと
それに関連したコミュニティ

9
00:00:51,518 --> 00:00:57,090
次にベータ版Xcode 10の
Swift 4.2を詳しく紹介します

10
00:00:58,559 --> 00:01:03,263
オープンソースの開発は
GitHub上で行ってきました

11
00:00:58,559 --> 00:01:03,263
オープンソースの開発は
GitHub上で行ってきました

12
00:01:04,464 --> 00:01:08,435
ユーザ間で
議論や提案を重ねて

13
00:01:08,669 --> 00:01:13,740
言語と基本ライブラリの
改良を行ってきました

14
00:01:15,609 --> 00:01:22,082
600人以上のユーザが
コードをGitHub上に提供し

15
00:01:22,482 --> 00:01:26,386
１万8000件以上の
プルリクエストをマージ

16
00:01:27,154 --> 00:01:29,823
Swift.orgを開設してから

17
00:01:29,923 --> 00:01:35,762
SwiftはXcode用に
ダウンロードが可能となり

18
00:01:35,863 --> 00:01:38,465
Ubuntuにも対応しています

19
00:01:38,565 --> 00:01:43,837
これは開発スナップショット
および公式リリース日です

20
00:01:44,905 --> 00:01:51,245
また全プラットフォームでの
Swiftの使用を実現するには

21
00:01:51,411 --> 00:01:56,850
コミュニティによるテストの
サポートが欠かせません

22
00:01:56,950 --> 00:02:02,322
Swiftサポートを広げるため
大勢が努力しています

23
00:01:56,950 --> 00:02:02,322
Swiftサポートを広げるため
大勢が努力しています

24
00:02:02,422 --> 00:02:04,691
我々も協力しました

25
00:02:06,360 --> 00:02:12,332
継続的インテグレーション
システムを拡大したのです

26
00:02:12,432 --> 00:02:16,937
新たなプラットフォームで
Swiftを使う時も

27
00:02:17,037 --> 00:02:21,108
ハードウェアサポートを
プラグインしテストできます

28
00:02:21,241 --> 00:02:24,845
Swiftサポートを
広げる第一歩です

29
00:02:26,813 --> 00:02:32,953
オープンソースの開発には
多額の投資も行いました

30
00:02:33,053 --> 00:02:36,356
変更点について論じる
コミュニティです

31
00:02:36,924 --> 00:02:42,796
コミュニティの要望で
約半年前にメール形式から―

32
00:02:42,896 --> 00:02:45,098
フォーラムに変えました

33
00:02:45,265 --> 00:02:47,568
ユーザが求めたのは

34
00:02:47,668 --> 00:02:51,839
自分のレベルに合った
参加方法です

35
00:02:52,072 --> 00:02:54,474
以前は困難でしたが

36
00:02:54,575 --> 00:02:58,178
フォーラムで可能となりました

37
00:02:59,379 --> 00:03:03,750
フォーラムは
一般のプロジェクトでも

38
00:02:59,379 --> 00:03:03,750
フォーラムは
一般のプロジェクトでも

39
00:03:03,917 --> 00:03:06,420
使えるようにしました

40
00:03:08,455 --> 00:03:12,693
Swiftオープンソースの
管理者であれば

41
00:03:12,793 --> 00:03:15,963
フォーラムで議論が可能です

42
00:03:16,063 --> 00:03:19,666
議題はユーザや
開発についてなど

43
00:03:20,901 --> 00:03:26,340
Swift.orgの一般的な
利用方法も考えました

44
00:03:26,507 --> 00:03:30,911
今週 The Swift Programming
LanguageをSwift.orgに移しました

45
00:03:31,378 --> 00:03:35,015
URLはdocs.swift.orgで

46
00:03:35,115 --> 00:03:39,353
コミュニティで活用できる
ドキュメントがあります

47
00:03:41,522 --> 00:03:46,760
人々はSwiftを使うことに
心を躍らせていて―

48
00:03:46,860 --> 00:03:49,596
あちこちで話題です

49
00:03:49,696 --> 00:03:52,933
例えばPodcastやMeetup

50
00:03:53,033 --> 00:03:56,770
カンファレンスなどを
活用して

51
00:03:56,870 --> 00:04:00,240
評価などを参考にしています

52
00:03:56,870 --> 00:04:00,240
評価などを参考にしています

53
00:04:00,807 --> 00:04:05,479
昨年より我々は
プレゼンテーションを行い

54
00:04:05,579 --> 00:04:11,251
Swiftの技術的な解説や
何が可能かを伝えてきました

55
00:04:11,351 --> 00:04:15,489
オープンソースの開発への
参加方法もです

56
00:04:16,290 --> 00:04:19,860
情報の提供は
今後も続けていきます

57
00:04:21,361 --> 00:04:26,400
その一環として
金曜にカンファレンスがあります

58
00:04:26,500 --> 00:04:29,670
try! Swift San Joseです

59
00:04:29,770 --> 00:04:33,307
コミュニティメンバーとの
ワークショップがあり

60
00:04:33,407 --> 00:04:38,512
オープンソースの開発に
協力する人をサポートします

61
00:04:38,612 --> 00:04:44,918
コンパイラチームも参加し
議論の手助けをする予定です

62
00:04:46,954 --> 00:04:48,755
コミュニティは以上です

63
00:04:48,989 --> 00:04:50,224
次はSwift 4.2

64
00:04:51,091 --> 00:04:55,829
まずは改良点と
その影響に関して話します

65
00:04:58,098 --> 00:05:02,736
Swiftの大規模アップデートは
年に２回です

66
00:04:58,098 --> 00:05:02,736
Swiftの大規模アップデートは
年に２回です

67
00:05:02,903 --> 00:05:07,374
Swift 4.2は4.1と4.0からの
アップデートです

68
00:05:08,141 --> 00:05:12,079
大まかに２つの点が
改良されました

69
00:05:12,212 --> 00:05:15,616
１つは開発者の
生産性を重視した点

70
00:05:15,716 --> 00:05:17,484
改良点は様々です

71
00:05:17,584 --> 00:05:19,353
例えばビルド速度の向上

72
00:05:19,453 --> 00:05:21,655
さらに力を入れたのが

73
00:05:21,822 --> 00:05:26,493
デバッガからエディタまでの
操作性の改善です

74
00:05:26,960 --> 00:05:30,430
コミュニティは
言語の改良にも注力し

75
00:05:30,531 --> 00:05:34,735
開発者のワークフローを
改善しました

76
00:05:34,835 --> 00:05:39,039
またSDKの改良のため
投資も続けています

77
00:05:39,139 --> 00:05:42,843
Objective-C APIsが
うまく反映され

78
00:05:43,010 --> 00:05:47,681
言語やAPIの活用が
より有効的になりました

79
00:05:48,148 --> 00:05:50,984
さらに 注力しているのが

80
00:05:51,084 --> 00:05:54,488
ランタイムの変更や改良による―

81
00:05:54,588 --> 00:05:56,990
バイナリ互換性の達成です

82
00:05:57,891 --> 00:05:59,293
達成時期は―

83
00:06:01,528 --> 00:06:05,232
Swift 5をリリース予定の
2019年初めです

84
00:06:05,933 --> 00:06:07,835
バイナリ互換性とは？

85
00:06:08,302 --> 00:06:13,640
Swift 5以降のコンパイラで
ビルドしたSwiftコードを

86
00:06:13,807 --> 00:06:20,280
バイナリレベルで別のコードと
相互に運用できることです

87
00:06:20,380 --> 00:06:24,852
言語の成熟において
重大な進歩です

88
00:06:25,085 --> 00:06:30,390
これでSwiftのランタイムが
OSに組み込まれ

89
00:06:30,491 --> 00:06:35,329
アプリケーションにバンドルで
含む必要がありません

90
00:06:35,662 --> 00:06:41,835
スタートアップの時間や
メモリ使用量なども改善され

91
00:06:41,935 --> 00:06:44,505
様々な好結果が得られます

92
00:06:45,772 --> 00:06:51,078
ABIの安定化 つまり
バイナリ互換性については

93
00:06:51,178 --> 00:06:55,449
Swift.orgのABI STABILITYを
ご覧ください

94
00:06:57,951 --> 00:07:03,123
Swift 4.2はSwift 5へと
つながっていきます

95
00:06:57,951 --> 00:07:03,123
Swift 4.2はSwift 5へと
つながっていきます

96
00:07:04,625 --> 00:07:06,493
ソース互換性の話をします

97
00:07:07,427 --> 00:07:13,066
Xcode 10には１つの
Swiftコンパイラが含まれます

98
00:07:13,534 --> 00:07:16,603
Swift 4.2がそうです

99
00:07:17,171 --> 00:07:20,107
しかしXcode 9と同じく

100
00:07:20,207 --> 00:07:24,711
コンパイラは複数言語の
互換モードがあります

101
00:07:25,145 --> 00:07:28,482
どのモードでも
APIや言語機能が―

102
00:07:28,582 --> 00:07:30,684
すべて使用可能です

103
00:07:30,784 --> 00:07:33,820
これらはソースに影響します

104
00:07:35,989 --> 00:07:39,226
最初の２つは
Xcode 9にも搭載され

105
00:07:39,326 --> 00:07:45,332
Swift 3と4のコードを変えず
そのまま使うことができます

106
00:07:45,566 --> 00:07:52,339
さらにSwift 4.2ではSDKの
改良で幅が広がりました

107
00:07:53,407 --> 00:07:54,074
そうです

108
00:07:55,676 --> 00:08:02,015
前バージョンからの移行は
Edit menuで対応できます

109
00:07:55,676 --> 00:08:02,015
前バージョンからの移行は
Edit menuで対応できます

110
00:08:02,716 --> 00:08:07,321
SDKの変更に関して
注意点があります

111
00:08:07,421 --> 00:08:11,291
ベータ版Xcode 10では
SDKが改良がされるため

112
00:08:11,391 --> 00:08:14,361
フィードバックを募集します

113
00:08:14,461 --> 00:08:19,967
APIで改良すべき点と
Swiftへの影響などです

114
00:08:20,133 --> 00:08:25,372
4.2への移行を先に行うと
あとで変更があるので

115
00:08:25,472 --> 00:08:29,176
移行を遅らせるのも
１つの選択です

116
00:08:30,511 --> 00:08:36,283
Swift 4.2ではコードの
発達が急速に進んでいます

117
00:08:36,383 --> 00:08:40,721
言語の成熟において
重要な時期です

118
00:08:41,421 --> 00:08:47,895
だからこそSwift 3から
Swift 4.2に移行を勧めます

119
00:08:47,995 --> 00:08:52,366
コードサイズは改善され
言語も発達しました

120
00:08:52,733 --> 00:08:57,538
Swift 3互換モードは
Xcode 10で最後となります

121
00:08:59,640 --> 00:09:01,808
ツールの話に移ります

122
00:08:59,640 --> 00:09:01,808
ツールの話に移ります

123
00:09:02,442 --> 00:09:06,880
Xcode 9に比べ
Swiftプロジェクトのビルドは

124
00:09:06,980 --> 00:09:09,683
大幅に改善されました

125
00:09:10,083 --> 00:09:14,855
MacBook Proのクアッドコア
Intel Core i7プロセッサです

126
00:09:15,489 --> 00:09:17,791
その中の１つを紹介します

127
00:09:18,792 --> 00:09:21,862
Objective-Cで始まり

128
00:09:21,962 --> 00:09:25,933
Swiftを組み込んだ
プロジェクトです

129
00:09:26,133 --> 00:09:28,168
これは普通の流れです

130
00:09:28,669 --> 00:09:31,071
ビルド時間の改善で

131
00:09:31,305 --> 00:09:35,876
Swiftコードのビルド速度が
大幅に向上しました

132
00:09:36,243 --> 00:09:39,546
Swiftコードの
ビルド速度だけを見ると

133
00:09:39,646 --> 00:09:43,217
以前の３倍の
速度になっています

134
00:09:43,317 --> 00:09:47,788
プロジェクト全体では
1.6xの高速化です

135
00:09:49,556 --> 00:09:54,094
ビルドの改善は
プロジェクトの内容や

136
00:09:54,194 --> 00:09:57,865
コード量とコア数などで異なります

137
00:09:57,965 --> 00:10:01,802
大体のプロジェクトは
2xの速度になります

138
00:09:57,965 --> 00:10:01,802
大体のプロジェクトは
2xの速度になります

139
00:10:02,336 --> 00:10:04,905
さらなる利点があります

140
00:10:05,005 --> 00:10:09,143
Swiftでは複数の
ファイルを扱えます

141
00:10:09,243 --> 00:10:12,379
ヘッダファイルは不要です

142
00:10:12,479 --> 00:10:15,949
コンパイラの
不要な処理も多いです

143
00:10:16,149 --> 00:10:18,886
そこでコンパイルパイプラインを
革新し

144
00:10:18,986 --> 00:10:22,923
無駄を抑え
コアの活用を効率化しました

145
00:10:23,023 --> 00:10:24,825
これが速さの理由です

146
00:10:25,192 --> 00:10:31,131
ビルドの工程に関しては
今週 別のセッションがあり

147
00:10:31,231 --> 00:10:34,468
様々な利点について話します

148
00:10:36,270 --> 00:10:40,908
さて１番の利点は
デバッグビルドです

149
00:10:43,076 --> 00:10:47,948
Xcodeのビルド設定を
例に説明します

150
00:10:48,649 --> 00:10:52,853
最近 コンパイルモードを
最適化レベルから分けました

151
00:10:53,120 --> 00:10:56,990
プロジェクトの作成方法です

152
00:10:57,090 --> 00:11:00,427
リリースビルドは
Whole Moduleモードで

153
00:10:57,090 --> 00:11:00,427
リリースビルドは
Whole Moduleモードで

154
00:11:00,527 --> 00:11:04,198
全ファイルを
同時にビルドします

155
00:11:04,298 --> 00:11:07,501
これが最適化を可能にします

156
00:11:07,935 --> 00:11:11,605
最適化の機会が
増えるということです

157
00:11:12,039 --> 00:11:15,209
デバッグビルドは
Incrementalモードで

158
00:11:15,309 --> 00:11:18,979
ビルドが同時ではありません

159
00:11:19,479 --> 00:11:23,116
これにより
パフォーマンスは低下します

160
00:11:23,417 --> 00:11:26,720
Optimazation Levelは
No optimazationです

161
00:11:26,820 --> 00:11:29,323
デバッグ情報が改善します

162
00:11:29,423 --> 00:11:32,426
リリースビルドは
最適化されますが

163
00:11:32,593 --> 00:11:35,829
そのレベルは
あとで説明します

164
00:11:39,533 --> 00:11:44,138
コンパイルモードと
最適化レベルを分けたことで

165
00:11:44,738 --> 00:11:49,243
ある興味深い暫定策が
見つかりました

166
00:11:49,543 --> 00:11:53,714
Whole Moduleモードと
No optimazationを組み合わせると

167
00:11:53,814 --> 00:11:56,483
デバッグビルドが
速くなるのです

168
00:11:56,884 --> 00:11:58,418
この組み合わせにより

169
00:11:58,519 --> 00:12:03,423
先にお話しした無駄が
格段に抑えられるからです

170
00:11:58,519 --> 00:12:03,423
先にお話しした無駄が
格段に抑えられるからです

171
00:12:03,524 --> 00:12:09,163
除去に努めてきた
不要部分が大幅に減るのです

172
00:12:09,963 --> 00:12:13,233
しかしビルドが
増えにくくなり―

173
00:12:13,333 --> 00:12:17,271
１つを変えると
全ファイルが再構築されます

174
00:12:17,371 --> 00:12:20,107
Xcode 10の
デバッグビルドでは

175
00:12:20,207 --> 00:12:23,243
暫定策は必要なくなります

176
00:12:23,343 --> 00:12:29,183
Incrementalモードも
先の組み合わせと同じく効果的です

177
00:12:29,283 --> 00:12:31,952
すでにサポート
範囲内だからです

178
00:12:34,588 --> 00:12:37,591
次にランタイムの
最適化についてです

179
00:12:37,691 --> 00:12:40,928
バイナリ互換性にも
つながります

180
00:12:43,230 --> 00:12:46,066
Swiftは自動で
メモリを管理します

181
00:12:46,767 --> 00:12:51,338
Objective-Cと同様に
参照カウントを使います

182
00:12:51,805 --> 00:12:56,777
これはコンパイラの
リリースまでの流れです

183
00:12:57,411 --> 00:12:59,713
Swift 4.1の場合です

184
00:13:02,216 --> 00:13:06,253
+1 reference countが
付随します

185
00:13:06,687 --> 00:13:11,091
規約ではオブジェクトが
別の関数に渡されると

186
00:13:11,191 --> 00:13:14,728
関数が呼び出され
リリースされました

187
00:13:14,828 --> 00:13:19,800
リリース処理を
別の関数にさせるのです

188
00:13:20,300 --> 00:13:24,638
これはオブジェクトの
ライフタイムを縮めています

189
00:13:24,738 --> 00:13:27,307
最小限の働きしかしません

190
00:13:27,708 --> 00:13:31,245
しかし こういったコードの場合

191
00:13:31,345 --> 00:13:35,716
オブジェクトを異なるAPIに
何度も渡します

192
00:13:35,816 --> 00:13:38,352
呼び出し規約に従い

193
00:13:38,452 --> 00:13:43,257
初めの参照数が最後の
呼び出しとつり合います

194
00:13:43,423 --> 00:13:47,828
しかし規約では
途中の呼び出しが

195
00:13:47,928 --> 00:13:50,297
保持されリリースされます

196
00:13:50,797 --> 00:13:52,432
無駄な作業です

197
00:13:52,533 --> 00:13:57,404
オブジェクトは一連の
流れの中でも生きています

198
00:13:57,704 --> 00:14:00,707
Swift 4.2では改善しました

199
00:13:57,704 --> 00:14:00,707
Swift 4.2では改善しました

200
00:14:00,807 --> 00:14:05,012
オブジェクトは
リリースされません

201
00:14:05,112 --> 00:14:08,415
保持とリリースの
工程は消えました

202
00:14:10,517 --> 00:14:13,320
これで無駄が縮小されました

203
00:14:13,854 --> 00:14:15,355
これによる利点は

204
00:14:15,456 --> 00:14:18,525
コードサイズが
縮小されたことと

205
00:14:18,625 --> 00:14:20,661
ランタイムの改善です

206
00:14:23,330 --> 00:14:26,099
また文字列も改善しました

207
00:14:26,533 --> 00:14:30,537
以前は24だったのが
今は16バイトです

208
00:14:30,637 --> 00:14:34,274
メモリと動作との間の
妥協点です

209
00:14:35,242 --> 00:14:40,347
まだこのサイズでも
文字列を最適化できます

210
00:14:40,614 --> 00:14:44,084
文字列が15バイト内の場合

211
00:14:44,184 --> 00:14:47,321
文字列の型として
表示されます

212
00:14:47,421 --> 00:14:50,924
異なるバッファに
移す必要はありません

213
00:14:51,325 --> 00:14:55,395
これでメモリと動作が
さらに改善されます

214
00:14:55,629 --> 00:14:58,365
文字列内の最適化と同様に

215
00:14:58,465 --> 00:15:00,834
多くの文字列を入力できます

216
00:14:58,465 --> 00:15:00,834
多くの文字列を入力できます

217
00:15:03,704 --> 00:15:07,274
最後に言語の
改良点をお話しします

218
00:15:07,741 --> 00:15:10,978
コードサイズの
縮小についてです

219
00:15:12,079 --> 00:15:16,016
呼び出し規約を変え
コードサイズを抑えました

220
00:15:16,116 --> 00:15:18,752
最適化レベルも
追加しました

221
00:15:18,886 --> 00:15:20,854
Optimize for Sizeです

222
00:15:21,388 --> 00:15:25,459
ダウンロード制限など
アプリケーションの容量が

223
00:15:25,559 --> 00:15:28,395
重要な場合に有用です

224
00:15:29,029 --> 00:15:35,102
Swiftはプログラムの
静的知識を備えています

225
00:15:35,202 --> 00:15:39,139
コンパイラは
動作を最適化しやすく

226
00:15:39,239 --> 00:15:42,543
インライン展開や
脱仮想化など

227
00:15:42,643 --> 00:15:45,345
動作の改善に
役立っています

228
00:15:45,646 --> 00:15:48,949
しかし時に
それが不要な場合も

229
00:15:50,184 --> 00:15:54,087
これはソース互換性に
Osizeを適用した結果で

230
00:15:54,188 --> 00:15:58,625
GitHubのフレームワークと
アプリケーションを含みます

231
00:15:59,059 --> 00:16:05,132
コードサイズが
10～30％縮小されました

232
00:15:59,059 --> 00:16:05,132
コードサイズが
10～30％縮小されました

233
00:16:05,732 --> 00:16:11,338
Swiftコードをコンパイルした
機械語のサイズで

234
00:16:11,438 --> 00:16:16,009
アプリケーション全体の
サイズではありません

235
00:16:17,477 --> 00:16:21,915
ランタイムは
約５％遅くなります

236
00:16:22,015 --> 00:16:24,151
若干の損失ですね

237
00:16:24,251 --> 00:16:26,720
しかし支障はありません

238
00:16:26,820 --> 00:16:29,056
使用の目的によります

239
00:16:29,156 --> 00:16:32,392
興味があれば
試してみてください

240
00:16:34,361 --> 00:16:39,566
次はスラヴァがSwift 4.2の
言語改善点をお話しします

241
00:16:39,666 --> 00:16:45,806
(拍手)

242
00:16:45,906 --> 00:16:47,708
スラヴァ･ペーストフです

243
00:16:47,808 --> 00:16:53,213
Swift 4.2の新しい言語の
特性について話します

244
00:16:53,313 --> 00:16:56,350
シンプルで
管理しやすくなりました

245
00:16:57,451 --> 00:17:04,223
本題に移る前に まずは
言語改善の工程をお話しします

246
00:16:57,451 --> 00:17:04,223
本題に移る前に まずは
言語改善の工程をお話しします

247
00:17:04,391 --> 00:17:09,963
Swiftはオープンソースで
オープンデザインです

248
00:17:10,130 --> 00:17:13,200
もし言語改善の
アイデアがあれば

249
00:17:13,300 --> 00:17:15,502
フォーラムに書き込みます

250
00:17:15,602 --> 00:17:20,007
アイデアが注目され
試案をまとめたら

251
00:17:20,107 --> 00:17:24,377
アイデアを実装し
コアチームに提出できます

252
00:17:24,545 --> 00:17:29,616
評価中もコミュニティで
さらにフィードバックがあり

253
00:17:29,716 --> 00:17:33,954
チームが試案を
正式に受理するか決めます

254
00:17:34,721 --> 00:17:36,957
Swift Evolutionの
ページでは

255
00:17:37,057 --> 00:17:42,629
Swift 4.2に追加された
試案のリストが閲覧できます

256
00:17:43,297 --> 00:17:46,700
試案の数がとても多いので

257
00:17:46,800 --> 00:17:48,635
すべてはお話しできません

258
00:17:48,735 --> 00:17:52,406
しかし強調したいのは
多くの試案が

259
00:17:52,506 --> 00:17:56,343
コミュニティから
生まれたということです

260
00:17:56,510 --> 00:18:02,783
ユーザ間で共感できるような
言語の改善すべき点をあげ

261
00:17:56,510 --> 00:18:02,783
ユーザ間で共感できるような
言語の改善すべき点をあげ

262
00:18:02,883 --> 00:18:07,154
解決方法のアイデアを
出し合います

263
00:18:07,254 --> 00:18:11,859
皆さんの貢献で
Swiftが改善されるのです

264
00:18:12,059 --> 00:18:12,893
いいですね

265
00:18:12,993 --> 00:18:19,299
(拍手)

266
00:18:19,399 --> 00:18:26,140
最初の改良点は列挙型での
ボイラープレートの削除です

267
00:18:26,440 --> 00:18:28,408
例えば列挙型で

268
00:18:28,509 --> 00:18:33,146
データタイプのすべての値を
printと定義します

269
00:18:33,247 --> 00:18:37,384
Swift 4では
プロパティの定義で

270
00:18:37,484 --> 00:18:40,721
全型のリストも含めました

271
00:18:40,988 --> 00:18:46,927
新たな型を追加したら
プロパティの更新が必要です

272
00:18:47,060 --> 00:18:50,230
でないと正確な
動作が得られません

273
00:18:50,831 --> 00:18:56,770
コンパイラに繰り返し
同じ作業を課すことになります

274
00:18:56,870 --> 00:19:01,508
そこでCaseIterable
プロトコルが追加されました

275
00:18:56,870 --> 00:19:01,508
そこでCaseIterable
プロトコルが追加されました

276
00:19:01,608 --> 00:19:07,448
プロトコルを適合させれば
コンパイラが全型を作ります

277
00:19:08,115 --> 00:19:09,216
以上です

278
00:19:09,316 --> 00:19:13,587
(拍手)

279
00:19:13,687 --> 00:19:17,858
また別のボイラープレートも
削除しました

280
00:19:17,958 --> 00:19:22,062
ジェネリックコードを
作成できない場合です

281
00:19:22,596 --> 00:19:26,867
Swift 4の
containsメソッドでは

282
00:19:26,967 --> 00:19:30,938
その数列の要素型が
Equatableでなければ

283
00:19:31,038 --> 00:19:34,007
要素は見つけられません

284
00:19:34,541 --> 00:19:40,013
文字列がEquatableなので
その配列でも呼び出せます

285
00:19:40,114 --> 00:19:42,849
配列の配列内で呼び出すと

286
00:19:43,116 --> 00:19:47,955
整数の配列では要素型の
同値比較はできません

287
00:19:48,055 --> 00:19:50,958
コンパイル時間エラーが出ます

288
00:19:51,658 --> 00:19:56,964
ではライブラリが全配列を
Equatableとすればいい

289
00:19:57,064 --> 00:19:59,533
しかし それはいけません

290
00:19:59,633 --> 00:20:04,037
配列の要素型が
Equatableでない場合

291
00:19:59,633 --> 00:20:04,037
配列の要素型が
Equatableでない場合

292
00:20:04,137 --> 00:20:06,907
配列をEquatableには
できません

293
00:20:07,941 --> 00:20:10,911
配列の要素型が
Equatableならば

294
00:20:11,011 --> 00:20:16,717
配列の同じ動作が定義でき
要素の比較が可能です

295
00:20:17,050 --> 00:20:21,155
ライブラリは この
限定的な適合ができます

296
00:20:21,255 --> 00:20:27,261
要素型がEquatableなら
配列も同様になります

297
00:20:27,361 --> 00:20:31,665
Swift 4.2では今の例が
可能になりました

298
00:20:33,066 --> 00:20:39,239
また他の限定的な適合を
ライブラリで定義できます

299
00:20:39,339 --> 00:20:44,945
例えばOptionalと
DictionaryはEquatableです

300
00:20:45,045 --> 00:20:51,618
HashableやEncodable
Decodableも適合します

301
00:20:52,486 --> 00:20:53,120
そして…

302
00:20:53,220 --> 00:20:57,791
(拍手)

303
00:20:57,891 --> 00:21:02,596
今まで不可能だった
組み立てができます

304
00:20:57,891 --> 00:21:02,596
今まで不可能だった
組み立てができます

305
00:21:02,896 --> 00:21:07,568
Optional整数値の
配列があれば

306
00:21:07,768 --> 00:21:10,671
すべてが可能になります

307
00:21:12,306 --> 00:21:15,275
今週末のセッションでは

308
00:21:15,409 --> 00:21:22,216
限定的な適合や総合的な
改良点を詳しくお話しします

309
00:21:24,151 --> 00:21:27,988
次にEquatableとHashableの
定義について

310
00:21:28,522 --> 00:21:34,161
Swiftには多くのプロパティを持つ
構造体があり

311
00:21:34,261 --> 00:21:37,264
これらは
すべてEquatableです

312
00:21:37,364 --> 00:21:40,033
２つの値を比較するだけで

313
00:21:40,134 --> 00:21:43,303
構造体もEquatableにします

314
00:21:43,403 --> 00:21:46,974
Swift 4では
手入力が必要でした

315
00:21:47,074 --> 00:21:48,509
ボイラープレートです

316
00:21:48,609 --> 00:21:53,847
プロパティを追加したら
Equatableの更新も必要で

317
00:21:53,947 --> 00:21:57,518
その際に間違いが
起こりかねません

318
00:21:57,684 --> 00:22:03,190
Swift 4.1から同値比較の
実装が可能になりました

319
00:21:57,684 --> 00:22:03,190
Swift 4.1から同値比較の
実装が可能になりました

320
00:22:03,290 --> 00:22:06,894
実装しなくても
プロパティがEquatableならば

321
00:22:06,994 --> 00:22:10,430
コンパイラが
自動的に処理します

322
00:22:11,031 --> 00:22:13,033
Hashableも同様です

323
00:22:13,901 --> 00:22:16,069
ジェネリックタイプは？

324
00:22:16,170 --> 00:22:22,643
これはleftとrightの
インスタンスのデータ型です

325
00:22:22,843 --> 00:22:26,613
両方をEquatableに
制限したくありません

326
00:22:26,713 --> 00:22:32,786
関数やエラー non Equatableも
使用可能にするためです

327
00:22:32,920 --> 00:22:35,689
限定的な適合を宣言し―

328
00:22:35,789 --> 00:22:39,993
両方がそうなら
それぞれもEquatableとします

329
00:22:40,094 --> 00:22:41,995
これだけではありません

330
00:22:42,095 --> 00:22:44,865
同値比較の実装については

331
00:22:44,998 --> 00:22:47,768
正しいやり方は１つです

332
00:22:47,868 --> 00:22:50,938
どちらの値も同じ型か確認し

333
00:22:51,038 --> 00:22:54,341
ペイロードが同等かを
チェックします

334
00:22:54,675 --> 00:23:00,614
Swift 4.2ではコンパイラが
この合成作業を行います

335
00:22:54,675 --> 00:23:00,614
Swift 4.2ではコンパイラが
この合成作業を行います

336
00:23:01,148 --> 00:23:03,550
Hashableも同様です

337
00:23:04,952 --> 00:23:10,124
これで 例えば整数または
文字列のSetが持てます

338
00:23:11,825 --> 00:23:12,493
さて…

339
00:23:12,593 --> 00:23:15,996
(拍手)

340
00:23:16,096 --> 00:23:22,402
時に同値比較とハッシュ化を
手入力で行う場合があります

341
00:23:23,670 --> 00:23:25,772
例を見てみましょう

342
00:23:26,507 --> 00:23:29,643
都市を表す
データがあるとします

343
00:23:29,810 --> 00:23:34,515
都市名と州と人口が
情報としてあります

344
00:23:34,615 --> 00:23:37,284
この例での目的は１つ

345
00:23:37,384 --> 00:23:40,687
都市名と州を同値比較します

346
00:23:40,787 --> 00:23:44,258
同値であれば
人口のチェックは不要です

347
00:23:44,491 --> 00:23:48,896
もしコンパイラに
同値比較を実行させると

348
00:23:48,996 --> 00:23:53,433
不要な人口の比較も
してしまいます

349
00:23:53,767 --> 00:23:57,971
ここは手入力ができますし
簡単な作業です

350
00:23:58,605 --> 00:24:00,174
でもHashableは？

351
00:23:58,605 --> 00:24:00,174
でもHashableは？

352
00:24:01,208 --> 00:24:04,878
都市のハッシュコードを
計算する場合

353
00:24:04,978 --> 00:24:09,349
都市名と州の
ハッシュコードの計算と

354
00:24:09,449 --> 00:24:11,418
結合が必要です

355
00:24:11,552 --> 00:24:12,986
そのやり方は？

356
00:24:13,220 --> 00:24:16,390
非等価演算も使えますし

357
00:24:17,324 --> 00:24:22,930
演算式をネットで探したり
自分で考えたりもできます

358
00:24:23,263 --> 00:24:26,333
しかし
どちらも最善策ではなく

359
00:24:26,433 --> 00:24:30,704
ハッシュ結合も
分かりにくい機能です

360
00:24:30,804 --> 00:24:34,074
うまく使えない場合の
損害は大きく

361
00:24:34,174 --> 00:24:38,312
DictionaryやSetの
動作プロパティには

362
00:24:38,412 --> 00:24:41,748
高度なハッシュ機能が
求められます

363
00:24:42,216 --> 00:24:44,451
またセキュリティに関しても

364
00:24:44,551 --> 00:24:50,257
アタッカーがハッシュを
すべて同値にしてしまい

365
00:24:50,357 --> 00:24:53,126
アプリケーションに
送るとします

366
00:24:53,227 --> 00:24:58,332
アプリケーションがDoS攻撃で
使用できなくなります

367
00:24:58,432 --> 00:25:02,803
Swift 4.2はより良い
APIを導入しました

368
00:24:58,432 --> 00:25:02,803
Swift 4.2はより良い
APIを導入しました

369
00:25:03,370 --> 00:25:07,241
Swift 4と4.1の
Hashableプロトコルは

370
00:25:07,474 --> 00:25:12,079
１つのハッシュ値が
１つの整数値を生成します

371
00:25:12,346 --> 00:25:16,116
Swift 4.2は
プロトコルを改良し

372
00:25:16,216 --> 00:25:19,920
hash(into:) requirementを
加えました

373
00:25:20,020 --> 00:25:22,990
１つの値を
生成するのではなく

374
00:25:23,090 --> 00:25:25,759
インスタンスを取り出し

375
00:25:25,859 --> 00:25:31,765
複数の値を与え
ハッシュコードとして１つにします

376
00:25:32,166 --> 00:25:35,435
都市データの例に戻りますと

377
00:25:35,602 --> 00:25:40,174
都市名と州のhash(into:)を
再帰的に呼び出し―

378
00:25:40,274 --> 00:25:45,646
Hasherオブジェクトに
インスタンスを渡します

379
00:25:46,380 --> 00:25:47,147
すると―

380
00:25:48,115 --> 00:25:50,851
ハッシュアルゴリズムが

381
00:25:50,951 --> 00:25:55,289
ハッシュコードの質と
動作を調整してくれます

382
00:25:55,389 --> 00:25:58,892
DoS攻撃の
さらなる予防策として

383
00:25:58,992 --> 00:26:03,564
アプリケーション起動時には
乱数が使われます

384
00:25:58,992 --> 00:26:03,564
アプリケーション起動時には
乱数が使われます

385
00:26:05,365 --> 00:26:09,002
最新の
Hashableプロトコルを使えば

386
00:26:09,102 --> 00:26:13,006
コードの移行も
簡単なのでお勧めです

387
00:26:13,106 --> 00:26:15,609
１つだけ気をつけてください

388
00:26:15,709 --> 00:26:21,915
アプリケーションの実行間で
ハッシュ値や要素の順序は

389
00:26:22,015 --> 00:26:27,087
変わらないものと
期待するかもしれません

390
00:26:27,187 --> 00:26:30,524
しかし 乱数を使うので
そうはならず―

391
00:26:30,624 --> 00:26:32,426
コード修正が必要です

392
00:26:32,860 --> 00:26:36,730
そのためビルド設定を加えました

393
00:26:36,830 --> 00:26:39,500
Swift Deterministic Hashingの
環境変数です

394
00:26:39,600 --> 00:26:45,606
スキームエディタで選び
乱数を一時的に無効にします

395
00:26:47,040 --> 00:26:51,278
では乱数の生成について
話しましょう

396
00:26:52,279 --> 00:26:55,149
現状のSwiftで生成する場合

397
00:26:55,315 --> 00:26:58,252
インポートされた
C APIを使います

398
00:26:58,352 --> 00:27:03,357
プラットフォーム間で
名前や特性が異なるため

399
00:26:58,352 --> 00:27:03,357
プラットフォーム間で
名前や特性が異なるため

400
00:27:03,457 --> 00:27:05,592
理想的ではありません

401
00:27:05,692 --> 00:27:08,328
ビルド設定チェックが必要です

402
00:27:08,562 --> 00:27:14,968
しかし これらは低レベルで
実装が難しいのです

403
00:27:15,235 --> 00:27:19,306
例えば１から６の
数値を得たい場合

404
00:27:19,406 --> 00:27:23,644
Darwinのarc4randomが
使えます

405
00:27:23,744 --> 00:27:26,713
６で割った余りを計算するのです

406
00:27:26,813 --> 00:27:31,885
しかし１から６で
均等な結果となりません

407
00:27:32,252 --> 00:27:38,458
Swift 4.2では新しいAPIを
導入し改善しました

408
00:27:39,126 --> 00:27:43,363
まず数値型は
ランダムメソッドにより

409
00:27:43,464 --> 00:27:48,068
範囲内で均等な数値を
返すようになりました

410
00:27:48,168 --> 00:27:51,638
さらに浮動小数も
扱えるのです

411
00:27:52,773 --> 00:27:58,178
(拍手)

412
00:27:58,846 --> 00:28:04,551
Collectionプロトコルにも
確率要素を加えました

413
00:27:58,846 --> 00:28:04,551
Collectionプロトコルにも
確率要素を加えました

414
00:28:04,685 --> 00:28:11,859
空のCollectionを渡した場合は
null値が返されます

415
00:28:12,493 --> 00:28:15,729
最後にshuffleメソッドです

416
00:28:15,829 --> 00:28:21,935
対象のCollection要素の
乱数配列を可能にします

417
00:28:23,537 --> 00:28:28,008
デフォルトのRandom Number
Generatorを勧めますが

418
00:28:28,242 --> 00:28:30,210
それ以外でも構いません

419
00:28:30,611 --> 00:28:36,717
乱数生成プロトコルに
適合する型を書き込めば

420
00:28:36,817 --> 00:28:39,553
APIに渡すことができ

421
00:28:39,653 --> 00:28:45,425
乱数を生成する多重定義を
持つことができます

422
00:28:47,027 --> 00:28:53,200
ビルド設定チェックについて
もう少し詳しくお話しします

423
00:28:54,468 --> 00:28:56,870
よくあるパターンです

424
00:28:56,970 --> 00:29:01,875
iOSとmacOSで利用できる
Swiftコードがあります

425
00:28:56,970 --> 00:29:01,875
iOSとmacOSで利用できる
Swiftコードがあります

426
00:29:01,975 --> 00:29:05,379
iOSでUIkitを使うとします

427
00:29:05,479 --> 00:29:08,515
macOSではAppKitを使います

428
00:29:08,782 --> 00:29:13,854
まずは“#if”でコンパイル時間
チェックを書き込み

429
00:29:13,954 --> 00:29:18,091
UIkitが使える
OSをリストします

430
00:29:18,492 --> 00:29:23,297
重要なのは
どのOSで実行するかではなく

431
00:29:23,397 --> 00:29:25,432
UIkitのインポートです

432
00:29:25,532 --> 00:29:30,938
Swift 4.2では
importビルド設定命令を加え

433
00:29:31,572 --> 00:29:33,874
より使いやすくしました

434
00:29:33,974 --> 00:29:36,143
(拍手)

435
00:29:36,243 --> 00:29:41,014
Swift 4.2の新機能で
さらにコードを改善できます

436
00:29:41,115 --> 00:29:45,119
例えばAppKitも
チェックするとします

437
00:29:45,219 --> 00:29:48,088
UIkitもAppKitも
使えないような―

438
00:29:48,188 --> 00:29:50,257
例えばLinuxの場合

439
00:29:50,357 --> 00:29:56,163
“#error”ビルド命令を使い
エラーメッセージを作ります

440
00:29:57,464 --> 00:30:00,767
この次も
ボイラープレートです

441
00:29:57,464 --> 00:30:00,767
この次も
ボイラープレートです

442
00:30:01,535 --> 00:30:06,673
シミュレータで
条件付きコンパイルをする時

443
00:30:06,773 --> 00:30:13,547
Swift 4では すべてをコピー
ペーストしなければなりません

444
00:30:14,047 --> 00:30:18,685
Swift 4.2では
targetEnvironmentが使えます

445
00:30:18,786 --> 00:30:23,423
目的を明確にし
コンパイルしているのが―

446
00:30:23,524 --> 00:30:26,427
シミュレータなのか確認できます

447
00:30:26,793 --> 00:30:31,698
同時に FIXMEを“#warning”
ビルド命令に置き換え

448
00:30:31,832 --> 00:30:36,637
あとでFIXMEの修正を
忘れないようにします

449
00:30:37,971 --> 00:30:42,876
これで大体 新しい
機能の話は終わりました

450
00:30:42,976 --> 00:30:45,312
少しだけ別の話をします

451
00:30:45,913 --> 00:30:49,983
Implicitly Unwrapped Optionalに
関してです

452
00:30:50,217 --> 00:30:51,151
さて―

453
00:30:51,785 --> 00:30:55,289
Implicitly Unwrapped Optionalは
複雑です

454
00:30:55,689 --> 00:31:00,060
まずはメンタルモデルから
見ていきます

455
00:30:55,689 --> 00:31:00,060
まずはメンタルモデルから
見ていきます

456
00:31:00,160 --> 00:31:01,595
どういうものか？

457
00:31:01,895 --> 00:31:06,467
Swift 3より
式の型ではありません

458
00:31:06,567 --> 00:31:08,202
そうは考えません

459
00:31:08,302 --> 00:31:13,407
代わりに宣言の属性だと
考えてください

460
00:31:13,941 --> 00:31:17,678
こういった宣言を
まずコンパイラは―

461
00:31:17,778 --> 00:31:21,181
Optionalとして型検査します

462
00:31:21,281 --> 00:31:24,551
そこでつじつまが
合わない場合

463
00:31:24,651 --> 00:31:29,189
アンラップ後
マークをして型検査します

464
00:31:30,190 --> 00:31:32,826
例を見てみましょう

465
00:31:33,160 --> 00:31:34,795
関数が２つあります

466
00:31:34,895 --> 00:31:38,532
Implicitly Unwrapped
Optionalの整数と

467
00:31:38,632 --> 00:31:41,568
どんな型にも対応する値です

468
00:31:41,735 --> 00:31:45,606
１つ目の結果で
２つ目を呼び出します

469
00:31:45,839 --> 00:31:50,644
AnyにOptional整数値を
格納できるので

470
00:31:50,744 --> 00:31:53,313
強制アンラップは不要です

471
00:31:53,413 --> 00:31:56,316
値はOptionalになります

472
00:31:57,918 --> 00:32:00,320
２つ目の例を見ましょう

473
00:31:57,918 --> 00:32:00,320
２つ目の例を見ましょう

474
00:32:00,921 --> 00:32:04,858
ここで１つ目の関数は…
間違えました

475
00:32:04,958 --> 00:32:07,294
２つ目の関数は整数です

476
00:32:07,394 --> 00:32:11,865
従って １つ目の結果で
２つ目を呼び出しても

477
00:32:12,132 --> 00:32:16,403
整数のあるべき所に
Optional整数値を渡せません

478
00:32:16,503 --> 00:32:19,439
コンパイラが
強制アンラップして

479
00:32:19,706 --> 00:32:23,744
整数同士になるので
問題ありません

480
00:32:24,845 --> 00:32:29,883
このメンタルモデルでImplicitly
Unwrapped Optionalが説明できます

481
00:32:30,217 --> 00:32:35,989
しかし最近までモデルが
機能しない例外もありました

482
00:32:36,223 --> 00:32:42,029
別の型のImplicitly Unwrapped
Optionalは使えないからです

483
00:32:42,329 --> 00:32:44,631
Swift 4.2でも同じです

484
00:32:44,731 --> 00:32:48,635
Implicitly Unwrapped整数値の
配列は置けません

485
00:32:49,236 --> 00:32:53,774
しかしSwift 4で
こんなケースがありました

486
00:32:53,874 --> 00:32:59,213
Implicitly Unwrapped整数値でも
型エイリアスを定義でき

487
00:32:59,313 --> 00:33:02,115
配列を作ることができました

488
00:32:59,313 --> 00:33:02,115
配列を作ることができました

489
00:33:02,216 --> 00:33:07,254
しかしコンパイラの生成した
コードは 複雑でした

490
00:33:07,488 --> 00:33:11,725
Swift 4.2では
この機能を実装し直し

491
00:33:11,825 --> 00:33:16,130
メンタルモデルに
沿うようにしました

492
00:33:16,296 --> 00:33:21,135
ご覧のコードが
コンパイル時間の警告を出力し

493
00:33:21,235 --> 00:33:27,908
Optionalの整数値として
コンパイラが解析します

494
00:33:28,475 --> 00:33:33,914
極端なケースなので
通常のコードには影響しません

495
00:33:34,014 --> 00:33:37,084
しかし気になるようであれば

496
00:33:37,184 --> 00:33:40,487
Swift.orgの
ブログをご覧ください

497
00:33:40,587 --> 00:33:46,160
変更された点について
詳しい解説が載っています

498
00:33:47,294 --> 00:33:50,797
では最後の議題に移ります

499
00:33:50,898 --> 00:33:54,201
メモリへの
排他的チェックです

500
00:33:55,102 --> 00:34:01,475
Swift 4にもメモリの
排他的チェック機能がありました

501
00:33:55,102 --> 00:34:01,475
Swift 4にもメモリの
排他的チェック機能がありました

502
00:34:01,575 --> 00:34:05,312
コンパイル時間と
ランタイムのチェックです

503
00:34:05,412 --> 00:34:09,149
特定の動作の実行が
制限されました

504
00:34:09,248 --> 00:34:14,521
同じメモリを使っての
作業ができませんでした

505
00:34:14,788 --> 00:34:17,424
では例をご覧ください

506
00:34:18,625 --> 00:34:23,597
OSパスのデータ型を
実装するコードです

507
00:34:23,697 --> 00:34:27,367
パスコンポーネントの
配列です

508
00:34:27,534 --> 00:34:29,536
withAppendedメソッドで

509
00:34:30,204 --> 00:34:32,639
配列に要素を加えます

510
00:34:32,906 --> 00:34:35,476
クロージャを呼び出し

511
00:34:35,576 --> 00:34:38,011
配列から要素を除きます

512
00:34:38,178 --> 00:34:42,049
コードはSwift 4でも
有効です

513
00:34:42,750 --> 00:34:45,853
しかし パスのデータ型を見ると

514
00:34:46,420 --> 00:34:49,857
パスが局所変数に
格納されています

515
00:34:49,956 --> 00:34:52,125
withAppendedを呼び出し

516
00:34:52,226 --> 00:34:57,364
クロージャ内の局所変数を
再度表示します

517
00:34:57,464 --> 00:34:59,032
どこに問題が？

518
00:34:59,333 --> 00:35:03,070
コードが
あいまいになっています

519
00:34:59,333 --> 00:35:03,070
コードが
あいまいになっています

520
00:35:03,470 --> 00:35:07,574
クロージャ内の
局所変数にアクセスした時

521
00:35:07,674 --> 00:35:12,946
withAppendedにより
数値が変更されています

522
00:35:13,180 --> 00:35:15,549
あいまいな点はこうです

523
00:35:15,649 --> 00:35:21,388
withAppendedで呼び出す前の
パスの値を指すのか

524
00:35:21,488 --> 00:35:26,260
変更されたあとの
現在値を指すのかです

525
00:35:26,660 --> 00:35:32,532
Swift 4ではコンパイル
時間エラーとされていました

526
00:35:32,633 --> 00:35:37,137
これを解消するには
コンパイラに命令をします

527
00:35:37,237 --> 00:35:39,506
新しい値が得たいなら

528
00:35:39,606 --> 00:35:44,711
クロージャにパラメータとして
渡すだけです

529
00:35:45,846 --> 00:35:48,048
これを見てください

530
00:35:48,148 --> 00:35:51,852
ほぼ同じ機能ですが
ジェネリックで―

531
00:35:51,952 --> 00:35:54,988
パラメータが戻り値の型です

532
00:35:55,255 --> 00:36:02,496
この場合も クロージャ内の
パス値は同じくあいまいです

533
00:35:55,255 --> 00:36:02,496
この場合も クロージャ内の
パス値は同じくあいまいです

534
00:36:02,629 --> 00:36:07,234
Swift 4では このエラーを
察知できませんでした

535
00:36:08,168 --> 00:36:12,139
Swift 4.2では
排他的チェックを改善し

536
00:36:12,239 --> 00:36:15,609
この あいまいさを
察知します

537
00:36:16,477 --> 00:36:18,879
別の解決策としては

538
00:36:19,046 --> 00:36:24,385
パラメータとしてクロージャに
渡しても修正可能です

539
00:36:25,652 --> 00:36:27,988
この改善点に加えて

540
00:36:28,088 --> 00:36:33,160
リリースビルドにも
排他的チェックを追加しました

541
00:36:33,260 --> 00:36:37,197
パフォーマンスが重要でなければ

542
00:36:37,297 --> 00:36:40,467
永続的な使用をお勧めします

543
00:36:40,567 --> 00:36:45,672
今後 負荷が削減され
常に使えるレベルになれば

544
00:36:45,772 --> 00:36:50,043
さらなる保護機能として
役立つでしょう

545
00:36:50,144 --> 00:36:54,748
配列範囲のチェックや
整数オーバーフローと同じです

546
00:36:56,149 --> 00:37:00,788
今日お話しできなかったことも
多くあります

547
00:36:56,149 --> 00:37:00,788
今日お話しできなかったことも
多くあります

548
00:37:02,022 --> 00:37:05,392
アプリケーションで
試してください

549
00:37:05,492 --> 00:37:07,628
新たな機能を試し

550
00:37:07,728 --> 00:37:12,299
質問があれば
いつでも尋ねてください

551
00:37:12,466 --> 00:37:13,367
ありがとう

552
00:37:13,700 --> 00:37:19,540
(拍手)