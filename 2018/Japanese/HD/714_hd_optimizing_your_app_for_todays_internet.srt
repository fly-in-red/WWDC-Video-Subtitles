
1
00:00:07,140 --> 00:00:16,517
(音楽)

2
00:00:18,886 --> 00:00:26,326
(拍手)

3
00:00:26,894 --> 00:00:28,662
おはようございます

4
00:00:28,962 --> 00:00:32,299
今回 初めてWWDCに
参加される方は？

5
00:00:33,667 --> 00:00:37,871
毎年 新たな参加者が増えて
うれしいです

6
00:00:38,138 --> 00:00:41,742
私 スチュアートが
ネットワークの話をします

7
00:00:42,643 --> 00:00:47,848
まずはアプリケーションの
動作に関わるトピックです

8
00:00:47,948 --> 00:00:52,186
ネットワークを使わないAppは
ほぼ存在しないので

9
00:00:52,286 --> 00:00:56,323
最高のパフォーマンスを
引き出すことが重要です

10
00:00:56,423 --> 00:01:00,294
そのための技術を
いくつかご紹介します

11
00:00:56,423 --> 00:01:00,294
そのための技術を
いくつかご紹介します

12
00:01:01,228 --> 00:01:05,399
AppleのAPIを
有効活用するための―

13
00:01:05,699 --> 00:01:09,570
秘訣についても
皆さんにお教えします

14
00:01:09,670 --> 00:01:13,473
そして後半は
私の同僚のジテンが―

15
00:01:13,574 --> 00:01:18,478
URLSessionの詳細について
ご紹介します

16
00:01:21,048 --> 00:01:25,052
まずは最新の
ネットワークについてです

17
00:01:25,419 --> 00:01:31,058
インターネット利用者数は
いまや40億人まで増えました

18
00:01:31,158 --> 00:01:34,061
これは世界人口の半数以上で―

19
00:01:34,161 --> 00:01:37,497
ネットの使用量も
増え続けています

20
00:01:37,698 --> 00:01:43,170
ネット利用者数の増加率は
緩やかになりましたが

21
00:01:43,270 --> 00:01:48,342
インターネットの成長率は
降下してはいません

22
00:01:48,442 --> 00:01:54,181
M2MやIoT スマートホームなどで
進化を続けています

23
00:01:54,281 --> 00:01:57,484
インドや
中国の人々の間では―

24
00:01:58,185 --> 00:02:04,892
デスクトップ型パソコンが
あまり普及していません

25
00:01:58,185 --> 00:02:04,892
デスクトップ型パソコンが
あまり普及していません

26
00:02:04,992 --> 00:02:09,863
彼らはスマートフォンを
メインで使用しており―

27
00:02:10,830 --> 00:02:14,735
その通信規格は
2Gのままなのです

28
00:02:15,035 --> 00:02:20,774
この会場の皆さんが生み出す
アプリケーションは―

29
00:02:20,874 --> 00:02:25,112
ほとんどがLTEを想定した
仕様のはずです

30
00:02:25,379 --> 00:02:28,949
これは私たちにとって
不利な事実です

31
00:02:29,049 --> 00:02:32,853
LTE向けの
アプリケーションは―

32
00:02:33,420 --> 00:02:36,623
2Gでの操作性が
非常に悪いからです

33
00:02:36,924 --> 00:02:41,461
2Gでのパフォーマンスが
良いアプリケーションは―

34
00:02:41,562 --> 00:02:43,797
LTEだと最高の操作性です

35
00:02:43,997 --> 00:02:48,468
そこで速度の遅い環境の
プロパティを再現する―

36
00:02:48,569 --> 00:02:53,373
Network Link Conditionerを
ご紹介いたします

37
00:02:53,941 --> 00:02:58,111
このNLCを
必ず実行しながら―

38
00:02:58,212 --> 00:03:02,983
アプリケーションの
開発を進めてください

39
00:02:58,212 --> 00:03:02,983
アプリケーションの
開発を進めてください

40
00:03:03,417 --> 00:03:07,354
アプリケーションが
完成した後では手遅れです

41
00:03:07,454 --> 00:03:09,923
プログラミングに
ミスがあっても―

42
00:03:10,023 --> 00:03:14,595
開発途中なら
すぐに修正ができるからです

43
00:03:15,462 --> 00:03:20,801
Wiresharkやtcptraceを
使うことで操作性や―

44
00:03:20,901 --> 00:03:24,571
メモリとCPUの使用量を
確認できます

45
00:03:25,038 --> 00:03:29,643
tcptraceは
このようなグラフで―

46
00:03:29,743 --> 00:03:33,247
ネットワークの状況を
ひと目で確認できます

47
00:03:33,347 --> 00:03:37,317
詳しくは３年前の
セッションをご覧ください

48
00:03:39,453 --> 00:03:43,891
IPv6の使用量が
増え続けている理由は―

49
00:03:43,991 --> 00:03:49,229
IPv4より良い
性能を発揮するからです

50
00:03:49,329 --> 00:03:51,899
アプリケーションの
操作性には―

51
00:03:51,999 --> 00:03:57,337
ネイティブ方式のIPv6に
対応しているかも重要です

52
00:03:57,704 --> 00:04:01,475
IPv6が推奨されている
地域は多く―

53
00:03:57,704 --> 00:04:01,475
IPv6が推奨されている
地域は多く―

54
00:04:01,875 --> 00:04:06,413
アメリカでも87％の携帯が
IPv6向けです

55
00:04:06,647 --> 00:04:12,186
ほぼ同じ状況である
インドに焦点を当ててみます

56
00:04:12,553 --> 00:04:17,423
これは今年の初めに調査した
ネットワークのデータです

57
00:04:17,824 --> 00:04:21,394
インドの
携帯ネットワークで―

58
00:04:21,495 --> 00:04:27,134
TCP接続にかかる時間と
その往復遅延時間を表しています

59
00:04:27,234 --> 00:04:29,369
青い線がIPv6です

60
00:04:29,469 --> 00:04:34,107
例として75％の部分を
見てみましょう

61
00:04:34,208 --> 00:04:39,179
IPv6によるTCP接続の
75％が―

62
00:04:39,279 --> 00:04:42,216
0.15秒以下であることを
意味します

63
00:04:42,316 --> 00:04:47,254
一方 IPv4での接続時間は
0.325秒以上で―

64
00:04:47,354 --> 00:04:48,956
２倍以上の遅さです

65
00:04:49,056 --> 00:04:53,193
もしアプリケーションの
操作性を高めるなら―

66
00:04:53,293 --> 00:04:55,729
IPv6に対応してください

67
00:04:56,997 --> 00:04:59,333
他にもExplicit Congestion
Notificationで

68
00:04:59,433 --> 00:05:04,471
パケットロスや再送信を減らし
操作性を高められます

69
00:04:59,433 --> 00:05:04,471
パケットロスや再送信を減らし
操作性を高められます

70
00:05:04,805 --> 00:05:07,841
macOSやiOSには―

71
00:05:07,941 --> 00:05:11,311
数年前から実装されています

72
00:05:11,411 --> 00:05:13,247
特別な作業は不要ですが―

73
00:05:13,614 --> 00:05:17,284
ネットワークは
ECN対応にしてください

74
00:05:18,185 --> 00:05:22,523
Alexaで上位100万件の
Webサイトを調べると―

75
00:05:22,623 --> 00:05:26,960
そのうち77％が
ECN対応のサイトでした

76
00:05:27,060 --> 00:05:29,796
数年前より激増しています

77
00:05:32,833 --> 00:05:37,704
その他 操作性と
レジリエンス向上に有効なのが

78
00:05:37,804 --> 00:05:39,673
Multipath TCPです

79
00:05:39,773 --> 00:05:44,311
オフィスでWi-Fiが
つながっていても―

80
00:05:44,411 --> 00:05:47,781
屋外では
途切れることがあります

81
00:05:47,881 --> 00:05:53,086
その場合 従来のTCPは
再接続が必要でした

82
00:05:53,187 --> 00:05:58,926
Multipath TCPは経路を
パケットごとに決めるため―

83
00:05:59,159 --> 00:06:04,198
異なるインターフェイスへ
接続できるのです

84
00:05:59,159 --> 00:06:04,198
異なるインターフェイスへ
接続できるのです

85
00:06:05,833 --> 00:06:10,237
詳しくは昨年のセッションを
ご覧ください

86
00:06:10,337 --> 00:06:15,342
そして お使いのサーバが
マルチパス対応かもご確認を

87
00:06:16,109 --> 00:06:21,381
世界中の携帯キャリアを
調査した結果―

88
00:06:21,481 --> 00:06:28,555
78％がMultipath TCPを
利用したネットワークでした

89
00:06:28,655 --> 00:06:32,259
未対応のままなのは
たった22％です

90
00:06:34,561 --> 00:06:37,598
TCP Fast Openは―

91
00:06:37,698 --> 00:06:42,803
TCPの往復遅延を
改善してくれる技術です

92
00:06:42,903 --> 00:06:45,939
TCP接続確立パケットに―

93
00:06:46,039 --> 00:06:50,944
初回のデータを含めることが
可能になります

94
00:06:52,546 --> 00:06:56,383
詳細は３年前の
セッションをご覧ください

95
00:06:56,483 --> 00:06:58,452
そして お使いのサーバが―

96
00:06:58,552 --> 00:07:02,456
TCP Fast Open対応か
ご確認ください

97
00:06:58,552 --> 00:07:02,456
TCP Fast Open対応か
ご確認ください

98
00:07:03,423 --> 00:07:06,160
次は新しい情報です

99
00:07:07,127 --> 00:07:11,832
QUICという技術を
ご存知の方もいるでしょう

100
00:07:11,999 --> 00:07:16,236
ここ30年来で
初めて開発された―

101
00:07:16,336 --> 00:07:19,640
TCPに代わる
新しいプロトコルです

102
00:07:19,740 --> 00:07:23,410
Googleの
エンジニアが開発し―

103
00:07:23,510 --> 00:07:25,412
その成果も検証済みです

104
00:07:25,512 --> 00:07:27,281
現在はIETFによって―

105
00:07:27,381 --> 00:07:30,984
QUICの標準化が
検討されています

106
00:07:31,919 --> 00:07:34,321
Appleのエンジニアも―

107
00:07:34,421 --> 00:07:39,059
スウェーデンで開催中の
会議に参加しています

108
00:07:40,093 --> 00:07:45,299
標準化はまだ先の話ですが
我々は準備を進めています

109
00:07:45,399 --> 00:07:49,803
準備が整い次第
我々のAPIも対応します

110
00:07:51,238 --> 00:07:53,507
他にも操作性の観点から―

111
00:07:54,308 --> 00:07:57,244
よくある事象に気づきました

112
00:07:57,344 --> 00:08:01,748
ウェブサイトで使われる
DNSレコードは―

113
00:07:57,344 --> 00:08:01,748
ウェブサイトで使われる
DNSレコードは―

114
00:08:01,849 --> 00:08:04,551
持続時間が短いものばかりです

115
00:08:04,651 --> 00:08:08,288
それは データセンターが
ダウンした際に―

116
00:08:08,388 --> 00:08:14,261
DNSを更新し 別のセンターに
迅速にアクセスするためです

117
00:08:15,195 --> 00:08:21,502
しかし コストをかけて
この対策を行っても―

118
00:08:21,602 --> 00:08:24,905
センターは
めったにダウンしません

119
00:08:25,005 --> 00:08:30,110
そのためDNSレコードが
期限切れになるたびに

120
00:08:30,210 --> 00:08:33,947
サーバからの応答を
待たねばならず

121
00:08:34,047 --> 00:08:39,620
余分な往復遅延時間が
かかることになります

122
00:08:39,720 --> 00:08:45,592
では 私たちにできる
最適な方法は何なのか？

123
00:08:45,826 --> 00:08:49,329
それをご説明しましょう

124
00:08:49,429 --> 00:08:55,269
例えばキャッシュに
古い情報があった場合―

125
00:08:55,369 --> 00:09:00,507
すぐさま同時進行で
DNSクエリを実行します

126
00:08:55,369 --> 00:09:00,507
すぐさま同時進行で
DNSクエリを実行します

127
00:09:00,607 --> 00:09:03,844
DNSの情報を照会するのです

128
00:09:04,511 --> 00:09:08,949
予想どおりの
応答が得られれば―

129
00:09:09,049 --> 00:09:13,987
そのまま接続ができ
データ往復の時間が省けます

130
00:09:14,354 --> 00:09:21,028
違うアドレスで応答があると
非同期通知が送られ―

131
00:09:21,128 --> 00:09:24,565
新たなアドレスで
再接続を行います

132
00:09:24,665 --> 00:09:29,303
Happy Eyeballsと
連動させることで―

133
00:09:29,403 --> 00:09:32,840
並列的な接続が可能です

134
00:09:32,940 --> 00:09:37,744
IPv6 IPv4 複数のアドレスや
インターフェイスを試します

135
00:09:38,512 --> 00:09:43,650
皆さんがお考えのとおり
これは大変な作業です

136
00:09:44,051 --> 00:09:48,822
この作業を簡単に行える
新たなAPIについて―

137
00:09:48,922 --> 00:09:52,759
後ほどご紹介いたします

138
00:09:54,495 --> 00:09:56,597
次はガイダンスです

139
00:09:56,697 --> 00:10:00,300
SCNetwork
Reachabilityで―

140
00:09:56,697 --> 00:10:00,300
SCNetwork
Reachabilityで―

141
00:10:00,400 --> 00:10:05,806
事前チェックを行う
デベロッパも多いでしょう

142
00:10:06,373 --> 00:10:08,575
ネットワークの運用が―

143
00:10:08,675 --> 00:10:12,513
うまくいくかどうかを
確認するためです

144
00:10:12,613 --> 00:10:17,117
しかし先のことを
予見するのは大変です

145
00:10:17,217 --> 00:10:19,453
今はうまく接続しても―

146
00:10:19,553 --> 00:10:24,791
２秒後にはWi-Fiの電波が
途切れるかもしれません

147
00:10:24,892 --> 00:10:30,030
運用が成功する保証は
どこにもないのです

148
00:10:30,497 --> 00:10:35,969
運用がうまくいくまで
失敗を繰り返すのも―

149
00:10:36,069 --> 00:10:38,205
日常茶飯事です

150
00:10:38,539 --> 00:10:42,042
ネットワークプロキシの
設定も―

151
00:10:42,142 --> 00:10:46,747
とても複雑で
負担の大きい作業です

152
00:10:47,514 --> 00:10:49,316
その悩みを解決しましょう

153
00:10:51,885 --> 00:10:57,825
waitsForConnectivityで
作業負荷を減らせます

154
00:10:58,759 --> 00:11:03,297
詳細は昨年のセッションを
ご覧ください

155
00:10:58,759 --> 00:11:03,297
詳細は昨年のセッションを
ご覧ください

156
00:11:03,397 --> 00:11:06,700
このシステムに
接続を要請するだけです

157
00:11:06,800 --> 00:11:09,203
タイミングは問いません

158
00:11:09,303 --> 00:11:14,575
デバイスが機内モードの場合
設定を解除すれば接続されます

159
00:11:14,675 --> 00:11:18,512
リトライ処理を行うより
はるかに簡単です

160
00:11:19,079 --> 00:11:23,183
ユーザに多数の質問に
回答してもらう際―

161
00:11:23,283 --> 00:11:27,454
有効であるという
開発時のケースがあります

162
00:11:27,554 --> 00:11:33,560
処理が失敗しても ユーザの
時間を無駄にしたくないですね

163
00:11:34,128 --> 00:11:37,531
休憩後のセッションで
詳細をお伝えします

164
00:11:37,631 --> 00:11:40,567
改善策をお知らせします

165
00:11:43,370 --> 00:11:46,340
セキュリティ面も重要です

166
00:11:47,341 --> 00:11:50,711
TLS1.2が普及して
10年が経ちました

167
00:11:50,811 --> 00:11:54,882
より安全性の高い
TLS 1.3への移行準備が―

168
00:11:55,315 --> 00:11:57,951
すでに始まっています

169
00:11:58,051 --> 00:12:02,689
TLS 1.3は
接続時間も短く済みます

170
00:11:58,051 --> 00:12:02,689
TLS 1.3は
接続時間も短く済みます

171
00:12:03,457 --> 00:12:08,462
標準規格化に向けて
最終調整をしており―

172
00:12:08,562 --> 00:12:12,132
公表文書の最終稿も
IESGに認証されました

173
00:12:12,566 --> 00:12:17,671
RFCエディタより
正式文書が刊行されたら―

174
00:12:17,838 --> 00:12:22,543
初期設定をTLS 1.3に
切り替える予定です

175
00:12:23,310 --> 00:12:26,680
今すぐにTLS 1.3を
試したい方は―

176
00:12:27,147 --> 00:12:31,585
iOSやmacOSの説明書を
ご参照ください

177
00:12:31,685 --> 00:12:35,923
アプリケーションを
TLS 1.3規格に更新できます

178
00:12:36,023 --> 00:12:42,896
規格がデフォルトになった時点で
互換性の問題が発覚しないよう

179
00:12:42,996 --> 00:12:46,166
なるべく早めにお試しください

180
00:12:46,266 --> 00:12:52,306
切り替え時期が来る前に
動作確認を終えてください

181
00:12:55,509 --> 00:13:00,113
Certificate Transparencyも
セキュリティ対策の１つです

182
00:12:55,509 --> 00:13:00,113
Certificate Transparencyも
セキュリティ対策の１つです

183
00:13:00,514 --> 00:13:05,853
悪意からか無能ゆえか
認証局が不正な証明書を

184
00:13:05,953 --> 00:13:11,692
適切でない相手に
発行する場合があります

185
00:13:12,459 --> 00:13:17,130
この解決策が
“証明書の透明性ログ”です

186
00:13:17,531 --> 00:13:22,803
認証局が発行した
すべての証明書に―

187
00:13:22,903 --> 00:13:25,472
証跡が残るのです

188
00:13:25,572 --> 00:13:29,610
その証跡は第三者の
監査ログに記載されます

189
00:13:30,143 --> 00:13:35,916
ポリシー外の認証局から
不正に発行された証明書は

190
00:13:36,216 --> 00:13:39,386
すぐに検知されます

191
00:13:40,454 --> 00:13:43,991
証明書が未発行の場合も
同様です

192
00:13:44,958 --> 00:13:48,262
なじみのある
セットアップですね

193
00:13:48,362 --> 00:13:50,998
新しいのはログです

194
00:13:51,098 --> 00:13:55,569
認証局が
証明書を発行すると―

195
00:13:55,669 --> 00:14:00,340
監査ログに
その証跡が記録されます

196
00:13:55,669 --> 00:14:00,340
監査ログに
その証跡が記録されます

197
00:14:00,440 --> 00:14:07,047
サーバは接続時に
ログから取得した証跡を―

198
00:14:07,214 --> 00:14:09,616
クライアントに提示します

199
00:14:09,716 --> 00:14:13,086
クライアントは
その証明書が―

200
00:14:13,187 --> 00:14:16,256
公的に記録され
署名されたと確認できます

201
00:14:16,890 --> 00:14:19,560
このポリシー外の認証局が―

202
00:14:20,027 --> 00:14:24,364
不正な証明書を
発行したと想定します

203
00:14:24,631 --> 00:14:28,869
クライアントは
ログを確認することで―

204
00:14:28,969 --> 00:14:32,005
この証明書が不正だと
検知できます

205
00:14:33,006 --> 00:14:36,310
私たちは今年の終わりに―

206
00:14:37,411 --> 00:14:40,747
新たなTLS証明書を
発行します

207
00:14:40,848 --> 00:14:42,816
ログの検証による―

208
00:14:42,916 --> 00:14:47,454
不正な証明書の検知も
可能です

209
00:14:47,554 --> 00:14:51,291
アプリケーションの改訂は
要りません

210
00:14:51,391 --> 00:14:56,396
独自のサーバ証明書を
お持ちの場合は―

211
00:14:56,497 --> 00:15:00,467
適切にログが記載されるか
ご確認ください

212
00:14:56,497 --> 00:15:00,467
適切にログが記載されるか
ご確認ください

213
00:15:01,468 --> 00:15:05,706
ハードウェアについても
お知らせがあります

214
00:15:06,240 --> 00:15:09,243
Bonjour
Conformance Testで―

215
00:15:09,343 --> 00:15:13,947
Bonjourが適切に
実装されているかが分ります

216
00:15:14,414 --> 00:15:19,853
Bonjourの商標を使う際は
ぜひ試してください

217
00:15:20,220 --> 00:15:27,561
Windowsのアプリケーションに
Bonjourを実装する際も同様です

218
00:15:27,661 --> 00:15:32,866
AirPrintやAirPlayなどの商標を
商品に使用する際も

219
00:15:32,966 --> 00:15:34,868
このテストが必須です

220
00:15:34,968 --> 00:15:37,871
Bonjourの信頼性の高さが―

221
00:15:37,971 --> 00:15:41,308
その商品の根幹になるからです

222
00:15:41,975 --> 00:15:46,180
そしてテストで
さらに重要なのは―

223
00:15:46,280 --> 00:15:51,285
皆さんの商品の質を
高めるということです

224
00:15:51,385 --> 00:15:55,989
それが顧客の満足に
つながり―

225
00:15:56,089 --> 00:15:59,126
皆さんの幸せにつながります

226
00:15:59,226 --> 00:16:03,831
顧客が信頼できる商品と
快適に暮らせることが

227
00:15:59,226 --> 00:16:03,831
顧客が信頼できる商品と
快適に暮らせることが

228
00:16:04,264 --> 00:16:06,833
私たちの望みです

229
00:16:09,636 --> 00:16:11,939
次はAPIの話です

230
00:16:12,639 --> 00:16:16,343
30年前はBSDソケットが
一般的でした

231
00:16:16,443 --> 00:16:18,879
当時にしては優れものです

232
00:16:18,979 --> 00:16:24,384
しかし30年前には
携帯端末はもちろん―

233
00:16:24,484 --> 00:16:28,288
ワイヤレス接続や
IPv6もありませんでした

234
00:16:29,289 --> 00:16:32,693
PCの複数台接続や―

235
00:16:32,793 --> 00:16:37,264
イーサネットのポートがある
PCも珍しかったのです

236
00:16:37,364 --> 00:16:43,637
いまや40億人もの人々が
電源管理を行いつつ

237
00:16:43,737 --> 00:16:48,375
IPv6対応のモバイル端末を
持ち歩く時代です

238
00:16:48,475 --> 00:16:50,878
世界は複雑化しています

239
00:16:52,045 --> 00:16:57,384
ソケット通信のサービスを
お使いの方もいれば―

240
00:16:57,684 --> 00:17:01,155
URLSessionを
お使いの方もいるでしょう

241
00:16:57,684 --> 00:17:01,155
URLSessionを
お使いの方もいるでしょう

242
00:17:01,255 --> 00:17:06,960
URLSessionはソケット通信と
大差ないと思いますか？

243
00:17:07,928 --> 00:17:10,097
それは間違いです

244
00:17:10,830 --> 00:17:15,502
URLSessionはAppleの
ユーザ空間を使って―

245
00:17:15,602 --> 00:17:18,204
設計されています

246
00:17:18,305 --> 00:17:21,040
iOS 12からは―

247
00:17:21,141 --> 00:17:25,212
URLSessionと同じ
APIが使用されます

248
00:17:25,311 --> 00:17:29,449
お持ちの
アプリケーションから―

249
00:17:29,550 --> 00:17:33,387
TCP接続などのため
直接使用可能です

250
00:17:33,487 --> 00:17:38,926
URLやGETメソッドを使ってる方は
ご検討ください

251
00:17:39,026 --> 00:17:44,531
URLSession非対応の
アプリケーション用に―

252
00:17:44,631 --> 00:17:47,234
フレームワークも
公開しています

253
00:17:47,868 --> 00:17:51,305
BSDソケットで設計された
ライブラリを―

254
00:17:51,405 --> 00:17:55,375
開発されている方も
いるでしょう

255
00:17:55,475 --> 00:17:59,479
その場合はNetwork.framework
APIを使ってください

256
00:17:59,580 --> 00:18:04,751
ライブラリを高性能な
APIに移行いただき―

257
00:17:59,580 --> 00:18:04,751
ライブラリを高性能な
APIに移行いただき―

258
00:18:04,852 --> 00:18:08,288
ぜひフィードバックを
お寄せください

259
00:18:08,856 --> 00:18:13,927
2018年は
BSDソケットの利用を―

260
00:18:14,027 --> 00:18:18,532
やめることを
強くおすすめします

261
00:18:18,632 --> 00:18:23,604
BSDソケット系統の
ライブラリも同様です

262
00:18:23,704 --> 00:18:30,611
そして古いAPIをお使いの方も
切り替えをご検討ください

263
00:18:30,844 --> 00:18:35,449
今日の午後もしくは明日
我々のラボで―

264
00:18:35,549 --> 00:18:39,453
移行に関するフィードバックを
お待ちしています

265
00:18:39,987 --> 00:18:42,923
次は同僚のジテンが―

266
00:18:43,023 --> 00:18:46,994
URLSessionの詳細を
ご説明します

267
00:18:47,094 --> 00:18:52,366
(拍手)

268
00:18:52,466 --> 00:18:53,567
ありがとう

269
00:18:54,201 --> 00:18:55,602
おはようございます

270
00:18:55,702 --> 00:18:59,673
CFNetworkのエンジニア
ジテンです

271
00:19:00,174 --> 00:19:04,478
今日は皆さんに最適な
ネットワークをご紹介します

272
00:19:05,312 --> 00:19:08,782
アプリケーションに
ネットワークは不可欠です

273
00:19:09,283 --> 00:19:13,253
新たな開発に
尽力されている皆さんに―

274
00:19:13,353 --> 00:19:17,824
ネットワークの詳細を
簡単にお話しします

275
00:19:17,925 --> 00:19:20,494
きっと役立つはずです

276
00:19:23,063 --> 00:19:28,435
これから 待機時間の削減
処理量や反応性の向上

277
00:19:28,669 --> 00:19:32,706
システムリソースの
有効活用といった―

278
00:19:33,006 --> 00:19:35,742
４つの項目について話します

279
00:19:36,743 --> 00:19:41,949
その前に簡単に
URLSessionのおさらいです

280
00:19:45,485 --> 00:19:50,557
URLSessionはApple推奨の
高性能APIで―

281
00:19:50,657 --> 00:19:53,427
Appleのプラットフォームで
利用可能です

282
00:19:54,394 --> 00:19:58,799
第一推奨の利用環境は
HTTP/2と―

283
00:19:59,066 --> 00:20:01,235
HTTP/1.1です

284
00:19:59,066 --> 00:20:01,235
HTTP/1.1です

285
00:20:02,336 --> 00:20:05,606
アプリケーションが
HTTP非対応の場合は―

286
00:20:05,706 --> 00:20:08,041
URLSessionStreamTaskをどうぞ

287
00:20:08,308 --> 00:20:13,146
そうすれば
任意のプロトコルで―

288
00:20:13,247 --> 00:20:16,316
サーバへの
TCP接続が可能になります

289
00:20:17,484 --> 00:20:19,086
おさらいは以上です

290
00:20:19,620 --> 00:20:24,358
では 待機時間の削減の
トピックに移りましょう

291
00:20:25,292 --> 00:20:29,463
あなたは友人と
レストランを訪れ―

292
00:20:29,563 --> 00:20:32,232
店員に水を頼んだとします

293
00:20:32,666 --> 00:20:36,670
店員があなたに
水を持ってきたところで―

294
00:20:36,937 --> 00:20:39,973
友人も水を頼みました

295
00:20:40,073 --> 00:20:44,444
店員は再び歩きさり
友人に水を持ってきました

296
00:20:44,545 --> 00:20:47,681
店員が水を一度に
持ってくれば―

297
00:20:47,781 --> 00:20:49,950
往復時間が省けるはずです

298
00:20:50,751 --> 00:20:52,953
リソース取得までの―

299
00:20:53,453 --> 00:20:57,024
往復時間を減らす場合も
考え方は同様です

300
00:20:57,658 --> 00:20:59,626
アプリケーションの動きは？

301
00:21:02,095 --> 00:21:05,899
このプロトコルは
HTTP/1.1です

302
00:21:06,867 --> 00:21:08,769
リソースを取得するため―

303
00:21:09,336 --> 00:21:13,640
URLSessionで
タスクを開始します

304
00:21:14,141 --> 00:21:17,578
するとDNSやTCP
TLSを含んだ―

305
00:21:17,678 --> 00:21:21,615
新たな接続が作成されます

306
00:21:22,616 --> 00:21:27,154
サーバに接続したら
リクエストを送り―

307
00:21:28,455 --> 00:21:31,959
サーバからの応答を待ちます

308
00:21:32,593 --> 00:21:38,899
この間 アプリケーションに
待機時間が発生するのです

309
00:21:40,567 --> 00:21:44,004
応答が得られたら
終了ブロックか―

310
00:21:44,104 --> 00:21:47,875
デリゲートで
ロードを終了させます

311
00:21:49,309 --> 00:21:54,314
ロード中に別のリソースを
取得することも可能です

312
00:21:55,449 --> 00:22:00,554
その場合はURLSessionで
別のタスクを作成し―

313
00:21:55,449 --> 00:22:00,554
その場合はURLSessionで
別のタスクを作成し―

314
00:22:00,654 --> 00:22:03,590
接続プールに
ムダな接続がない状態で

315
00:22:03,690 --> 00:22:07,127
リソース取得のために
新たに接続します

316
00:22:08,128 --> 00:22:13,634
さらに他のリソースを
取得したい場合も同様に―

317
00:22:13,734 --> 00:22:18,272
URLSessionで
別のタスクを作成します

318
00:22:19,406 --> 00:22:22,142
ここでは同じサーバから

319
00:22:22,242 --> 00:22:26,647
３つの接続で
異なるリソースを取得しています

320
00:22:27,714 --> 00:22:31,518
初回の接続には
時間を要しましたが―

321
00:22:32,486 --> 00:22:36,457
これが単一接続だったら
どうでしょう

322
00:22:38,659 --> 00:22:40,761
単一接続の場合です

323
00:22:40,928 --> 00:22:45,866
初回の接続時間は短いですが
別の問題があります

324
00:22:46,567 --> 00:22:49,536
２つ目の緑色のタスクは―

325
00:22:49,636 --> 00:22:53,574
最初のタスクの完了まで
待機が必要です

326
00:22:54,141 --> 00:22:56,844
３つ目の
オレンジ色のタスクも―

327
00:22:56,944 --> 00:23:02,649
２つ目のタスクが終わるまで
待機が必要です

328
00:22:56,944 --> 00:23:02,649
２つ目のタスクが終わるまで
待機が必要です

329
00:23:03,750 --> 00:23:07,221
これがヘッドオブ
ラインブロッキングです

330
00:23:08,355 --> 00:23:14,361
実は新規格のHTTP/2も
単一接続を行いますが―

331
00:23:14,461 --> 00:23:18,265
この問題への
回避策が備わっています

332
00:23:19,299 --> 00:23:24,571
HTTP/2は１つの接続上で
ストリームを多重化し―

333
00:23:24,671 --> 00:23:29,543
複数の送受信を
並列的に行えるのです

334
00:23:31,078 --> 00:23:34,915
HTTP/2がHTTP/1.1より
優れていることを―

335
00:23:35,015 --> 00:23:37,684
例を見て分析しましょう

336
00:23:39,653 --> 00:23:43,724
複数のリソースを
取得するまでの―

337
00:23:43,824 --> 00:23:46,427
所要時間に注目してください

338
00:23:47,094 --> 00:23:51,432
HTTP/1.1では
明らかな遅延が

339
00:23:51,532 --> 00:23:56,537
リソース取得のリクエストが
送られるまでに発生しています

340
00:23:57,571 --> 00:24:01,275
一方のHTTP/2は―

341
00:23:57,571 --> 00:24:01,275
一方のHTTP/2は―

342
00:24:01,375 --> 00:24:04,511
遅れが少なく 迅速に―

343
00:24:04,611 --> 00:24:07,181
リクエストが送られています

344
00:24:10,250 --> 00:24:13,020
グレーの部分にも
注目してください

345
00:24:13,387 --> 00:24:16,256
先ほどお話ししたとおり―

346
00:24:16,356 --> 00:24:21,228
サーバからの応答を待つ
待機時間が生じてしまいます

347
00:24:22,930 --> 00:24:27,134
HTTP/2では
この待機時間が削減され―

348
00:24:27,234 --> 00:24:32,906
バンド幅を有効に使い
迅速なロードが可能になるのです

349
00:24:35,742 --> 00:24:40,547
HTTP/2がHTTP/1.1より
優れている点を―

350
00:24:40,647 --> 00:24:42,382
簡単におさらいします

351
00:24:43,150 --> 00:24:47,387
HTTP/2はヘッドオブライン
ブロッキングを解消し―

352
00:24:47,654 --> 00:24:51,258
バンド幅を有効利用できます

353
00:24:52,192 --> 00:24:57,331
すでにURLSessionを
お使いの方は―

354
00:24:57,931 --> 00:25:02,703
そのままの状態で
HTTP/2の恩恵を受けられます

355
00:24:57,931 --> 00:25:02,703
そのままの状態で
HTTP/2の恩恵を受けられます

356
00:25:04,037 --> 00:25:08,308
HTTP/2はサーバへの
接続回数も少ないので―

357
00:25:08,408 --> 00:25:13,814
サーバ側の負担が軽く済む
メリットもあります

358
00:25:15,115 --> 00:25:18,519
今年からURLSessionに―

359
00:25:18,619 --> 00:25:22,089
HTTP/2の強みを生かす
技術が加わります

360
00:25:24,157 --> 00:25:26,960
HTTP/2 Connection
Coalescingについて―

361
00:25:27,060 --> 00:25:28,695
ご紹介します

362
00:25:30,030 --> 00:25:31,999
この技術のおかげで―

363
00:25:32,099 --> 00:25:35,502
より強力な接続が
可能になります

364
00:25:36,803 --> 00:25:41,542
毎回 接続をオープンにする
やり取りが不要なため―

365
00:25:41,642 --> 00:25:44,878
さらに反応が速くなるのです

366
00:25:45,913 --> 00:25:47,881
HTTP/2 Connection Coalescingは

367
00:25:48,949 --> 00:25:52,653
URLSessionに対応した
アプリケーションでは

368
00:25:52,753 --> 00:25:55,422
自動適用されます

369
00:25:56,557 --> 00:26:00,727
接続の再利用方法を
見てみましょう

370
00:25:56,557 --> 00:26:00,727
接続の再利用方法を
見てみましょう

371
00:26:03,497 --> 00:26:04,998
アプリケーションが―

372
00:26:05,365 --> 00:26:10,204
リソースの取得を
要求したとします

373
00:26:10,704 --> 00:26:15,275
サーバへ接続をすると
証明書が発行されました

374
00:26:16,043 --> 00:26:20,514
さらに他のリソースを
取得する場合は―

375
00:26:20,614 --> 00:26:24,551
別の接続をオープンにし
新たな証明書が発行されます

376
00:26:25,419 --> 00:26:28,589
これは従来の
URLSessionで―

377
00:26:28,689 --> 00:26:33,594
複数のリソースを取得する
手順と同じです

378
00:26:34,828 --> 00:26:39,700
しかし よく見ると
最初の証明書によって―

379
00:26:39,800 --> 00:26:43,504
すべてのサブドメインが
網羅されています

380
00:26:44,004 --> 00:26:46,707
delivery.example.comに

381
00:26:46,807 --> 00:26:49,376
最初の証明書が
適用されているのです

382
00:26:50,277 --> 00:26:53,413
さらに最初の接続と同じ
IPアドレスで―

383
00:26:53,514 --> 00:26:57,217
処理されていることも
分かります

384
00:26:58,385 --> 00:27:00,687
同一のエンドポイントが

385
00:26:58,385 --> 00:27:00,687
同一のエンドポイントが

386
00:27:00,787 --> 00:27:04,558
接続を再利用しているので
安全です

387
00:27:04,658 --> 00:27:08,729
新たな接続のオープンが
不要なため―

388
00:27:09,062 --> 00:27:13,734
待機時間が
大幅に短縮されるのです

389
00:27:15,269 --> 00:27:19,006
HTTP/2 Connection
Coalescingは―

390
00:27:19,106 --> 00:27:22,643
iOS 12とmacOS Mojaveに
搭載されています

391
00:27:23,677 --> 00:27:28,081
URLSessionの
オブジェクトによる―

392
00:27:28,182 --> 00:27:30,184
処理速度を見てみます

393
00:27:32,920 --> 00:27:38,225
先ほどご紹介した
接続の恩恵を受けるには―

394
00:27:38,458 --> 00:27:44,665
同じURLSessionを
利用する必要があります

395
00:27:47,267 --> 00:27:52,673
URLSessionは
接続プールが可能なので

396
00:27:52,773 --> 00:27:58,278
オブジェクトを複数作成すると
メリットは感じられません

397
00:27:59,046 --> 00:28:02,549
また自明でない
メモリフットプリントを―

398
00:27:59,046 --> 00:28:02,549
また自明でない
メモリフットプリントを―

399
00:28:02,649 --> 00:28:07,087
URLSessionで作成すると
コストがかかります

400
00:28:07,988 --> 00:28:11,058
そのためURLSessionの
オブジェクトは―

401
00:28:11,158 --> 00:28:13,827
少ないほうが良いのです

402
00:28:15,729 --> 00:28:20,100
次は処理量の向上について
お話しします

403
00:28:21,668 --> 00:28:23,504
レストランで―

404
00:28:23,937 --> 00:28:25,739
こう注文したとします

405
00:28:25,839 --> 00:28:29,276
“グリルチキンと
トマトとタマネギに―”

406
00:28:29,376 --> 00:28:32,946
“バターたっぷりの
ソースを添えて”

407
00:28:33,881 --> 00:28:35,516
言いにくいですね

408
00:28:35,616 --> 00:28:38,886
“バターチキン”と
注文すれば十分です

409
00:28:39,920 --> 00:28:43,857
リソース取得時の
送信バイトを減らし―

410
00:28:43,957 --> 00:28:47,194
処理量を
向上させるのも同様です

411
00:28:47,294 --> 00:28:49,396
実際にお見せします

412
00:28:51,598 --> 00:28:54,968
リクエストのサイズを
減らす方法です

413
00:28:56,270 --> 00:28:59,039
HTTP cookieに
注目してください

414
00:28:59,139 --> 00:29:04,278
cookieは すべての
リクエストにおいて―

415
00:28:59,139 --> 00:29:04,278
cookieは すべての
リクエストにおいて―

416
00:29:05,179 --> 00:29:10,350
ドメインとパス属性で
ひも付けられています

417
00:29:10,450 --> 00:29:13,020
サイズが膨大になる原因です

418
00:29:13,921 --> 00:29:17,791
ドメインとパス属性を
効果的に使えば―

419
00:29:17,891 --> 00:29:21,628
cookieとリクエストが
適切に照合されます

420
00:29:22,463 --> 00:29:26,934
小さいcookieを使い
適宜 削除すれば―

421
00:29:28,168 --> 00:29:33,574
クライアント側のcookieの数を
減らすことができます

422
00:29:34,775 --> 00:29:39,713
HTTP/2に移行すれば
ヘッダ圧縮も可能です

423
00:29:40,981 --> 00:29:43,684
圧縮について
詳しく説明します

424
00:29:45,986 --> 00:29:49,790
HTTP圧縮はサーバと
クライアント間で―

425
00:29:50,424 --> 00:29:55,696
行き交うデータを
圧縮する手法です

426
00:29:56,063 --> 00:29:58,899
これにより
情報量が増加します

427
00:29:59,700 --> 00:30:02,135
URLSessionでは―

428
00:29:59,700 --> 00:30:02,135
URLSessionでは―

429
00:30:02,236 --> 00:30:06,306
GzipとBrotliを
推奨しています

430
00:30:07,207 --> 00:30:11,345
Gzipは汎用性が高く
処理速度も速いです

431
00:30:11,912 --> 00:30:14,214
Brotliは昨年 iOS 11と―

432
00:30:14,314 --> 00:30:17,785
macOS High Sierraで
導入されました

433
00:30:18,619 --> 00:30:22,589
構造化テキストや
HTMLなどの―

434
00:30:22,723 --> 00:30:26,427
小さなデータの圧縮に
Brotliは最適です

435
00:30:27,661 --> 00:30:31,932
ぜひ この圧縮方法を
サーバに適用ください

436
00:30:33,300 --> 00:30:35,836
次にご紹介する項目は―

437
00:30:36,370 --> 00:30:38,472
反応性の向上についてです

438
00:30:39,173 --> 00:30:41,308
再びレストランに戻ります

439
00:30:41,808 --> 00:30:46,046
あなたはWWDCで
旧友と再会する予定です

440
00:30:46,980 --> 00:30:49,583
２人はテーブルに
座っていて―

441
00:30:49,683 --> 00:30:52,486
ドリンクは
すでに手元にあります

442
00:30:52,586 --> 00:30:55,656
食事前に旧友と
近況報告をするため―

443
00:30:56,089 --> 00:30:57,925
あなたは店員に言います

444
00:30:58,025 --> 00:31:01,728
“食事はゆっくり
出してもらえますか？”

445
00:30:58,025 --> 00:31:01,728
“食事はゆっくり
出してもらえますか？”

446
00:31:02,196 --> 00:31:04,598
別タスクの実行中に―

447
00:31:04,698 --> 00:31:09,570
特定のタスクを
優先させる場合も同様です

448
00:31:10,104 --> 00:31:12,439
実際に見てみましょう

449
00:31:15,609 --> 00:31:19,413
５つのQoSと
NSOperationが―

450
00:31:19,513 --> 00:31:23,050
関連しているのは
ご存じだと思います

451
00:31:23,617 --> 00:31:26,520
スケジューリングポリシーに
沿っています

452
00:31:27,521 --> 00:31:31,758
URLSessionは
“QoS-aware”で

453
00:31:31,859 --> 00:31:36,463
task.resumeを呼ぶキューで
QoSをキャプチャします

454
00:31:37,064 --> 00:31:42,002
送られるメッセージは
QoSを優先します

455
00:31:43,237 --> 00:31:44,638
例を見ましょう

456
00:31:45,272 --> 00:31:49,143
緊急でないデータを
取得する場合―

457
00:31:49,309 --> 00:31:53,947
バックグラウンドの
QoSが働きます

458
00:31:54,047 --> 00:31:57,351
優先度の高いタスクを
妨げないように―

459
00:31:57,451 --> 00:32:00,954
処理してくれるのです

460
00:31:57,451 --> 00:32:00,954
処理してくれるのです

461
00:32:04,158 --> 00:32:09,797
URLSessionの
オブジェクトによって―

462
00:32:10,164 --> 00:32:13,700
ネットワークトラフィックが
分類され

463
00:32:14,268 --> 00:32:18,272
タスクに優先順位が
つけられるのです

464
00:32:19,540 --> 00:32:23,777
“responsiveData”を
今年から導入します

465
00:32:24,578 --> 00:32:30,818
defaultTypeより高度なので
上手に活用しましょう

466
00:32:31,452 --> 00:32:34,521
responsiveDataは

467
00:32:34,822 --> 00:32:39,093
通販サイトで清算する時にも
便利です

468
00:32:39,526 --> 00:32:42,029
支払い請求書の情報を―

469
00:32:42,129 --> 00:32:46,733
すぐにサーバから
呼び出す時などに便利です

470
00:32:48,368 --> 00:32:52,940
Ciscoのファストレーンを
使うことで―

471
00:32:53,040 --> 00:32:57,377
記録されたタグを
いつでも呼び出せます

472
00:32:58,045 --> 00:33:00,347
このAPIの詳細は―

473
00:32:58,045 --> 00:33:00,347
このAPIの詳細は―

474
00:33:00,447 --> 00:33:04,952
2016年のWWDCのセッションで
ご確認ください

475
00:33:08,055 --> 00:33:13,126
昨年 URLSessionのAPIで
導入したのが―

476
00:33:13,327 --> 00:33:14,995
waitsForConnectivityです

477
00:33:15,963 --> 00:33:19,099
タスクの実行中に
接続が切れても―

478
00:33:19,199 --> 00:33:23,871
タスクを待機させてくれます

479
00:33:24,605 --> 00:33:27,908
従来 リクエストの
事前チェックには―

480
00:33:28,008 --> 00:33:31,011
STNetworkReachabilityが
主流でした

481
00:33:31,111 --> 00:33:35,082
しかしスチュアートが
指摘したとおり

482
00:33:35,182 --> 00:33:38,685
サーバの接続中に
タスクが競合しがちです

483
00:33:38,786 --> 00:33:41,255
いざリクエストを
実行すると―

484
00:33:41,355 --> 00:33:44,291
接続が切れてることも
あります

485
00:33:45,826 --> 00:33:48,829
waitsFor
Connectivityを使えば―

486
00:33:48,929 --> 00:33:53,000
有効なサーバに
すぐリクエストを送れます

487
00:33:53,967 --> 00:33:59,173
また taskIsWaitingFor
Connectivityのメソッドを

488
00:33:59,273 --> 00:34:02,342
接続がない状態で
呼び出せます

489
00:33:59,273 --> 00:34:02,342
接続がない状態で
呼び出せます

490
00:34:03,243 --> 00:34:06,547
このためユーザは
違う操作をしたり―

491
00:34:06,647 --> 00:34:10,484
UIをオフラインに
することができます

492
00:34:11,652 --> 00:34:13,719
このAPIの詳細は―

493
00:34:13,821 --> 00:34:18,859
昨年のWWDCの内容を
ご参照ください

494
00:34:20,661 --> 00:34:22,963
最後の項目は―

495
00:34:23,063 --> 00:34:25,998
システムリソースの
有効活用です

496
00:34:26,600 --> 00:34:28,601
再びレストランの例です

497
00:34:29,803 --> 00:34:34,274
あなたは料理が気に入り
明日も来たくなりました

498
00:34:35,007 --> 00:34:39,246
しかし このレストランは
宅配も行っており―

499
00:34:39,346 --> 00:34:42,649
注文した翌日に
料理を届けてくれます

500
00:34:42,750 --> 00:34:47,286
顧客の時間と労力が
宅配によって節約され―

501
00:34:47,387 --> 00:34:51,891
店側も仕事の優先順位が
つけられます

502
00:34:52,492 --> 00:34:57,764
システムリソースの
有効活用も同じ考えです

503
00:35:00,400 --> 00:35:01,602
バックグラウンドで―

504
00:35:01,702 --> 00:35:03,871
アップロードと
ダウンロードをします

505
00:35:04,405 --> 00:35:06,974
システムが状況に応じて―

506
00:35:07,074 --> 00:35:10,878
ロードの中断や
再開をしてくれます

507
00:35:10,978 --> 00:35:16,049
バッテリーやCPU
Wi-Fi環境で判断するのです

508
00:35:17,951 --> 00:35:20,420
バックグラウンド
セッションは―

509
00:35:20,521 --> 00:35:22,756
大容量データに有効です

510
00:35:23,724 --> 00:35:27,394
これらのタスクは
プロセス外で実行され

511
00:35:27,494 --> 00:35:32,199
アプリケーションが停止中も
ダウンロードが続きます

512
00:35:33,333 --> 00:35:35,502
本件に関する詳細は―

513
00:35:35,602 --> 00:35:39,540
2014年のセッションを
ご参照ください

514
00:35:42,776 --> 00:35:45,612
キャッシュで待機時間は
削減されます

515
00:35:46,213 --> 00:35:50,551
しかしディスクI/Oでしか
効果を発揮できません

516
00:35:51,351 --> 00:35:57,124
現実世界のアプリケーションは
日々 大容量のデータを扱い

517
00:35:57,224 --> 00:36:00,027
フラッシュストレージが
劣化します

518
00:35:57,224 --> 00:36:00,027
フラッシュストレージが
劣化します

519
00:36:01,128 --> 00:36:05,599
固有のコンテンツに
キャッシュは不向きなのです

520
00:36:06,033 --> 00:36:09,269
あなたが
マッチングアプリの―

521
00:36:09,436 --> 00:36:12,105
ネットワークコードの
責任者だとします

522
00:36:13,040 --> 00:36:17,878
ユーザのプロフィールを
高画質でロードします

523
00:36:18,479 --> 00:36:22,216
この高画質な画像の
読み込みに―

524
00:36:22,316 --> 00:36:26,119
キャッシュを用いるのは
ムダです

525
00:36:26,219 --> 00:36:28,689
ユーザは
いろんな人の画像を―

526
00:36:28,789 --> 00:36:31,358
次々と閲覧していくからです

527
00:36:32,392 --> 00:36:36,763
willCacheResponseを
実装すれば―

528
00:36:36,864 --> 00:36:40,701
キャッシュするリソースを
判断してくれます

529
00:36:41,869 --> 00:36:46,106
自身のサーバをお持ちなら
Cache-Controlヘッダを

530
00:36:46,206 --> 00:36:49,243
ぜひ お試しください

531
00:36:51,879 --> 00:36:54,882
今日のポイントを
おさらいします

532
00:36:55,349 --> 00:36:59,153
レストランでは
一度に全部の注文をする

533
00:36:59,820 --> 00:37:01,488
今のは冗談です

534
00:36:59,820 --> 00:37:01,488
今のは冗談です

535
00:37:01,588 --> 00:37:04,458
HTTP/2は
ヘッダを圧縮したり―

536
00:37:04,558 --> 00:37:08,395
ヘッドオブライン
ブロッキングを解消できます

537
00:37:10,030 --> 00:37:13,567
URLSessionの
オブジェクトを減らせば―

538
00:37:13,667 --> 00:37:15,669
待機時間を減らせます

539
00:37:15,769 --> 00:37:20,941
メモリフットプリントも削減し
リソースの活用がより効率的に

540
00:37:22,576 --> 00:37:26,179
リクエストのサイズ削減で
処理速度を最大にします

541
00:37:27,614 --> 00:37:32,085
QoSでアプリケーションの
反応性も向上します

542
00:37:32,186 --> 00:37:35,756
システムリソースの
有効活用の鍵は―

543
00:37:35,856 --> 00:37:38,492
バックグラウンドセッションです

544
00:37:39,860 --> 00:37:43,364
詳しい情報は
ウェブサイトをご覧ください

545
00:37:43,697 --> 00:37:46,533
少し休憩をはさんだ後に―

546
00:37:46,633 --> 00:37:51,138
ソケットの代わりとなる
新たなフレームワークを紹介します

547
00:37:51,238 --> 00:37:56,276
我々のラボにも
ぜひお立ち寄りください

548
00:37:57,511 --> 00:38:01,248
皆さんの
ご参加に感謝します

549
00:37:57,511 --> 00:38:01,248
皆さんの
ご参加に感謝します

550
00:38:01,348 --> 00:38:04,284
(拍手)