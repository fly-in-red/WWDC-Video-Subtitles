
1
00:00:07,074 --> 00:00:16,450
(音楽)

2
00:00:20,754 --> 00:00:21,955
(拍手)

3
00:00:22,055 --> 00:00:22,990
どうも

4
00:00:24,791 --> 00:00:25,626
ありがとう

5
00:00:26,593 --> 00:00:27,794
こんにちは 皆さん

6
00:00:27,895 --> 00:00:31,331
私はフィル･アザール　Appleの
ソフトウェアエンジニアです

7
00:00:31,765 --> 00:00:34,034
今日は同僚のデビッドと共に

8
00:00:34,134 --> 00:00:37,538
Energy Debuggingの
新しい特長をご紹介します

9
00:00:40,574 --> 00:00:43,243
バッテリー寿命は極めて重要です

10
00:00:43,343 --> 00:00:44,845
Power Teamが目指すのは

11
00:00:44,945 --> 00:00:49,816
バッテリーの充電なしに
１日を過ごせることです

12
00:00:50,884 --> 00:00:55,088
寿命を最適化すべく
デベロッパと協力し

13
00:00:55,189 --> 00:00:59,026
エネルギー効率の良い
デザインを目指しています

14
00:01:00,494 --> 00:01:03,330
アプリケーションも
カスタマーには重要です

15
00:01:03,430 --> 00:01:07,868
デバイスの使用状況は
他社製のアプリケーションの影響を

16
00:01:07,968 --> 00:01:09,369
ダイレクトに受けます

17
00:01:09,469 --> 00:01:12,739
アプリケーションの
デザインにあたっては

18
00:01:12,840 --> 00:01:17,978
これまで以上に エネルギー効率が
重要になります

19
00:01:18,745 --> 00:01:21,748
今日のテーマは３つです

20
00:01:22,950 --> 00:01:28,055
１つ目は エネルギー効率を
確実に高めるための

21
00:01:28,155 --> 00:01:31,091
バッテリー寿命の
コンセプトについて

22
00:01:31,925 --> 00:01:35,662
次にツールをいくつかご紹介します

23
00:01:35,929 --> 00:01:39,833
これでエネルギーを定量化し
理解できます

24
00:01:40,133 --> 00:01:45,205
３つ目は Energy Debuggingを
進化させるための

25
00:01:45,305 --> 00:01:47,841
新しいツールの説明です

26
00:01:48,775 --> 00:01:52,412
まずは一般的なコンセプトからです

27
00:01:53,113 --> 00:01:55,148
バッテリー寿命の向上には

28
00:01:55,249 --> 00:02:00,587
まずバッテリー寿命とは何たるかを
理解すべきです

29
00:01:55,249 --> 00:02:00,587
まずバッテリー寿命とは何たるかを
理解すべきです

30
00:02:01,288 --> 00:02:02,256
始めましょう

31
00:02:04,258 --> 00:02:05,292
エネルギーとは？

32
00:02:06,093 --> 00:02:11,165
物理の観点によれば
それは力と時間による産物です

33
00:02:11,732 --> 00:02:16,970
アプリケーションの実行中
消費されるエネルギーは様々です

34
00:02:17,604 --> 00:02:21,475
実行する内容で
消費量が異なります

35
00:02:22,009 --> 00:02:27,481
また 消費の時間が長いと
消費量も増えます

36
00:02:27,814 --> 00:02:29,416
グラフで見ましょう

37
00:02:30,117 --> 00:02:35,055
アプリケーションの実行中
電力の消費に波があります

38
00:02:35,923 --> 00:02:39,092
折線の下のエリアが
エネルギーです

39
00:02:39,693 --> 00:02:43,363
これは様々なモードに関わる話です

40
00:02:44,731 --> 00:02:50,237
アクティブかアイドルかによって
消費電力量は異なります

41
00:02:50,838 --> 00:02:54,675
アクティブな時
電力は山の頂点に達します

42
00:02:55,175 --> 00:02:59,780
アプリケーション本来の機能が
直接 使われるからです

43
00:03:00,214 --> 00:03:04,685
アイドル状態かつ起動中の時は
消費量が減ります

44
00:03:06,119 --> 00:03:10,424
停止中も一定の電力が
消費されています

45
00:03:11,024 --> 00:03:12,492
興味深いです

46
00:03:13,560 --> 00:03:16,497
アプリケーションは
処理の実行時―

47
00:03:16,597 --> 00:03:21,201
必要なハードウェアを
システムに要求します

48
00:03:21,935 --> 00:03:27,374
その際に生じるエネルギーを
オーバーヘッドと呼びます

49
00:03:28,075 --> 00:03:30,744
直接は制御できないものの

50
00:03:30,844 --> 00:03:32,746
アプリケーションは
オーバーヘッドを

51
00:03:32,913 --> 00:03:34,515
大きく左右します

52
00:03:35,816 --> 00:03:39,119
ハードウェアの
最初の利用時に生じるのが

53
00:03:39,219 --> 00:03:40,821
アクティブエネルギーです

54
00:03:41,121 --> 00:03:44,057
サブシステムを使うことで

55
00:03:44,158 --> 00:03:48,595
アプリケーションはラジオや
カメラなどにアクセスできます

56
00:03:49,263 --> 00:03:52,232
これが アクティブエネルギーです

57
00:03:53,033 --> 00:03:54,701
バッテリー寿命には

58
00:03:54,968 --> 00:03:58,572
２つの要素の最適化が
重要です

59
00:03:58,839 --> 00:04:04,011
アクティブエネルギーの効率性や
ハードウェアの要求に伴う―

60
00:03:58,839 --> 00:04:04,011
アクティブエネルギーの効率性や
ハードウェアの要求に伴う―

61
00:04:04,111 --> 00:04:08,482
オーバーヘッドについても
考えねばなりません

62
00:04:11,118 --> 00:04:15,589
ハードウェアや
サブシステムについて触れましたが

63
00:04:15,923 --> 00:04:18,524
エネルギー消費の肝は？

64
00:04:18,926 --> 00:04:22,696
皆さんは数多くの
ハードウェアサブシステムと

65
00:04:22,796 --> 00:04:24,698
向き合うはずです

66
00:04:25,833 --> 00:04:28,302
効率化に貢献するサブシステムを

67
00:04:28,402 --> 00:04:31,138
Power Teamは４つ挙げました

68
00:04:32,639 --> 00:04:34,007
こちらです

69
00:04:34,741 --> 00:04:38,545
プロセッシング ネットワーキング
ロケーション グラフィックスです

70
00:04:39,780 --> 00:04:42,149
具体的に見てみましょう

71
00:04:43,417 --> 00:04:45,486
プロセッシングは想像がつきます

72
00:04:46,386 --> 00:04:51,625
アプリケーションが CPUなどの
システム資源を利用する時に

73
00:04:51,725 --> 00:04:54,394
消費されるエネルギーを生みます

74
00:04:55,162 --> 00:04:57,130
非常に強力な要素です

75
00:04:57,598 --> 00:05:00,801
ここでのエネルギーは
実行されるコードや―

76
00:04:57,598 --> 00:05:00,801
ここでのエネルギーは
実行されるコードや―

77
00:05:00,901 --> 00:05:05,005
要求するワークロードに
強く依存します

78
00:05:06,006 --> 00:05:10,010
つまり 実行される処理が
増えるほどに

79
00:05:10,110 --> 00:05:12,913
消費エネルギーも増えるのです

80
00:05:14,648 --> 00:05:20,420
エネルギー消費を語る上で
ネットワーキングも重要です

81
00:05:22,322 --> 00:05:24,625
これは想像できるでしょう

82
00:05:24,858 --> 00:05:27,528
アプリケーションが
セルラーやWi-Fiを通じ

83
00:05:27,628 --> 00:05:30,130
通信を要求する際には

84
00:05:30,230 --> 00:05:33,100
エネルギーを消費します

85
00:05:34,368 --> 00:05:36,236
これはトラフィックに依存し―

86
00:05:36,436 --> 00:05:40,274
通信量が多ければ多いほど

87
00:05:40,374 --> 00:05:42,009
消費エネルギーも増えます

88
00:05:43,544 --> 00:05:47,047
ネットワークリクエストが増えれば

89
00:05:47,147 --> 00:05:49,383
消費エネルギーも増えるのです

90
00:05:51,018 --> 00:05:53,287
ロケーションは少し異なります

91
00:05:54,321 --> 00:05:58,258
アプリケーションは
ロケーションの決定時に

92
00:05:58,659 --> 00:06:04,198
GPSやWi-Fi セルラーを用いて
エネルギーを消費します

93
00:05:58,659 --> 00:06:04,198
GPSやWi-Fi セルラーを用いて
エネルギーを消費します

94
00:06:05,899 --> 00:06:09,436
消費量は
正確性と頻度に依存します

95
00:06:10,037 --> 00:06:15,242
ロケーションの決定が
正確かつ高頻度に行われれば

96
00:06:15,542 --> 00:06:18,712
消費エネルギーも増えます

97
00:06:20,347 --> 00:06:24,418
ロケーションの決定に
時間をかけると

98
00:06:24,518 --> 00:06:27,387
消費量が増えるわけです

99
00:06:30,357 --> 00:06:32,593
最後はグラフィックスです

100
00:06:33,994 --> 00:06:38,966
グラフィックサブシステムでは
GPUやCPUといったプロセッサが

101
00:06:39,066 --> 00:06:41,902
エネルギーの消費に関わります

102
00:06:42,636 --> 00:06:45,205
アニメーションや
UIに依存します

103
00:06:45,772 --> 00:06:50,244
UIのレンダリングや
アニメーション表示には

104
00:06:50,344 --> 00:06:52,913
エネルギーの消費を伴います

105
00:06:54,181 --> 00:06:56,183
複雑の度合いが鍵です

106
00:06:56,750 --> 00:06:59,253
アニメーションやUIが複雑なら

107
00:06:59,353 --> 00:07:02,222
消費エネルギーも増えます

108
00:06:59,353 --> 00:07:02,222
消費エネルギーも増えます

109
00:07:03,957 --> 00:07:08,428
要は レンダリング量が
多ければ多いほど

110
00:07:08,529 --> 00:07:13,066
グラフィックスの
消費エネルギーは増えるのです

111
00:07:15,769 --> 00:07:19,706
まとめると 注意すべきなのは？

112
00:07:19,806 --> 00:07:23,110
これら４つには
共通原則があります

113
00:07:23,944 --> 00:07:26,680
“処理が増えれば
エネルギーも増える”

114
00:07:28,248 --> 00:07:32,252
ただ闇雲に処理を減らせば
機能が低下します

115
00:07:32,819 --> 00:07:38,392
大事なのは処理を最適化し
エネルギー効率を高めること

116
00:07:40,460 --> 00:07:41,929
簡単ではありません

117
00:07:42,629 --> 00:07:45,399
エネルギー効率には
プロセスが伴います

118
00:07:45,899 --> 00:07:49,136
突然 最適化して
効率が上がり―

119
00:07:49,236 --> 00:07:53,640
バッテリー寿命が
延びるわけではありません

120
00:07:54,808 --> 00:07:56,977
複数のリソースを

121
00:07:57,077 --> 00:08:01,048
効率的に使うことが重要なのです

122
00:07:57,077 --> 00:08:01,048
効率的に使うことが重要なのです

123
00:08:02,649 --> 00:08:07,287
この点を踏まえ
実際の例を見ていきましょう

124
00:08:07,387 --> 00:08:11,592
エネルギー効率の
プロセスを実戦してみます

125
00:08:12,593 --> 00:08:14,628
フォアグラウンドの場合です

126
00:08:15,529 --> 00:08:19,600
フォアグラウンドでの
ユーザ体験は

127
00:08:19,700 --> 00:08:23,070
アプリケーションの
最も重要な要素です

128
00:08:23,437 --> 00:08:24,638
そう考えると―

129
00:08:25,572 --> 00:08:29,843
フォアグラウンドでは
提供する価値に着目し

130
00:08:30,143 --> 00:08:35,148
ユーザ体験に
即時に影響するべきです

131
00:08:35,816 --> 00:08:39,385
実行するのは
求められた処理だけ

132
00:08:40,053 --> 00:08:41,587
シンプルですね

133
00:08:42,054 --> 00:08:46,126
実際に その重要性を
見ていきましょう

134
00:08:47,294 --> 00:08:49,363
メディアアプリケーションの場合

135
00:08:49,563 --> 00:08:54,968
目的は 一定のペースで
コンテンツを配信することです

136
00:08:55,469 --> 00:08:58,639
タイマーベースの手法を
取り入れ

137
00:08:58,739 --> 00:09:01,742
フィードのリフレッシュも可能です

138
00:08:58,739 --> 00:09:01,742
フィードのリフレッシュも可能です

139
00:09:02,142 --> 00:09:04,745
ユーザの操作がなくとも

140
00:09:04,845 --> 00:09:08,081
常に新しいコンテンツを
提供します

141
00:09:09,216 --> 00:09:13,720
しかし これは
エネルギー非効率です

142
00:09:14,888 --> 00:09:18,926
ここで電力と時間の関係を見ます

143
00:09:19,026 --> 00:09:24,231
タイマーが機能時に
エネルギーが消費されています

144
00:09:25,165 --> 00:09:28,969
注目すべきは
膨大なオーバーヘッドです

145
00:09:29,503 --> 00:09:32,973
新しいコンテンツの表示が
要求されると

146
00:09:33,073 --> 00:09:36,143
ネットワーキングやグラフィックス

147
00:09:36,443 --> 00:09:40,013
プロセッシングなどの
サブシステムが呼び出されます

148
00:09:40,113 --> 00:09:42,082
ユーザの要望に関わらずです

149
00:09:42,182 --> 00:09:46,253
実行中 エネルギーは
消費され続けます

150
00:09:47,321 --> 00:09:48,422
解決できます

151
00:09:49,690 --> 00:09:52,960
ユーザの求める
フレッシュなコンテンツには

152
00:09:53,160 --> 00:09:56,263
オンデマンドのソリューションが
有効です

153
00:09:57,231 --> 00:10:02,269
ユーザの操作あるいは
サーバからの通知を通して

154
00:09:57,231 --> 00:10:02,269
ユーザの操作あるいは
サーバからの通知を通して

155
00:10:02,369 --> 00:10:05,806
新しいコンテンツを表示できます

156
00:10:07,608 --> 00:10:10,878
エネルギー効率の高いこの方法は

157
00:10:10,978 --> 00:10:14,047
電力と時間の関係を
劇的に変えます

158
00:10:14,314 --> 00:10:15,616
なぜでしょう

159
00:10:16,383 --> 00:10:20,454
フォアグラウンドでの操作中に

160
00:10:20,554 --> 00:10:24,057
フィードを
リフレッシュするとします

161
00:10:24,358 --> 00:10:28,328
この時 アプリケーションは
アイドル状態です

162
00:10:28,695 --> 00:10:31,431
スクロールしたり
している時などです

163
00:10:32,065 --> 00:10:36,503
オーバーヘッドは
かなり小さくなっています

164
00:10:36,937 --> 00:10:38,572
不要なサブシステムを

165
00:10:38,672 --> 00:10:42,676
スリープ状態か
アイドル状態にしたからです

166
00:10:45,512 --> 00:10:49,983
他にもフォアグラウンドにおいて
有効なのは

167
00:10:50,517 --> 00:10:52,519
複雑なUIの最小化です

168
00:10:53,287 --> 00:10:58,926
グラフィックスのエネルギー消費は
複雑さに強く依存します

169
00:10:59,827 --> 00:11:02,196
私たちは魅力的なUIや

170
00:10:59,827 --> 00:11:02,196
私たちは魅力的なUIや

171
00:11:02,296 --> 00:11:07,701
アニメーションの構築に
時間を費やそうとしますが

172
00:11:08,635 --> 00:11:11,004
これは時に副作用を伴います

173
00:11:11,705 --> 00:11:14,041
理由を見ていきましょう

174
00:11:15,576 --> 00:11:19,446
動画プレーヤーの目的は
動画を見せること

175
00:11:19,913 --> 00:11:20,747
シンプルです

176
00:11:21,148 --> 00:11:25,285
しかし 新しいUIを
付加したくもなります

177
00:11:25,385 --> 00:11:30,123
関連する動画やスクラバー
コントロールなどです

178
00:11:30,791 --> 00:11:33,494
動画鑑賞を楽しむ上で

179
00:11:33,594 --> 00:11:36,430
大きく貢献してくれます

180
00:11:37,831 --> 00:11:40,500
しかし エネルギー効率は低いです

181
00:11:41,134 --> 00:11:42,736
なぜでしょうか

182
00:11:43,570 --> 00:11:46,874
デバイスには
スクリーンにUIがない時に

183
00:11:46,974 --> 00:11:51,745
ディスプレイを最適化する機能が
備わっています

184
00:11:52,446 --> 00:11:56,016
開発中は気付きにくいですが

185
00:11:56,116 --> 00:11:58,385
重要なことです

186
00:11:59,620 --> 00:12:02,556
この最適化を利用して

187
00:11:59,620 --> 00:12:02,556
この最適化を利用して

188
00:12:02,656 --> 00:12:06,393
エネルギー非効率を
解消するために

189
00:12:07,161 --> 00:12:10,898
UIのコントロールを
自動で無効にします

190
00:12:12,132 --> 00:12:16,103
これで ユーザが
操作を行っていない時は

191
00:12:16,203 --> 00:12:19,873
関連のコンテンツは
現れなくなります

192
00:12:20,674 --> 00:12:24,511
ディスプレイの最適化は
非常に重要です

193
00:12:24,745 --> 00:12:30,350
動画再生時のエネルギー効率を
大きく高めてくれます

194
00:12:33,687 --> 00:12:36,957
バックグラウンドでは
どうでしょう

195
00:12:37,324 --> 00:12:42,930
音楽プレーヤーや
アラームなどの開発では重要です

196
00:12:43,230 --> 00:12:47,067
ユーザ体験を左右するからです

197
00:12:49,002 --> 00:12:52,439
注意してほしいのですが
アプリケーションは

198
00:12:53,207 --> 00:12:58,078
デバイス上の他のシステムと
同時に実行されます

199
00:12:58,512 --> 00:13:01,882
iMessageやFaceTimeなどです

200
00:12:58,512 --> 00:13:01,882
iMessageやFaceTimeなどです

201
00:13:02,482 --> 00:13:05,986
エネルギー効率を高めるために

202
00:13:06,119 --> 00:13:08,655
ワークロードを最小化します

203
00:13:10,023 --> 00:13:13,627
もう少し掘り下げてみましょう

204
00:13:14,461 --> 00:13:15,863
バックグラウンドでは

205
00:13:15,963 --> 00:13:20,601
使用中のサブシステムの
利用が可能です

206
00:13:20,801 --> 00:13:24,037
ただし エネルギーの消費は

207
00:13:24,138 --> 00:13:27,741
フォアグラウンドの方が
優先されます

208
00:13:28,242 --> 00:13:33,647
ワークロードを最小化し
それらを邪魔しないことが大事です

209
00:13:34,615 --> 00:13:38,519
全タスクを
まとめて処理するとしたら？

210
00:13:38,952 --> 00:13:41,989
例えば
ネートワーキング関連の処理を

211
00:13:42,089 --> 00:13:45,692
バックグラウンドで
多数 抱えていたら

212
00:13:45,993 --> 00:13:49,696
一括で処理することが最善でしょう

213
00:13:50,097 --> 00:13:53,734
他の処理への影響は
最小限で済みます

214
00:13:55,169 --> 00:13:57,337
その分かりやすい例が

215
00:13:57,437 --> 00:14:00,807
アプリケーションの
アナリティクスです

216
00:13:57,437 --> 00:14:00,807
アプリケーションの
アナリティクスです

217
00:14:01,775 --> 00:14:05,746
皆さんはアナリティクスを
すぐに送信するでしょう

218
00:14:05,846 --> 00:14:09,483
クラッシュしないデータセットを

219
00:14:09,583 --> 00:14:11,985
ビルドできるからです

220
00:14:12,953 --> 00:14:15,422
ただ エネルギー非効率です

221
00:14:15,856 --> 00:14:19,026
都度 アナリティクスを
送っていると

222
00:14:19,126 --> 00:14:21,528
ハードウェアが過剰に使われます

223
00:14:22,696 --> 00:14:25,866
電力と時間の関係を見てみましょう

224
00:14:26,533 --> 00:14:29,970
送信の都度
リソースが使われ

225
00:14:30,070 --> 00:14:33,073
続いて アイドルとなります

226
00:14:34,007 --> 00:14:37,110
グラフでは
山は３つだけですが

227
00:14:37,244 --> 00:14:41,815
実際のアプリケーションでは
影響は かなりのものです

228
00:14:44,017 --> 00:14:46,653
解決策は至ってシンプルです

229
00:14:47,888 --> 00:14:50,457
バッチ処理を行うのです

230
00:14:50,924 --> 00:14:54,795
それをサポートするAPIは
たくさんあり

231
00:14:54,895 --> 00:14:57,064
主たるものがNSURLSessionです

232
00:14:57,798 --> 00:15:00,501
discretionaryプロパティや

233
00:14:57,798 --> 00:15:00,501
discretionaryプロパティや

234
00:15:00,601 --> 00:15:03,437
バックグラウンドセッションに
利用し

235
00:15:03,537 --> 00:15:06,340
迅速に最適化できます

236
00:15:08,342 --> 00:15:09,743
これが正解です

237
00:15:11,144 --> 00:15:15,516
エネルギーと時間の関係を
見てみましょう

238
00:15:16,917 --> 00:15:19,820
アナリティクスの
アップロードなどには

239
00:15:19,920 --> 00:15:22,923
多少 時間がかかるでしょうが

240
00:15:23,023 --> 00:15:26,627
エネルギー量は
はるかに少なく済みます

241
00:15:26,760 --> 00:15:29,263
消費するのは一度だけです

242
00:15:29,563 --> 00:15:34,434
バックグラウンドでの処理を
一括で実行したからです

243
00:15:35,302 --> 00:15:40,274
タスク完了には
多くのエネルギーを費やしますが

244
00:15:40,374 --> 00:15:45,012
他のアプリケーションを
邪魔する心配はなくなります

245
00:15:47,214 --> 00:15:51,785
タスクを素早く完了させることも
いい例です

246
00:15:52,586 --> 00:15:56,323
バックグラウンドで
有用なAPIがあります

247
00:15:57,157 --> 00:16:00,727
UIKitやVoIP
PushKitなどです

248
00:15:57,157 --> 00:16:00,727
UIKitやVoIP
PushKitなどです

249
00:16:01,995 --> 00:16:06,066
バックグラウンド処理が
必要なくなった場合に

250
00:16:06,166 --> 00:16:08,235
指示することができます

251
00:16:10,637 --> 00:16:15,275
バックグラウンドモードでの処理が
終わったことを―

252
00:16:15,642 --> 00:16:19,513
完了ハンドラを呼び出し
知らせるのです

253
00:16:20,080 --> 00:16:22,149
タスクの完了を忘れたり

254
00:16:22,249 --> 00:16:27,287
保留したいと
考えたりすることもあります

255
00:16:27,821 --> 00:16:29,590
タスクは時間切れになり―

256
00:16:30,791 --> 00:16:33,427
多大なエネルギーが使われます

257
00:16:34,561 --> 00:16:39,366
開発時には
気付かないかもしれません

258
00:16:40,167 --> 00:16:43,670
なぜエネルギー効率が
低いのでしょう

259
00:16:44,638 --> 00:16:50,043
バックグラウンドのタスクを
完了させずに置いておくと

260
00:16:50,344 --> 00:16:55,315
タスクが時間切れになり
アイドル状態に入ります

261
00:16:55,415 --> 00:16:57,985
バックグラウンドの
アプリケーションは

262
00:16:58,085 --> 00:17:01,021
エネルギーを消費しますが

263
00:16:58,085 --> 00:17:01,021
エネルギーを消費しますが

264
00:17:01,255 --> 00:17:03,190
他には何も起きていません

265
00:17:03,557 --> 00:17:08,328
システムの稼働が続くので
オーバーヘッドも長く続き

266
00:17:08,428 --> 00:17:10,063
サブシステムは―

267
00:17:10,164 --> 00:17:13,634
タスクの完了を待っています

268
00:17:15,335 --> 00:17:16,869
解決するには

269
00:17:17,204 --> 00:17:21,608
利用可能な時は
完了ハンドラを呼び出します

270
00:17:22,675 --> 00:17:25,779
代表例は
UIBackgroundTaskで

271
00:17:25,878 --> 00:17:30,250
このAPIとUIKitを呼び出せます

272
00:17:30,717 --> 00:17:35,489
実行すべき処理がないことを
システムに伝えれば

273
00:17:35,589 --> 00:17:37,458
エネルギーを節約し

274
00:17:37,558 --> 00:17:40,794
ハードウェアを
アイドル状態にできます

275
00:17:41,428 --> 00:17:44,198
グラフで見てみましょう

276
00:17:44,898 --> 00:17:48,635
アクティブな時間が短くなり

277
00:17:48,735 --> 00:17:51,705
オーバーヘッドも
大幅に減りました

278
00:17:52,973 --> 00:17:57,110
シンプルですが
エネルギーへの影響は絶大です

279
00:18:01,348 --> 00:18:06,220
エネルギー効率の
プロセスについてお話ししました

280
00:18:06,553 --> 00:18:10,390
様々な処理を最適化していけば

281
00:18:10,557 --> 00:18:14,761
エネルギー消費の最適化も
大きく進みます

282
00:18:16,563 --> 00:18:18,599
より掘り下げるために

283
00:18:18,699 --> 00:18:23,337
最適化の裏にある
コードの話に移りましょう

284
00:18:23,437 --> 00:18:28,041
昨年のセッションの視聴を
お勧めします

285
00:18:28,709 --> 00:18:31,578
高効率なデザインの例や

286
00:18:31,678 --> 00:18:36,617
興味深いリソースが
たくさん見つかると思います

287
00:18:40,521 --> 00:18:45,659
エネルギー効率の改善方法を
ご紹介してきました

288
00:18:46,760 --> 00:18:50,264
アプリケーションの裏側にある―

289
00:18:50,397 --> 00:18:55,269
ハードウェアに関しても
重点的に説明しました

290
00:18:55,736 --> 00:18:57,838
これらを定量化し

291
00:18:57,971 --> 00:19:02,276
アプリケーションでの
実際の影響を理解しましょう

292
00:18:57,971 --> 00:19:02,276
アプリケーションでの
実際の影響を理解しましょう

293
00:19:03,177 --> 00:19:07,981
そのために必要なツールを
ご紹介します

294
00:19:10,050 --> 00:19:14,621
エネルギーの影響の定量化には
２つのツールが有用です

295
00:19:15,389 --> 00:19:19,760
まずXcodeのデバッガから
アクセスできるゲージです

296
00:19:20,460 --> 00:19:24,731
このゲージは
高速かつ反復の処理に役立ち

297
00:19:24,898 --> 00:19:27,100
エネルギー消費を

298
00:19:27,568 --> 00:19:30,370
理解しやすくするツールです

299
00:19:31,572 --> 00:19:36,677
ゲージでは不十分なら
Developer Toolkitも使えます

300
00:19:37,344 --> 00:19:41,515
デバイス上のサブシステムを
深く分析し

301
00:19:41,615 --> 00:19:47,154
そのパフォーマンスについて
理解することができます

302
00:19:48,622 --> 00:19:50,557
ゲージから見ていきます

303
00:19:51,892 --> 00:19:55,162
Xcodeのデバッガから入手でき

304
00:19:55,262 --> 00:19:57,097
使い方は簡単です

305
00:19:58,298 --> 00:19:59,800
これがUIです

306
00:19:59,900 --> 00:20:02,369
エネルギーの影響の列や

307
00:19:59,900 --> 00:20:02,369
エネルギーの影響の列や

308
00:20:02,469 --> 00:20:07,007
３つのセクションにより
構成されています

309
00:20:07,741 --> 00:20:10,744
基準ゲージが左上にあります

310
00:20:11,345 --> 00:20:15,415
“低い”から
“非常に高い”まで振れて

311
00:20:15,516 --> 00:20:19,920
その時のエネルギーの影響を
瞬時に表します

312
00:20:20,888 --> 00:20:26,026
ゲージは消費量を
相対的に示しているだけなので

313
00:20:26,126 --> 00:20:31,064
“高い”からといって
望ましくない状態とは限りません

314
00:20:31,765 --> 00:20:33,400
望ましいかどうかは

315
00:20:33,500 --> 00:20:38,172
デベロッパが
妥当と捉えるかどうか次第です

316
00:20:39,573 --> 00:20:43,076
右上にあるのは Average
Component Utilizationです

317
00:20:43,610 --> 00:20:49,116
エネルギー全体における
各要素の使用率が―

318
00:20:49,216 --> 00:20:53,086
この円グラフから把握できます

319
00:20:53,921 --> 00:20:57,925
サブシステムの状態が分かり
便利です

320
00:20:58,025 --> 00:21:01,562
オーバーヘッドや
要素ごとのエネルギーが

321
00:20:58,025 --> 00:21:01,562
オーバーヘッドや
要素ごとのエネルギーが

322
00:21:01,662 --> 00:21:05,065
過剰かどうかも分かります

323
00:21:06,800 --> 00:21:11,438
すぐ下には
時系列のグラフがあります

324
00:21:11,738 --> 00:21:14,708
アプリケーションの実行中の

325
00:21:14,808 --> 00:21:18,545
各要素の平均的な使用状況を
表します

326
00:21:18,879 --> 00:21:20,881
アプリケーション実行が―

327
00:21:20,981 --> 00:21:24,418
フォアグラウンドか
バックグランドかも

328
00:21:24,518 --> 00:21:26,153
ここで見られます

329
00:21:27,120 --> 00:21:31,425
実行状況を
リアルタイムで確認できます

330
00:21:33,727 --> 00:21:35,996
ゲージは優れたツールで―

331
00:21:36,797 --> 00:21:41,168
ハイレベルな分析や
プロファイリングに有用です

332
00:21:41,502 --> 00:21:42,503
それがカギです

333
00:21:42,703 --> 00:21:47,741
デベロッパとして
何かを実現させようとする際に

334
00:21:48,108 --> 00:21:53,247
エネルギーについて考えるための
足掛かりとなります

335
00:21:55,482 --> 00:21:58,652
ゲージだけでは不十分なら？

336
00:21:59,753 --> 00:22:01,155
Instrumentsの出番です

337
00:21:59,753 --> 00:22:01,155
Instrumentsの出番です

338
00:22:01,889 --> 00:22:03,991
ゲージのUIを通じて

339
00:22:04,091 --> 00:22:06,693
サブシステムと
最も関わりの深い―

340
00:22:06,793 --> 00:22:09,630
３つのInstrumentsに
アクセスできます

341
00:22:10,931 --> 00:22:13,400
含まれるのは
Time Profilerと

342
00:22:13,500 --> 00:22:16,370
Network Profiler
Location Profilerです

343
00:22:17,171 --> 00:22:20,674
アクセスすると
現在のデバッグセッションを

344
00:22:20,774 --> 00:22:24,878
それらのInstrumentsに移せます

345
00:22:26,246 --> 00:22:31,518
Time ProfilerのUIについて
理解していきましょう

346
00:22:33,487 --> 00:22:36,823
非常に標準的なUIを有していますが

347
00:22:36,924 --> 00:22:39,827
とても使いやすいものです

348
00:22:40,194 --> 00:22:41,195
ご覧ください

349
00:22:42,329 --> 00:22:44,731
Time ProfilerのUIです

350
00:22:45,132 --> 00:22:51,171
上部のバーはInstrumentsの
様々なコントロールを表します

351
00:22:51,371 --> 00:22:53,574
左上には再生･停止ボタン

352
00:22:53,674 --> 00:22:56,443
プロファイリングのターゲットが
あります

353
00:22:56,777 --> 00:22:58,812
右上の＋ボタンで

354
00:22:58,912 --> 00:23:01,882
他のInstrumentsを
プロファイリングペインへ

355
00:22:58,912 --> 00:23:01,882
他のInstrumentsを
プロファイリングペインへ

356
00:23:01,982 --> 00:23:05,419
ドラッグアンドドロップできます

357
00:23:06,220 --> 00:23:11,325
実行中のInstrumentsを
確認できます

358
00:23:11,925 --> 00:23:15,596
Time Profilerでは
CPUの消費状況や

359
00:23:15,696 --> 00:23:19,800
時間との関係を
グラフで確認できます

360
00:23:21,602 --> 00:23:24,037
その下の重み付きコールグラフでは

361
00:23:24,137 --> 00:23:26,874
CPUの使用状況を―

362
00:23:26,974 --> 00:23:29,243
見ることができます

363
00:23:30,077 --> 00:23:34,982
何の処理が呼び出され
どの程度の重みが―

364
00:23:35,082 --> 00:23:38,285
CPU時間にかかっているかもです

365
00:23:39,486 --> 00:23:44,358
右には スタックトレースが
まとめられています

366
00:23:44,825 --> 00:23:49,263
プロファイリングの際の
最も重いスタックです

367
00:23:50,964 --> 00:23:53,567
Instrumentsは実に便利です

368
00:23:54,601 --> 00:23:56,003
例えば これです

369
00:23:58,038 --> 00:24:01,842
Instrumentsは
複数の用途に使えます

370
00:23:58,038 --> 00:24:01,842
Instrumentsは
複数の用途に使えます

371
00:24:02,242 --> 00:24:06,046
例えば根本原因解析においてもです

372
00:24:06,146 --> 00:24:10,083
特定のサブシステムで
問題があるとします

373
00:24:11,018 --> 00:24:14,755
Time Profilerや
Network Profilerを使えば

374
00:24:14,855 --> 00:24:17,724
問題を素早く特定できます

375
00:24:18,425 --> 00:24:23,096
緻密なプロファイリングにも
非常に有用です

376
00:24:23,697 --> 00:24:27,568
アルゴリズムの
実行時間の削減などで―

377
00:24:27,668 --> 00:24:30,838
CPU効率を改善したとします

378
00:24:31,505 --> 00:24:35,909
最適化の効果が
サブシステムに浸透しているか

379
00:24:36,009 --> 00:24:39,046
Instrumentsで確認できます

380
00:24:40,447 --> 00:24:44,985
Instrumentsは
ある用途にも効果的です

381
00:24:45,652 --> 00:24:47,354
アンテザードプロファイリングです

382
00:24:48,322 --> 00:24:51,725
Energy Logという
Instrumentsを使うと

383
00:24:51,892 --> 00:24:55,162
アプリケーションの使用中
デバイス上で

384
00:24:55,295 --> 00:24:58,365
アンテザードプロファイリングが
可能です

385
00:24:58,599 --> 00:25:01,068
デベロッパ設定から使えます

386
00:24:58,599 --> 00:25:01,068
デベロッパ設定から使えます

387
00:25:01,301 --> 00:25:02,903
実行中も

388
00:25:03,003 --> 00:25:07,775
いつもどおりに
アプリケーションが使えます

389
00:25:08,208 --> 00:25:12,179
完了後はデベロッパツールから
記録を停止し

390
00:25:12,279 --> 00:25:14,815
Instrumentsで
トレースをアップロード

391
00:25:15,215 --> 00:25:18,986
環境的要因が
効率を下げていないか

392
00:25:19,086 --> 00:25:21,121
確認できます

393
00:25:23,123 --> 00:25:25,893
ツールやコンセプトを
お話ししました

394
00:25:26,093 --> 00:25:27,928
実践に移ります

395
00:25:28,228 --> 00:25:31,798
これらをうまく組み合わせて

396
00:25:31,899 --> 00:25:35,102
エネルギー効率を向上させます

397
00:25:39,439 --> 00:25:42,609
Energy Gameというゲームでは

398
00:25:42,709 --> 00:25:47,648
画面にスプライトが描かれ
バグを注入できます

399
00:25:47,848 --> 00:25:51,685
View Controller内は
AppDelegateだけで

400
00:25:51,785 --> 00:25:52,986
主な目的は

401
00:25:53,086 --> 00:25:57,257
コード処理時の
ツールの活用法を伝えることです

402
00:25:58,592 --> 00:26:03,664
XcodeのUIにて
Energy Gameをビルドし実行します

403
00:25:58,592 --> 00:26:03,664
XcodeのUIにて
Energy Gameをビルドし実行します

404
00:26:04,064 --> 00:26:06,533
右側に バッテリースプライトが

405
00:26:06,633 --> 00:26:10,204
ランダムに描かれていますね

406
00:26:10,671 --> 00:26:12,539
シンプルです

407
00:26:12,940 --> 00:26:17,778
Xcodeデバッガに入り
Energy Impactに移ると

408
00:26:17,878 --> 00:26:19,580
ゲージが表示されます

409
00:26:21,081 --> 00:26:23,217
先ほどのUIです

410
00:26:23,317 --> 00:26:26,186
３つのエリアが表示されています

411
00:26:26,386 --> 00:26:29,022
アプリケーションが
実行しているのは

412
00:26:29,122 --> 00:26:33,293
スプライトを画面に
いくつか描くことだけです

413
00:26:33,994 --> 00:26:39,066
オーバーヘッドは
大きくなっているように見えます

414
00:26:39,433 --> 00:26:41,368
ネットワーキングにおいて

415
00:26:41,468 --> 00:26:46,106
スプライトが描かれる都度
数が更新されるからです

416
00:26:46,807 --> 00:26:50,544
ゲージからその影響を確認できます

417
00:26:51,812 --> 00:26:54,815
この辺りで停止させましょう

418
00:26:54,915 --> 00:26:58,051
コードを確認し
仕組みを理解します

419
00:26:59,853 --> 00:27:02,856
View Controllerにある関数は

420
00:26:59,853 --> 00:27:02,856
View Controllerにある関数は

421
00:27:02,956 --> 00:27:05,125
スプライト数を出力します

422
00:27:05,225 --> 00:27:07,461
コネクションオブジェクトを
生成し―

423
00:27:07,561 --> 00:27:10,430
スプライトの数を更新します

424
00:27:10,564 --> 00:27:12,399
AppDelegateに入ります

425
00:27:13,400 --> 00:27:15,636
バックグラウンドにいる時だけ―

426
00:27:15,936 --> 00:27:19,139
数が更新されるようにします

427
00:27:20,374 --> 00:27:23,343
“ネットワーキング最適化”
と名付けました

428
00:27:24,077 --> 00:27:26,246
Energy Gameをリビルドし

429
00:27:26,713 --> 00:27:29,249
ゲージへの影響をお見せします

430
00:27:31,818 --> 00:27:33,921
Energy Gameが実行中です

431
00:27:34,321 --> 00:27:38,926
XcodeデバッガのUIと
Energy Impactに戻ります

432
00:27:39,693 --> 00:27:45,232
ネットワーキングエネルギーも
オーバーヘッドも見られません

433
00:27:45,666 --> 00:27:50,571
ネットワーキングリクエストを
別のエリアに移動させ

434
00:27:50,671 --> 00:27:52,973
頻繁に起こるのを防ぐだけで

435
00:27:53,407 --> 00:27:58,378
エネルギーの影響を
大幅に減らすことができます

436
00:28:00,013 --> 00:28:01,849
次に ゲージを使う際に

437
00:28:01,949 --> 00:28:06,386
注入したバグが
どう見えるかを確認しましょう

438
00:28:07,221 --> 00:28:10,157
バグ１はシンプルですが

439
00:28:10,257 --> 00:28:13,126
CPUスピンの原因になります

440
00:28:13,293 --> 00:28:16,797
開発の現場でも
日常的に起こり得ます

441
00:28:17,464 --> 00:28:19,266
このバグを注入します

442
00:28:20,968 --> 00:28:23,637
Energy Gameの
バックグラウンドに入ると

443
00:28:24,238 --> 00:28:27,775
ゲージのUIにもそれが表れています

444
00:28:28,442 --> 00:28:32,146
要求が移動し
ネットワーキングが行われます

445
00:28:32,613 --> 00:28:35,816
CPUが激しく動いていますね

446
00:28:36,884 --> 00:28:38,819
これがゲージの力です

447
00:28:38,919 --> 00:28:43,123
注入したバグを
ゲージで見られるのです

448
00:28:43,957 --> 00:28:47,361
根本原因を探るため
Time Profilerに入り

449
00:28:47,461 --> 00:28:50,230
デバッグセッションを移します

450
00:28:53,901 --> 00:28:57,704
移行後は
自動で実行されます

451
00:28:59,940 --> 00:29:03,944
重み付きコールグラフが
入力されます

452
00:28:59,940 --> 00:29:03,944
重み付きコールグラフが
入力されます

453
00:29:07,214 --> 00:29:12,719
ディスパッチされたスレッドが
多くのCPU時間を消費します

454
00:29:15,455 --> 00:29:16,423
クロージャが

455
00:29:16,523 --> 00:29:19,426
AppDelegate.Computeに
ありますね

456
00:29:20,127 --> 00:29:23,931
アプリケーションに戻り
正体を理解しましょう

457
00:29:29,837 --> 00:29:31,505
バックグラウンドで

458
00:29:32,139 --> 00:29:35,742
コンピュテーション式を
呼び出しました

459
00:29:36,877 --> 00:29:40,214
コンピュテーション式は
ひどい関数です

460
00:29:40,814 --> 00:29:42,816
バグ１の注入時に

461
00:29:43,016 --> 00:29:47,921
while Trueループと共に
激しく回転し始めます

462
00:29:48,021 --> 00:29:50,557
デモでは分かりやすいですが

463
00:29:50,657 --> 00:29:52,960
ゲージとTime Profilerで

464
00:29:53,060 --> 00:29:55,896
発生場所が
すぐに見つかります

465
00:29:56,530 --> 00:29:59,566
while Trueループはイマイチです

466
00:30:00,334 --> 00:30:02,236
コメントアウトします

467
00:30:04,004 --> 00:30:06,473
私はコメントアウトが大好きです

468
00:30:07,541 --> 00:30:09,710
Energy Gameをリビルドします

469
00:30:13,480 --> 00:30:16,583
ゲージに戻り 問題がないかを確認

470
00:30:16,683 --> 00:30:18,886
再びバグ１を注入します

471
00:30:22,790 --> 00:30:24,091
バックグラウンドへ

472
00:30:29,730 --> 00:30:32,866
順調に動きつつ
CPUスピンはなし

473
00:30:33,500 --> 00:30:35,102
解決です

474
00:30:35,435 --> 00:30:39,173
使ったツールは２つ
所要時間は１分弱です

475
00:30:39,606 --> 00:30:41,141
ツールによって

476
00:30:41,241 --> 00:30:46,046
速い処理や
根本原因の解析が可能になりました

477
00:30:47,181 --> 00:30:48,782
スライドに戻ります

478
00:30:54,955 --> 00:30:56,757
ポイントをまとめます

479
00:30:58,358 --> 00:31:02,029
まず速い反復処理には
ゲージが有用です

480
00:30:58,358 --> 00:31:02,029
まず速い反復処理には
ゲージが有用です

481
00:31:02,930 --> 00:31:06,233
問題の迅速な発見を助け

482
00:31:06,633 --> 00:31:09,536
解決へと導いてくれます

483
00:31:11,638 --> 00:31:13,407
次に Instrumentsは

484
00:31:13,874 --> 00:31:16,710
緻密なプロファイリングに
役立ちます

485
00:31:18,078 --> 00:31:20,247
最後に アプリケーションでは

486
00:31:20,347 --> 00:31:25,586
エネルギー効率の向上が
極めて重要です

487
00:31:26,086 --> 00:31:28,956
エネルギーの消費状況や
根本原因は

488
00:31:29,056 --> 00:31:33,093
ご紹介したツールを使って
把握できます

489
00:31:34,328 --> 00:31:37,231
すべてが完了したとしましょう

490
00:31:37,731 --> 00:31:41,335
アプリケーションの配信も―

491
00:31:41,435 --> 00:31:43,337
予定通り完了

492
00:31:43,437 --> 00:31:44,438
次の問題は？

493
00:31:44,972 --> 00:31:48,575
バッテリー寿命への不満が
出たら？

494
00:31:48,876 --> 00:31:50,644
次に頼る手段は？

495
00:31:51,345 --> 00:31:54,448
ここからは同僚のデビッドが

496
00:31:54,548 --> 00:31:59,920
別のツールによる解決策を
お伝えします

497
00:32:01,221 --> 00:32:05,259
(拍手)

498
00:32:05,359 --> 00:32:08,195
こんにちは　デビッドと申します

499
00:32:08,295 --> 00:32:13,133
Energy Debuggingに役立つ
新たなツールをご紹介します

500
00:32:15,836 --> 00:32:17,337
App StoreやTestFlightで

501
00:32:17,838 --> 00:32:20,474
アプリケーションを
配信している方は

502
00:32:20,574 --> 00:32:22,676
ぜひ参考にしてください

503
00:32:23,744 --> 00:32:25,712
アプリケーションの配信後

504
00:32:26,413 --> 00:32:30,651
その動作状況を
どうやって確認しますか？

505
00:32:31,251 --> 00:32:36,924
カスタマーが バッテリー寿命の
悪化につながるような問題を

506
00:32:37,024 --> 00:32:39,093
抱えていたとしたら？

507
00:32:40,327 --> 00:32:43,464
こんなレビューを残されたら？

508
00:32:44,598 --> 00:32:47,334
“このアプリケーションのせいで
バッテリーがすぐ切れる”

509
00:32:48,368 --> 00:32:51,071
あるいはレビューもなく

510
00:32:51,705 --> 00:32:55,976
アプリケーションを
削除される可能性もあります

511
00:32:56,677 --> 00:32:58,045
エネルギーの問題を

512
00:32:58,145 --> 00:33:01,482
配信後に把握するのは困難です

513
00:32:58,145 --> 00:33:01,482
配信後に把握するのは困難です

514
00:33:02,616 --> 00:33:05,185
仮に把握できたとしても

515
00:33:05,552 --> 00:33:09,323
それをどうやって
デバッグしますか？

516
00:33:11,058 --> 00:33:15,596
Instrumentsや
ゲージは便利ですが

517
00:33:16,163 --> 00:33:20,634
事象が分からなければ
再現は困難です

518
00:33:21,468 --> 00:33:23,437
カスタマー側で

519
00:33:23,737 --> 00:33:27,374
Wi-Fi環境が不安定な
ケースもあります

520
00:33:28,375 --> 00:33:30,878
同じ環境とは限りません

521
00:33:32,846 --> 00:33:35,249
非常に難しい課題です

522
00:33:37,651 --> 00:33:41,488
こうした問題を
デバッグするために

523
00:33:41,855 --> 00:33:44,491
新しい方法をご紹介します

524
00:33:46,160 --> 00:33:49,963
Xcode Energy Logsと
Xcode Energy Organizerです

525
00:33:50,631 --> 00:33:52,900
まずXcode Energy Logsは

526
00:33:53,000 --> 00:33:57,070
デバイス上の問題を
報告できるツールです

527
00:33:57,638 --> 00:34:00,007
Xcode Energy Organizerは

528
00:33:57,638 --> 00:34:00,007
Xcode Energy Organizerは

529
00:34:00,107 --> 00:34:02,876
Energy Logを
閲覧するツールです

530
00:34:04,311 --> 00:34:08,916
問題解決に必要なデータを
入手できる―

531
00:34:10,050 --> 00:34:13,219
これまでにないツールです

532
00:34:13,387 --> 00:34:14,554
始めましょう

533
00:34:16,123 --> 00:34:20,194
Xcode Energy Logsでは
デバイスから問題を報告できます

534
00:34:21,995 --> 00:34:27,234
まずCPUが多く使われるような
イベントを考えます

535
00:34:27,900 --> 00:34:31,038
Energy Logの
重み付きコールグラフは

536
00:34:31,138 --> 00:34:34,074
コード内の問題箇所を
指摘します

537
00:34:35,007 --> 00:34:38,946
ログはTestFlightや
App Storeから利用でき

538
00:34:39,045 --> 00:34:43,583
カスタマー側の問題を
データで把握できます

539
00:34:44,083 --> 00:34:48,088
バッテリーに関わる
ユーザ体験を改善できます

540
00:34:50,090 --> 00:34:53,726
Xcode Energy Logは
いつ生成されるのでしょう

541
00:34:54,661 --> 00:34:59,967
CPUに多大な負荷をかける
アプリケーションを例に取ります

542
00:35:00,801 --> 00:35:03,570
負荷はかかることもあります

543
00:35:04,705 --> 00:35:08,775
ただ それが
長時間に及ぶとしたら？

544
00:35:12,179 --> 00:35:15,449
高いCPUエネルギーが検知されます

545
00:35:17,184 --> 00:35:20,921
エネルギーが高いという判断には

546
00:35:21,155 --> 00:35:22,856
２つの基準があります

547
00:35:23,090 --> 00:35:26,727
１つ目は CPUの80％以上が
フォアグラウンドで

548
00:35:26,827 --> 00:35:29,763
３分以上 回転していること

549
00:35:30,230 --> 00:35:33,801
２つ目は CPUの80％以上が
バックグラウンドで

550
00:35:33,901 --> 00:35:36,370
１分以上 回転していること

551
00:35:37,104 --> 00:35:38,138
後者のケースでは

552
00:35:38,238 --> 00:35:42,342
アプリケーションの
故障を招きかねません

553
00:35:45,112 --> 00:35:47,881
それぞれのEnergy Logは

554
00:35:47,981 --> 00:35:51,852
CPUの使いすぎに対し
警告を出すのです

555
00:35:52,619 --> 00:35:54,588
分かりやすく言うと

556
00:35:54,988 --> 00:36:00,561
警告を出すのは １％以下の
バッテリーの低下が起きた時です

557
00:35:54,988 --> 00:36:00,561
警告を出すのは １％以下の
バッテリーの低下が起きた時です

558
00:36:01,729 --> 00:36:06,066
１％なら 大した数値じゃないと
思いますか？

559
00:36:07,000 --> 00:36:08,202
実際はどうでしょう

560
00:36:09,169 --> 00:36:13,407
iPhone 6sで
バッテリーが１％増えれば

561
00:36:13,774 --> 00:36:17,511
ユーザは８分長く
通話が可能です

562
00:36:17,945 --> 00:36:20,414
または６分長くネットを閲覧

563
00:36:20,914 --> 00:36:23,851
30分長く
音楽を聴くことも

564
00:36:24,718 --> 00:36:27,121
先ほどのペースが続けば

565
00:36:28,055 --> 00:36:30,157
バッテリーはさらに低下します

566
00:36:30,557 --> 00:36:34,328
CPUの効率化は
非常に重要です

567
00:36:34,428 --> 00:36:36,430
ユーザは ごまかせません

568
00:36:37,898 --> 00:36:42,135
Energy Logには
便利な機能が３つあります

569
00:36:42,736 --> 00:36:47,041
まず 報告が起きた原因を示す
コンテキスト

570
00:36:47,374 --> 00:36:49,109
“CPUの80％が―”

571
00:36:49,309 --> 00:36:52,913
“３分以上 回転しました”
といった具合です

572
00:36:53,981 --> 00:36:58,785
２つ目はEnergy Logの
生成場所を示すメタデータです

573
00:36:59,153 --> 00:37:01,688
iPhoneなのかiPadなのか

574
00:36:59,153 --> 00:37:01,688
iPhoneなのかiPadなのか

575
00:37:02,022 --> 00:37:04,491
ビルドナンバーも分かります

576
00:37:05,492 --> 00:37:08,028
最も重要な３つ目の機能は

577
00:37:08,128 --> 00:37:12,199
問題箇所を示す
重み付きコールグラフです

578
00:37:13,100 --> 00:37:15,569
このグラフはどう生成され

579
00:37:16,036 --> 00:37:20,073
問題のデバッグに
どう役立つのでしょう

580
00:37:23,477 --> 00:37:26,547
main関数から成る
プログラムを考えます

581
00:37:26,647 --> 00:37:31,084
method1やmethod2 method3
method4も含まれます

582
00:37:33,620 --> 00:37:38,125
高消費のイベント発生まで
コードが実行されます

583
00:37:40,594 --> 00:37:44,298
バックトレースは
１秒に１回の間隔で

584
00:37:44,465 --> 00:37:47,167
継続的にサンプリングされます

585
00:37:47,734 --> 00:37:49,403
各バックトレースは

586
00:37:49,670 --> 00:37:54,375
実行時にアクティブな
フレームのサンプルです

587
00:37:55,809 --> 00:37:57,778
１つ目のバックトレースは

588
00:37:57,945 --> 00:38:01,548
method1とmethod2が
アクティブだったことを示します

589
00:37:57,945 --> 00:38:01,548
method1とmethod2が
アクティブだったことを示します

590
00:38:04,017 --> 00:38:05,185
２つ目は―

591
00:38:05,285 --> 00:38:08,922
method3とmethod4が
アクティブだったことを示します

592
00:38:10,457 --> 00:38:11,425
以下も同じです

593
00:38:17,464 --> 00:38:22,502
全体像を形成すべく
バックトレースを結合します

594
00:38:23,370 --> 00:38:28,709
この重み付きコールグラフは
非常に役に立ちます

595
00:38:29,343 --> 00:38:34,047
６つのサンプルすべてに
mainが含まれていました

596
00:38:34,982 --> 00:38:37,751
常に実行されていた証拠です

597
00:38:38,919 --> 00:38:42,489
method1はサンプルが
５つありましたが

598
00:38:43,223 --> 00:38:45,826
method3の場合は１つです

599
00:38:47,027 --> 00:38:50,931
method1の中では
method2が３つと―

600
00:38:51,031 --> 00:38:53,700
method3が１つの
サンプルでした

601
00:38:54,468 --> 00:38:59,306
これでコードの実行場所や
所要時間についての

602
00:38:59,406 --> 00:39:01,642
全体像が見えてきます

603
00:38:59,406 --> 00:39:01,642
全体像が見えてきます

604
00:39:04,912 --> 00:39:07,014
Energy Logが生成される時

605
00:39:07,514 --> 00:39:11,819
バックトレースが１秒に１回
サンプリングされます

606
00:39:12,152 --> 00:39:13,787
各バックトレースには―

607
00:39:15,122 --> 00:39:18,859
CPUが実行する
アクティブフレームが含まれます

608
00:39:19,626 --> 00:39:24,231
バックトレースは
サンプル数によって集約され

609
00:39:24,731 --> 00:39:29,703
サンプル数は
コードの実行頻度を示します

610
00:39:30,370 --> 00:39:35,509
コールグラフは 予期せぬ
ワークロードの発見にも使えます

611
00:39:37,578 --> 00:39:41,315
Energy Logへの
アクセス方法は？

612
00:39:42,783 --> 00:39:45,786
Energy Logは
デバイス上で生成されます

613
00:39:46,720 --> 00:39:50,524
ベータテスターと
オプトインしたカスタマーが

614
00:39:50,858 --> 00:39:53,727
Appleに向けて
ログをアップロードします

615
00:39:54,595 --> 00:39:57,831
ログの数は
数千に上ることがあるので

616
00:39:58,565 --> 00:40:01,535
私たちが それらを集約します

617
00:39:58,565 --> 00:40:01,535
私たちが それらを集約します

618
00:40:01,635 --> 00:40:06,507
ソートし 重大な問題を
リストアップします

619
00:40:07,307 --> 00:40:12,713
Xcode Energy Organizerを使い
ダウンロードし閲覧できます

620
00:40:14,281 --> 00:40:17,451
Xcode Energy Organizerは
デバッグする上で

621
00:40:17,551 --> 00:40:20,420
司令部として機能します

622
00:40:21,421 --> 00:40:25,325
Energy Logを
非常に見やすくしてくれます

623
00:40:26,560 --> 00:40:29,930
TestFlightやApp Storeに
接続しており

624
00:40:30,030 --> 00:40:32,699
iOSのアプリケーションが
確認できます

625
00:40:35,502 --> 00:40:40,574
配信後の問題発生の頻度について
統計も得られます

626
00:40:42,009 --> 00:40:46,647
影響したデバイスの数により
問題をソートします

627
00:40:48,482 --> 00:40:52,252
重み付きコールグラフで
様々なログを

628
00:40:52,486 --> 00:40:55,422
飛ばしながら見ることも可能

629
00:40:57,691 --> 00:41:01,295
Open in Projectを使うと
コードベースへ移動し

630
00:40:57,691 --> 00:41:01,295
Open in Projectを使うと
コードベースへ移動し

631
00:41:01,395 --> 00:41:03,831
デバッグを始められます

632
00:41:04,365 --> 00:41:06,533
実際にお見せしましょう

633
00:41:15,676 --> 00:41:18,845
ログインし Energy Gameを―

634
00:41:18,946 --> 00:41:23,784
App Store内のTestFlightに
アップロード済みです

635
00:41:24,952 --> 00:41:28,722
Energy Organizerの起動は
Windowから―

636
00:41:30,824 --> 00:41:32,092
Organizerをクリック

637
00:41:35,829 --> 00:41:38,165
Energy OrganizerのUIです

638
00:41:39,366 --> 00:41:42,402
Energyタブを選択します

639
00:41:43,370 --> 00:41:48,142
Crashesオーガナイザに
よく似たUIです

640
00:41:48,942 --> 00:41:51,545
左にはアプリケーションのリスト

641
00:41:52,479 --> 00:41:55,416
隣には 優先度の高い問題のリスト

642
00:41:56,116 --> 00:41:58,418
中央はコールグラフです

643
00:41:59,086 --> 00:42:03,624
右には 問題に関する統計が
見られます

644
00:41:59,086 --> 00:42:03,624
右には 問題に関する統計が
見られます

645
00:42:04,658 --> 00:42:07,161
左に注目してください

646
00:42:07,794 --> 00:42:11,031
Energy Gameを選択します

647
00:42:12,399 --> 00:42:15,269
ビルドナンバーも確認しましょう

648
00:42:19,973 --> 00:42:25,279
影響したデバイスの数により
問題がソートされています

649
00:42:27,281 --> 00:42:29,449
１つ目の問題を見ます

650
00:42:30,651 --> 00:42:33,053
影響したデバイス数は64個

651
00:42:36,890 --> 00:42:40,761
右のペインに
詳細が表示されています

652
00:42:41,495 --> 00:42:45,198
発生頻度の内訳も出ています

653
00:42:45,399 --> 00:42:50,571
発生したデバイスは
iPadと iPodと iPod touch

654
00:42:51,371 --> 00:42:55,509
過去２週間の発生分布も分かります

655
00:42:56,777 --> 00:42:58,645
重み付きコールグラフを見ます

656
00:43:01,849 --> 00:43:05,886
dispatch call blockで
多くの時間が費やされ

657
00:43:05,986 --> 00:43:09,323
コンピュテーション式が
呼び出されています

658
00:43:10,624 --> 00:43:12,726
ボタンをクリックし

659
00:43:13,360 --> 00:43:16,130
コードベースにジャンプします

660
00:43:21,869 --> 00:43:24,371
コード画面に戻りました

661
00:43:25,005 --> 00:43:26,340
左に見えるのは

662
00:43:26,440 --> 00:43:30,010
コールグラフからの
サンプルのバックトレースです

663
00:43:32,146 --> 00:43:35,949
コンピュテーション式に
時間が費やされています

664
00:43:37,417 --> 00:43:42,422
まさに先ほど
フィルが話していた関数です

665
00:43:49,196 --> 00:43:50,330
フィルが―

666
00:43:51,932 --> 00:43:56,070
コメントアウトし
問題は解決済みですね

667
00:43:56,170 --> 00:43:58,105
オーガナイザに戻ります

668
00:44:04,545 --> 00:44:09,249
ボタンをクリックし
解決済みとします

669
00:44:10,184 --> 00:44:16,323
次回 Energy Organizerを開くと
解決済みとして表示されます

670
00:44:17,891 --> 00:44:21,461
次は 42個のデバイスに
影響した問題です

671
00:44:22,763 --> 00:44:27,701
まず画面下部の
３つの機能を見てください

672
00:44:29,770 --> 00:44:32,773
まず ページスルーログです

673
00:44:33,707 --> 00:44:37,044
５つあるログのサンプルの中から

674
00:44:37,144 --> 00:44:39,279
１つを選ぶことができます

675
00:44:42,382 --> 00:44:43,784
見てみると―

676
00:44:44,585 --> 00:44:47,821
重み付きコールグラフが
少し異なります

677
00:44:48,155 --> 00:44:50,057
これでも構いません

678
00:44:50,157 --> 00:44:53,594
バックトレースやグラフは
サンプルですからね

679
00:44:54,528 --> 00:44:57,564
しかし グループ化したからには

680
00:44:57,664 --> 00:45:00,667
これらのログは
似通っているべきです

681
00:44:57,664 --> 00:45:00,667
これらのログは
似通っているべきです

682
00:45:02,903 --> 00:45:06,206
このボタンをクリックすると

683
00:45:06,306 --> 00:45:11,678
隠れていたライブラリフレームが
姿を現します

684
00:45:12,913 --> 00:45:15,549
こちらのボタンは―

685
00:45:15,782 --> 00:45:19,353
サンプル数の少ないフレームが
表示されます

686
00:45:19,887 --> 00:45:23,657
デフォルトでは
ほとんどが隠され

687
00:45:23,757 --> 00:45:26,627
重要なものだけが表示されます

688
00:45:34,435 --> 00:45:36,103
関数を見てみます

689
00:45:38,639 --> 00:45:42,376
heavyTimer関数で
時間が費やされています

690
00:45:42,943 --> 00:45:45,846
このバグはフィルが処理するので

691
00:45:45,946 --> 00:45:49,083
名前を変更しておきます

692
00:45:50,450 --> 00:45:52,119
“フィルのバグ”としよう

693
00:45:56,757 --> 00:45:58,258
では次のバグへ

694
00:45:59,159 --> 00:46:00,894
もう１つ見ましょう

695
00:45:59,159 --> 00:46:00,894
もう１つ見ましょう

696
00:46:13,540 --> 00:46:16,076
ここでは
setNextUpdateTimerと

697
00:46:16,176 --> 00:46:19,379
addNewSpriteで
時間がかかっています

698
00:46:19,680 --> 00:46:22,583
この関数を調べましょう

699
00:46:25,686 --> 00:46:27,087
コードを見ます

700
00:46:37,131 --> 00:46:41,969
addNewSprite関数で
時間がかかっていますね

701
00:46:42,603 --> 00:46:45,005
この関数は高くつくようです

702
00:46:46,140 --> 00:46:50,477
このワークロードは
想定どおりでしょうか？

703
00:46:51,245 --> 00:46:54,147
この場合 そうとは言えません

704
00:46:54,348 --> 00:46:59,219
スプライトを加えるのは
数秒に一度のはずです

705
00:46:59,453 --> 00:47:03,223
なぜこんなにも
CPUを食うのでしょう

706
00:46:59,453 --> 00:47:03,223
なぜこんなにも
CPUを食うのでしょう

707
00:47:04,258 --> 00:47:06,994
呼び出し元のバックトレースは？

708
00:47:08,162 --> 00:47:11,431
setNextUpdateTimerです

709
00:47:12,166 --> 00:47:13,734
この関数の動作は？

710
00:47:18,005 --> 00:47:22,476
setNextUpdateTimerの中に
addNewSpriteがあります

711
00:47:23,644 --> 00:47:28,415
この関数を次に呼び出す
タイミングを設定すべく

712
00:47:28,515 --> 00:47:31,685
updateTimerが生成されています

713
00:47:33,420 --> 00:47:36,423
このタイマーはnowと
nextUpdateIntervalの間で

714
00:47:36,857 --> 00:47:38,625
作動します

715
00:47:40,427 --> 00:47:45,065
nextUpdateIntervalは
ゼロまでデクリメントされ

716
00:47:46,133 --> 00:47:50,604
こちらのコードに従って
再び初期化されます

717
00:47:52,539 --> 00:47:54,441
問題は ここです

718
00:47:55,509 --> 00:47:57,978
timeIntervalSince
lastUpdateDateは

719
00:47:58,145 --> 00:48:00,414
負の値かも知れません

720
00:47:58,145 --> 00:48:00,414
負の値かも知れません

721
00:48:01,315 --> 00:48:03,350
ユーザがシステムを―

722
00:48:03,450 --> 00:48:06,553
だまそうとする時に起きがちです

723
00:48:07,087 --> 00:48:11,358
ゲーム中 時間を
リセットしたい場合や

724
00:48:11,759 --> 00:48:14,528
ゲームオーバーを避けるべく

725
00:48:14,628 --> 00:48:18,632
システム設定で
時計を24時間前に戻すのです

726
00:48:19,600 --> 00:48:23,904
するとnextUpdateIntervalは
負の値になります

727
00:48:24,538 --> 00:48:29,009
タイマーは過去の時間に
設定されると

728
00:48:29,343 --> 00:48:34,047
すぐに作動し
自身を何度も呼び出します

729
00:48:34,948 --> 00:48:37,584
つまりは無限ループです

730
00:48:39,586 --> 00:48:41,922
幸い 修復は簡単です

731
00:48:42,656 --> 00:48:44,725
この関数を書き換えます

732
00:48:45,792 --> 00:48:48,195
ゼロもしくはゼロ未満に変えれば

733
00:48:48,295 --> 00:48:52,966
nextUpdateIntervalが負の値でも
ループから抜け出せます

734
00:48:54,401 --> 00:48:58,238
エネルギーの問題を
よく表した例です

735
00:48:58,338 --> 00:49:03,344
通常のテストだけでは
極めて把握しにくい問題ですが

736
00:48:58,338 --> 00:49:03,344
通常のテストだけでは
極めて把握しにくい問題ですが

737
00:49:03,744 --> 00:49:07,247
フィールドからのデータで
浮き彫りになります

738
00:49:08,448 --> 00:49:13,487
それこそがEnergy Logと
Energy Organizerの実力です

739
00:49:14,521 --> 00:49:17,458
このデモのポイントは３つです

740
00:49:18,625 --> 00:49:23,497
まずEnergy Organizerで 重大な
エネルギーの問題を発見すること

741
00:49:24,264 --> 00:49:28,202
どれほど重大か
どのくらい起きているか

742
00:49:28,469 --> 00:49:31,905
デバイスについても確認します

743
00:49:33,073 --> 00:49:37,844
次に 重み付きコールグラフで
問題箇所を見つけること

744
00:49:38,479 --> 00:49:41,615
異常なサンプル数に
注意してください

745
00:49:42,549 --> 00:49:45,085
想定外のワークロードにもです

746
00:49:46,220 --> 00:49:50,991
最後に Open in Projectで
コードに直接ジャンプし

747
00:49:51,091 --> 00:49:55,996
必要に応じて修正を加えることです

748
00:49:58,332 --> 00:50:00,067
総括します

749
00:49:58,332 --> 00:50:00,067
総括します

750
00:50:03,103 --> 00:50:07,774
まずエネルギーを
最優先の課題として捉えること

751
00:50:07,875 --> 00:50:12,112
デザインや開発 テスト
あらゆる側面においてです

752
00:50:12,913 --> 00:50:15,549
次に ツールの活用

753
00:50:16,383 --> 00:50:18,719
エネルギーゲージや
Instrumentsによる

754
00:50:18,819 --> 00:50:20,187
プロファイリングです

755
00:50:21,088 --> 00:50:26,093
最後に 新しいXcode Energy
Organizerを使いこなし

756
00:50:26,193 --> 00:50:29,897
エネルギーの問題の解決に
役立ててください

757
00:50:31,531 --> 00:50:34,835
詳しい情報は
こちらのURLからどうぞ

758
00:50:35,536 --> 00:50:40,741
気になる方は
お気軽にラボへお越しください

759
00:50:41,341 --> 00:50:42,743
ありがとうございました

760
00:50:42,843 --> 00:50:47,114
(拍手)